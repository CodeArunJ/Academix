/*! For license information please see main.193d5b99.js.LICENSE.txt */
(()=>{var e={4:(e,t,n)=>{"use strict";var r=n(853),a=n(43),s=n(950);function i(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function l(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function u(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function c(e){if(l(e)!==e)throw Error(i(188))}function d(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e;for(e=e.child;null!==e;){if(null!==(t=d(e)))return t;e=e.sibling}return null}var h=Object.assign,p=Symbol.for("react.element"),f=Symbol.for("react.transitional.element"),m=Symbol.for("react.portal"),g=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),y=Symbol.for("react.profiler"),x=Symbol.for("react.provider"),v=Symbol.for("react.consumer"),w=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),S=Symbol.for("react.suspense"),I=Symbol.for("react.suspense_list"),N=Symbol.for("react.memo"),C=Symbol.for("react.lazy");Symbol.for("react.scope");var T=Symbol.for("react.activity");Symbol.for("react.legacy_hidden"),Symbol.for("react.tracing_marker");var E=Symbol.for("react.memo_cache_sentinel");Symbol.for("react.view_transition");var $=Symbol.iterator;function R(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=$&&e[$]||e["@@iterator"])?e:null}var _=Symbol.for("react.client.reference");function A(e){if(null==e)return null;if("function"===typeof e)return e.$$typeof===_?null:e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case g:return"Fragment";case y:return"Profiler";case b:return"StrictMode";case S:return"Suspense";case I:return"SuspenseList";case T:return"Activity"}if("object"===typeof e)switch(e.$$typeof){case m:return"Portal";case w:return(e.displayName||"Context")+".Provider";case v:return(e._context.displayName||"Context")+".Consumer";case k:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case N:return null!==(t=e.displayName||null)?t:A(e.type)||"Memo";case C:t=e._payload,e=e._init;try{return A(e(t))}catch(n){}}return null}var F=Array.isArray,D=a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,O=s.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,L={pending:!1,data:null,method:null,action:null},M=[],z=-1;function P(e){return{current:e}}function B(e){0>z||(e.current=M[z],M[z]=null,z--)}function W(e,t){z++,M[z]=e.current,e.current=t}var U=P(null),j=P(null),V=P(null),G=P(null);function H(e,t){switch(W(V,t),W(j,e),W(U,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?ad(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)e=sd(t=ad(t),e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}B(U),W(U,e)}function q(){B(U),B(j),B(V)}function K(e){null!==e.memoizedState&&W(G,e);var t=U.current,n=sd(t,e.type);t!==n&&(W(j,e),W(U,n))}function X(e){j.current===e&&(B(U),B(j)),G.current===e&&(B(G),Kd._currentValue=L)}var Y=Object.prototype.hasOwnProperty,Q=r.unstable_scheduleCallback,J=r.unstable_cancelCallback,Z=r.unstable_shouldYield,ee=r.unstable_requestPaint,te=r.unstable_now,ne=r.unstable_getCurrentPriorityLevel,re=r.unstable_ImmediatePriority,ae=r.unstable_UserBlockingPriority,se=r.unstable_NormalPriority,ie=r.unstable_LowPriority,oe=r.unstable_IdlePriority,le=r.log,ue=r.unstable_setDisableYieldValue,ce=null,de=null;function he(e){if("function"===typeof le&&ue(e),de&&"function"===typeof de.setStrictMode)try{de.setStrictMode(ce,e)}catch(t){}}var pe=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(fe(e)/me|0)|0},fe=Math.log,me=Math.LN2;var ge=256,be=4194304;function ye(e){var t=42&e;if(0!==t)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194048&e;case 4194304:case 8388608:case 16777216:case 33554432:return 62914560&e;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function xe(e,t,n){var r=e.pendingLanes;if(0===r)return 0;var a=0,s=e.suspendedLanes,i=e.pingedLanes;e=e.warmLanes;var o=134217727&r;return 0!==o?0!==(r=o&~s)?a=ye(r):0!==(i&=o)?a=ye(i):n||0!==(n=o&~e)&&(a=ye(n)):0!==(o=r&~s)?a=ye(o):0!==i?a=ye(i):n||0!==(n=r&~e)&&(a=ye(n)),0===a?0:0!==t&&t!==a&&0===(t&s)&&((s=a&-a)>=(n=t&-t)||32===s&&0!==(4194048&n))?t:a}function ve(e,t){return 0===(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)}function we(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ke(){var e=ge;return 0===(4194048&(ge<<=1))&&(ge=256),e}function Se(){var e=be;return 0===(62914560&(be<<=1))&&(be=4194304),e}function Ie(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Ne(e,t){e.pendingLanes|=t,268435456!==t&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function Ce(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-pe(t);e.entangledLanes|=t,e.entanglements[r]=1073741824|e.entanglements[r]|4194090&n}function Te(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-pe(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}function Ee(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function $e(e){return 2<(e&=-e)?8<e?0!==(134217727&e)?32:268435456:8:2}function Re(){var e=O.p;return 0!==e?e:void 0===(e=window.event)?32:uh(e.type)}var _e=Math.random().toString(36).slice(2),Ae="__reactFiber$"+_e,Fe="__reactProps$"+_e,De="__reactContainer$"+_e,Oe="__reactEvents$"+_e,Le="__reactListeners$"+_e,Me="__reactHandles$"+_e,ze="__reactResources$"+_e,Pe="__reactMarker$"+_e;function Be(e){delete e[Ae],delete e[Fe],delete e[Oe],delete e[Le],delete e[Me]}function We(e){var t=e[Ae];if(t)return t;for(var n=e.parentNode;n;){if(t=n[De]||n[Ae]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=xd(e);null!==e;){if(n=e[Ae])return n;e=xd(e)}return t}n=(e=n).parentNode}return null}function Ue(e){if(e=e[Ae]||e[De]){var t=e.tag;if(5===t||6===t||13===t||26===t||27===t||3===t)return e}return null}function je(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e.stateNode;throw Error(i(33))}function Ve(e){var t=e[ze];return t||(t=e[ze]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Ge(e){e[Pe]=!0}var He=new Set,qe={};function Ke(e,t){Xe(e,t),Xe(e+"Capture",t)}function Xe(e,t){for(qe[e]=t,e=0;e<t.length;e++)He.add(t[e])}var Ye,Qe,Je=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Ze={},et={};function tt(e,t,n){if(a=t,Y.call(et,a)||!Y.call(Ze,a)&&(Je.test(a)?et[a]=!0:(Ze[a]=!0,0)))if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":return void e.removeAttribute(t);case"boolean":var r=t.toLowerCase().slice(0,5);if("data-"!==r&&"aria-"!==r)return void e.removeAttribute(t)}e.setAttribute(t,""+n)}var a}function nt(e,t,n){if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(t)}e.setAttribute(t,""+n)}}function rt(e,t,n,r){if(null===r)e.removeAttribute(n);else{switch(typeof r){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(n)}e.setAttributeNS(t,n,""+r)}}function at(e){if(void 0===Ye)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Ye=t&&t[1]||"",Qe=-1<n.stack.indexOf("\n    at")?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return"\n"+Ye+e+Qe}var st=!1;function it(e,t){if(!e||st)return"";st=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(a){var r=a}Reflect.construct(e,[],n)}else{try{n.call()}catch(s){r=s}e.call(n.prototype)}}else{try{throw Error()}catch(i){r=i}(n=e())&&"function"===typeof n.catch&&n.catch((function(){}))}}catch(o){if(o&&r&&"string"===typeof o.stack)return[o.stack,r.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var a=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,"name");a&&a.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var s=r.DetermineComponentFrameRoot(),i=s[0],o=s[1];if(i&&o){var l=i.split("\n"),u=o.split("\n");for(a=r=0;r<l.length&&!l[r].includes("DetermineComponentFrameRoot");)r++;for(;a<u.length&&!u[a].includes("DetermineComponentFrameRoot");)a++;if(r===l.length||a===u.length)for(r=l.length-1,a=u.length-1;1<=r&&0<=a&&l[r]!==u[a];)a--;for(;1<=r&&0<=a;r--,a--)if(l[r]!==u[a]){if(1!==r||1!==a)do{if(r--,0>--a||l[r]!==u[a]){var c="\n"+l[r].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=r&&0<=a);break}}}finally{st=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?at(n):""}function ot(e){switch(e.tag){case 26:case 27:case 5:return at(e.type);case 16:return at("Lazy");case 13:return at("Suspense");case 19:return at("SuspenseList");case 0:case 15:return it(e.type,!1);case 11:return it(e.type.render,!1);case 1:return it(e.type,!0);case 31:return at("Activity");default:return""}}function lt(e){try{var t="";do{t+=ot(e),e=e.return}while(e);return t}catch(n){return"\nError generating stack: "+n.message+"\n"+n.stack}}function ut(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function ct(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function dt(e){e._valueTracker||(e._valueTracker=function(e){var t=ct(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function ht(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=ct(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function pt(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}var ft=/[\n"\\]/g;function mt(e){return e.replace(ft,(function(e){return"\\"+e.charCodeAt(0).toString(16)+" "}))}function gt(e,t,n,r,a,s,i,o){e.name="",null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i?e.type=i:e.removeAttribute("type"),null!=t?"number"===i?(0===t&&""===e.value||e.value!=t)&&(e.value=""+ut(t)):e.value!==""+ut(t)&&(e.value=""+ut(t)):"submit"!==i&&"reset"!==i||e.removeAttribute("value"),null!=t?yt(e,i,ut(t)):null!=n?yt(e,i,ut(n)):null!=r&&e.removeAttribute("value"),null==a&&null!=s&&(e.defaultChecked=!!s),null!=a&&(e.checked=a&&"function"!==typeof a&&"symbol"!==typeof a),null!=o&&"function"!==typeof o&&"symbol"!==typeof o&&"boolean"!==typeof o?e.name=""+ut(o):e.removeAttribute("name")}function bt(e,t,n,r,a,s,i,o){if(null!=s&&"function"!==typeof s&&"symbol"!==typeof s&&"boolean"!==typeof s&&(e.type=s),null!=t||null!=n){if(!("submit"!==s&&"reset"!==s||void 0!==t&&null!==t))return;n=null!=n?""+ut(n):"",t=null!=t?""+ut(t):n,o||t===e.value||(e.value=t),e.defaultValue=t}r="function"!==typeof(r=null!=r?r:a)&&"symbol"!==typeof r&&!!r,e.checked=o?e.checked:!!r,e.defaultChecked=!!r,null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i&&(e.name=i)}function yt(e,t,n){"number"===t&&pt(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function xt(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+ut(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function vt(e,t,n){null==t||((t=""+ut(t))!==e.value&&(e.value=t),null!=n)?e.defaultValue=null!=n?""+ut(n):"":e.defaultValue!==t&&(e.defaultValue=t)}function wt(e,t,n,r){if(null==t){if(null!=r){if(null!=n)throw Error(i(92));if(F(r)){if(1<r.length)throw Error(i(93));r=r[0]}n=r}null==n&&(n=""),t=n}n=ut(t),e.defaultValue=n,(r=e.textContent)===n&&""!==r&&null!==r&&(e.value=r)}function kt(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var St=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function It(e,t,n){var r=0===t.indexOf("--");null==n||"boolean"===typeof n||""===n?r?e.setProperty(t,""):"float"===t?e.cssFloat="":e[t]="":r?e.setProperty(t,n):"number"!==typeof n||0===n||St.has(t)?"float"===t?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function Nt(e,t,n){if(null!=t&&"object"!==typeof t)throw Error(i(62));if(e=e.style,null!=n){for(var r in n)!n.hasOwnProperty(r)||null!=t&&t.hasOwnProperty(r)||(0===r.indexOf("--")?e.setProperty(r,""):"float"===r?e.cssFloat="":e[r]="");for(var a in t)r=t[a],t.hasOwnProperty(a)&&n[a]!==r&&It(e,a,r)}else for(var s in t)t.hasOwnProperty(s)&&It(e,s,t[s])}function Ct(e){if(-1===e.indexOf("-"))return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Tt=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Et=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function $t(e){return Et.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var Rt=null;function _t(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var At=null,Ft=null;function Dt(e){var t=Ue(e);if(t&&(e=t.stateNode)){var n=e[Fe]||null;e:switch(e=t.stateNode,t.type){case"input":if(gt(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+mt(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=r[Fe]||null;if(!a)throw Error(i(90));gt(r,a.value,a.defaultValue,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name)}}for(t=0;t<n.length;t++)(r=n[t]).form===e.form&&ht(r)}break e;case"textarea":vt(e,n.value,n.defaultValue);break e;case"select":null!=(t=n.value)&&xt(e,!!n.multiple,t,!1)}}}var Ot=!1;function Lt(e,t,n){if(Ot)return e(t,n);Ot=!0;try{return e(t)}finally{if(Ot=!1,(null!==At||null!==Ft)&&(Wu(),At&&(t=At,e=Ft,Ft=At=null,Dt(t),e)))for(t=0;t<e.length;t++)Dt(e[t])}}function Mt(e,t){var n=e.stateNode;if(null===n)return null;var r=n[Fe]||null;if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}var zt=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),Pt=!1;if(zt)try{var Bt={};Object.defineProperty(Bt,"passive",{get:function(){Pt=!0}}),window.addEventListener("test",Bt,Bt),window.removeEventListener("test",Bt,Bt)}catch(Fh){Pt=!1}var Wt=null,Ut=null,jt=null;function Vt(){if(jt)return jt;var e,t,n=Ut,r=n.length,a="value"in Wt?Wt.value:Wt.textContent,s=a.length;for(e=0;e<r&&n[e]===a[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===a[s-t];t++);return jt=a.slice(e,1<t?1-t:void 0)}function Gt(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function Ht(){return!0}function qt(){return!1}function Kt(e){function t(t,n,r,a,s){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(a):a[i]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?Ht:qt,this.isPropagationStopped=qt,this}return h(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=Ht)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=Ht)},persist:function(){},isPersistent:Ht}),t}var Xt,Yt,Qt,Jt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Zt=Kt(Jt),en=h({},Jt,{view:0,detail:0}),tn=Kt(en),nn=h({},en,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:fn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Qt&&(Qt&&"mousemove"===e.type?(Xt=e.screenX-Qt.screenX,Yt=e.screenY-Qt.screenY):Yt=Xt=0,Qt=e),Xt)},movementY:function(e){return"movementY"in e?e.movementY:Yt}}),rn=Kt(nn),an=Kt(h({},nn,{dataTransfer:0})),sn=Kt(h({},en,{relatedTarget:0})),on=Kt(h({},Jt,{animationName:0,elapsedTime:0,pseudoElement:0})),ln=Kt(h({},Jt,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),un=Kt(h({},Jt,{data:0})),cn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},dn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},hn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function pn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=hn[e])&&!!t[e]}function fn(){return pn}var mn=Kt(h({},en,{key:function(e){if(e.key){var t=cn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Gt(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?dn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:fn,charCode:function(e){return"keypress"===e.type?Gt(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Gt(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),gn=Kt(h({},nn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),bn=Kt(h({},en,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:fn})),yn=Kt(h({},Jt,{propertyName:0,elapsedTime:0,pseudoElement:0})),xn=Kt(h({},nn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),vn=Kt(h({},Jt,{newState:0,oldState:0})),wn=[9,13,27,32],kn=zt&&"CompositionEvent"in window,Sn=null;zt&&"documentMode"in document&&(Sn=document.documentMode);var In=zt&&"TextEvent"in window&&!Sn,Nn=zt&&(!kn||Sn&&8<Sn&&11>=Sn),Cn=String.fromCharCode(32),Tn=!1;function En(e,t){switch(e){case"keyup":return-1!==wn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function $n(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Rn=!1;var _n={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function An(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!_n[e.type]:"textarea"===t}function Fn(e,t,n,r){At?Ft?Ft.push(r):Ft=[r]:At=r,0<(t=Vc(t,"onChange")).length&&(n=new Zt("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Dn=null,On=null;function Ln(e){Lc(e,0)}function Mn(e){if(ht(je(e)))return e}function zn(e,t){if("change"===e)return t}var Pn=!1;if(zt){var Bn;if(zt){var Wn="oninput"in document;if(!Wn){var Un=document.createElement("div");Un.setAttribute("oninput","return;"),Wn="function"===typeof Un.oninput}Bn=Wn}else Bn=!1;Pn=Bn&&(!document.documentMode||9<document.documentMode)}function jn(){Dn&&(Dn.detachEvent("onpropertychange",Vn),On=Dn=null)}function Vn(e){if("value"===e.propertyName&&Mn(On)){var t=[];Fn(t,On,e,_t(e)),Lt(Ln,t)}}function Gn(e,t,n){"focusin"===e?(jn(),On=n,(Dn=t).attachEvent("onpropertychange",Vn)):"focusout"===e&&jn()}function Hn(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Mn(On)}function qn(e,t){if("click"===e)return Mn(t)}function Kn(e,t){if("input"===e||"change"===e)return Mn(t)}var Xn="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function Yn(e,t){if(Xn(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!Y.call(t,a)||!Xn(e[a],t[a]))return!1}return!0}function Qn(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Jn(e,t){var n,r=Qn(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=Qn(r)}}function Zn(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?Zn(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function er(e){for(var t=pt((e=null!=e&&null!=e.ownerDocument&&null!=e.ownerDocument.defaultView?e.ownerDocument.defaultView:window).document);t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=pt((e=t.contentWindow).document)}return t}function tr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var nr=zt&&"documentMode"in document&&11>=document.documentMode,rr=null,ar=null,sr=null,ir=!1;function or(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;ir||null==rr||rr!==pt(r)||("selectionStart"in(r=rr)&&tr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},sr&&Yn(sr,r)||(sr=r,0<(r=Vc(ar,"onSelect")).length&&(t=new Zt("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=rr)))}function lr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ur={animationend:lr("Animation","AnimationEnd"),animationiteration:lr("Animation","AnimationIteration"),animationstart:lr("Animation","AnimationStart"),transitionrun:lr("Transition","TransitionRun"),transitionstart:lr("Transition","TransitionStart"),transitioncancel:lr("Transition","TransitionCancel"),transitionend:lr("Transition","TransitionEnd")},cr={},dr={};function hr(e){if(cr[e])return cr[e];if(!ur[e])return e;var t,n=ur[e];for(t in n)if(n.hasOwnProperty(t)&&t in dr)return cr[e]=n[t];return e}zt&&(dr=document.createElement("div").style,"AnimationEvent"in window||(delete ur.animationend.animation,delete ur.animationiteration.animation,delete ur.animationstart.animation),"TransitionEvent"in window||delete ur.transitionend.transition);var pr=hr("animationend"),fr=hr("animationiteration"),mr=hr("animationstart"),gr=hr("transitionrun"),br=hr("transitionstart"),yr=hr("transitioncancel"),xr=hr("transitionend"),vr=new Map,wr="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function kr(e,t){vr.set(e,t),Ke(t,[e])}wr.push("scrollEnd");var Sr=new WeakMap;function Ir(e,t){if("object"===typeof e&&null!==e){var n=Sr.get(e);return void 0!==n?n:(t={value:e,source:t,stack:lt(t)},Sr.set(e,t),t)}return{value:e,source:t,stack:lt(t)}}var Nr=[],Cr=0,Tr=0;function Er(){for(var e=Cr,t=Tr=Cr=0;t<e;){var n=Nr[t];Nr[t++]=null;var r=Nr[t];Nr[t++]=null;var a=Nr[t];Nr[t++]=null;var s=Nr[t];if(Nr[t++]=null,null!==r&&null!==a){var i=r.pending;null===i?a.next=a:(a.next=i.next,i.next=a),r.pending=a}0!==s&&Ar(n,a,s)}}function $r(e,t,n,r){Nr[Cr++]=e,Nr[Cr++]=t,Nr[Cr++]=n,Nr[Cr++]=r,Tr|=r,e.lanes|=r,null!==(e=e.alternate)&&(e.lanes|=r)}function Rr(e,t,n,r){return $r(e,t,n,r),Fr(e)}function _r(e,t){return $r(e,null,null,t),Fr(e)}function Ar(e,t,n){e.lanes|=n;var r=e.alternate;null!==r&&(r.lanes|=n);for(var a=!1,s=e.return;null!==s;)s.childLanes|=n,null!==(r=s.alternate)&&(r.childLanes|=n),22===s.tag&&(null===(e=s.stateNode)||1&e._visibility||(a=!0)),e=s,s=s.return;return 3===e.tag?(s=e.stateNode,a&&null!==t&&(a=31-pe(n),null===(r=(e=s.hiddenUpdates)[a])?e[a]=[t]:r.push(t),t.lane=536870912|n),s):null}function Fr(e){if(50<Au)throw Au=0,Fu=null,Error(i(185));for(var t=e.return;null!==t;)t=(e=t).return;return 3===e.tag?e.stateNode:null}var Dr={};function Or(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Lr(e,t,n,r){return new Or(e,t,n,r)}function Mr(e){return!(!(e=e.prototype)||!e.isReactComponent)}function zr(e,t){var n=e.alternate;return null===n?((n=Lr(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=65011712&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function Pr(e,t){e.flags&=65011714;var n=e.alternate;return null===n?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Br(e,t,n,r,a,s){var o=0;if(r=e,"function"===typeof e)Mr(e)&&(o=1);else if("string"===typeof e)o=function(e,t,n){if(1===n||null!=t.itemProp)return!1;switch(e){case"meta":case"title":return!0;case"style":if("string"!==typeof t.precedence||"string"!==typeof t.href||""===t.href)break;return!0;case"link":if("string"!==typeof t.rel||"string"!==typeof t.href||""===t.href||t.onLoad||t.onError)break;return"stylesheet"!==t.rel||(e=t.disabled,"string"===typeof t.precedence&&null==e);case"script":if(t.async&&"function"!==typeof t.async&&"symbol"!==typeof t.async&&!t.onLoad&&!t.onError&&t.src&&"string"===typeof t.src)return!0}return!1}(e,n,U.current)?26:"html"===e||"head"===e||"body"===e?27:5;else e:switch(e){case T:return(e=Lr(31,n,t,a)).elementType=T,e.lanes=s,e;case g:return Wr(n.children,a,s,t);case b:o=8,a|=24;break;case y:return(e=Lr(12,n,t,2|a)).elementType=y,e.lanes=s,e;case S:return(e=Lr(13,n,t,a)).elementType=S,e.lanes=s,e;case I:return(e=Lr(19,n,t,a)).elementType=I,e.lanes=s,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case x:case w:o=10;break e;case v:o=9;break e;case k:o=11;break e;case N:o=14;break e;case C:o=16,r=null;break e}o=29,n=Error(i(130,null===e?"null":typeof e,"")),r=null}return(t=Lr(o,n,t,a)).elementType=e,t.type=r,t.lanes=s,t}function Wr(e,t,n,r){return(e=Lr(7,e,r,t)).lanes=n,e}function Ur(e,t,n){return(e=Lr(6,e,null,t)).lanes=n,e}function jr(e,t,n){return(t=Lr(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var Vr=[],Gr=0,Hr=null,qr=0,Kr=[],Xr=0,Yr=null,Qr=1,Jr="";function Zr(e,t){Vr[Gr++]=qr,Vr[Gr++]=Hr,Hr=e,qr=t}function ea(e,t,n){Kr[Xr++]=Qr,Kr[Xr++]=Jr,Kr[Xr++]=Yr,Yr=e;var r=Qr;e=Jr;var a=32-pe(r)-1;r&=~(1<<a),n+=1;var s=32-pe(t)+a;if(30<s){var i=a-a%5;s=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Qr=1<<32-pe(t)+a|n<<a|r,Jr=s+e}else Qr=1<<s|n<<a|r,Jr=e}function ta(e){null!==e.return&&(Zr(e,1),ea(e,1,0))}function na(e){for(;e===Hr;)Hr=Vr[--Gr],Vr[Gr]=null,qr=Vr[--Gr],Vr[Gr]=null;for(;e===Yr;)Yr=Kr[--Xr],Kr[Xr]=null,Jr=Kr[--Xr],Kr[Xr]=null,Qr=Kr[--Xr],Kr[Xr]=null}var ra=null,aa=null,sa=!1,ia=null,oa=!1,la=Error(i(519));function ua(e){throw ma(Ir(Error(i(418,"")),e)),la}function ca(e){var t=e.stateNode,n=e.type,r=e.memoizedProps;switch(t[Ae]=e,t[Fe]=r,n){case"dialog":Mc("cancel",t),Mc("close",t);break;case"iframe":case"object":case"embed":Mc("load",t);break;case"video":case"audio":for(n=0;n<Dc.length;n++)Mc(Dc[n],t);break;case"source":Mc("error",t);break;case"img":case"image":case"link":Mc("error",t),Mc("load",t);break;case"details":Mc("toggle",t);break;case"input":Mc("invalid",t),bt(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0),dt(t);break;case"select":Mc("invalid",t);break;case"textarea":Mc("invalid",t),wt(t,r.value,r.defaultValue,r.children),dt(t)}"string"!==typeof(n=r.children)&&"number"!==typeof n&&"bigint"!==typeof n||t.textContent===""+n||!0===r.suppressHydrationWarning||Yc(t.textContent,n)?(null!=r.popover&&(Mc("beforetoggle",t),Mc("toggle",t)),null!=r.onScroll&&Mc("scroll",t),null!=r.onScrollEnd&&Mc("scrollend",t),null!=r.onClick&&(t.onclick=Qc),t=!0):t=!1,t||ua(e)}function da(e){for(ra=e.return;ra;)switch(ra.tag){case 5:case 13:return void(oa=!1);case 27:case 3:return void(oa=!0);default:ra=ra.return}}function ha(e){if(e!==ra)return!1;if(!sa)return da(e),sa=!0,!1;var t,n=e.tag;if((t=3!==n&&27!==n)&&((t=5===n)&&(t=!("form"!==(t=e.type)&&"button"!==t)||id(e.type,e.memoizedProps)),t=!t),t&&aa&&ua(e),da(e),13===n){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType)if("/$"===(t=e.data)){if(0===n){aa=bd(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++;e=e.nextSibling}aa=null}}else 27===n?(n=aa,pd(e.type)?(e=yd,yd=null,aa=e):aa=n):aa=ra?bd(e.stateNode.nextSibling):null;return!0}function pa(){aa=ra=null,sa=!1}function fa(){var e=ia;return null!==e&&(null===xu?xu=e:xu.push.apply(xu,e),ia=null),e}function ma(e){null===ia?ia=[e]:ia.push(e)}var ga=P(null),ba=null,ya=null;function xa(e,t,n){W(ga,t._currentValue),t._currentValue=n}function va(e){e._currentValue=ga.current,B(ga)}function wa(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function ka(e,t,n,r){var a=e.child;for(null!==a&&(a.return=e);null!==a;){var s=a.dependencies;if(null!==s){var o=a.child;s=s.firstContext;e:for(;null!==s;){var l=s;s=a;for(var u=0;u<t.length;u++)if(l.context===t[u]){s.lanes|=n,null!==(l=s.alternate)&&(l.lanes|=n),wa(s.return,n,e),r||(o=null);break e}s=l.next}}else if(18===a.tag){if(null===(o=a.return))throw Error(i(341));o.lanes|=n,null!==(s=o.alternate)&&(s.lanes|=n),wa(o,n,e),o=null}else o=a.child;if(null!==o)o.return=a;else for(o=a;null!==o;){if(o===e){o=null;break}if(null!==(a=o.sibling)){a.return=o.return,o=a;break}o=o.return}a=o}}function Sa(e,t,n,r){e=null;for(var a=t,s=!1;null!==a;){if(!s)if(0!==(524288&a.flags))s=!0;else if(0!==(262144&a.flags))break;if(10===a.tag){var o=a.alternate;if(null===o)throw Error(i(387));if(null!==(o=o.memoizedProps)){var l=a.type;Xn(a.pendingProps.value,o.value)||(null!==e?e.push(l):e=[l])}}else if(a===G.current){if(null===(o=a.alternate))throw Error(i(387));o.memoizedState.memoizedState!==a.memoizedState.memoizedState&&(null!==e?e.push(Kd):e=[Kd])}a=a.return}null!==e&&ka(t,e,n,r),t.flags|=262144}function Ia(e){for(e=e.firstContext;null!==e;){if(!Xn(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Na(e){ba=e,ya=null,null!==(e=e.dependencies)&&(e.firstContext=null)}function Ca(e){return Ea(ba,e)}function Ta(e,t){return null===ba&&Na(e),Ea(e,t)}function Ea(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},null===ya){if(null===e)throw Error(i(308));ya=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else ya=ya.next=t;return n}var $a="undefined"!==typeof AbortController?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach((function(e){return e()}))}},Ra=r.unstable_scheduleCallback,_a=r.unstable_NormalPriority,Aa={$$typeof:w,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Fa(){return{controller:new $a,data:new Map,refCount:0}}function Da(e){e.refCount--,0===e.refCount&&Ra(_a,(function(){e.controller.abort()}))}var Oa=null,La=0,Ma=0,za=null;function Pa(){if(0===--La&&null!==Oa){null!==za&&(za.status="fulfilled");var e=Oa;Oa=null,Ma=0,za=null;for(var t=0;t<e.length;t++)(0,e[t])()}}var Ba=D.S;D.S=function(e,t){"object"===typeof t&&null!==t&&"function"===typeof t.then&&function(e,t){if(null===Oa){var n=Oa=[];La=0,Ma=$c(),za={status:"pending",value:void 0,then:function(e){n.push(e)}}}La++,t.then(Pa,Pa)}(0,t),null!==Ba&&Ba(e,t)};var Wa=P(null);function Ua(){var e=Wa.current;return null!==e?e:ru.pooledCache}function ja(e,t){W(Wa,null===t?Wa.current:t.pool)}function Va(){var e=Ua();return null===e?null:{parent:Aa._currentValue,pool:e}}var Ga=Error(i(460)),Ha=Error(i(474)),qa=Error(i(542)),Ka={then:function(){}};function Xa(e){return"fulfilled"===(e=e.status)||"rejected"===e}function Ya(){}function Qa(e,t,n){switch(void 0===(n=e[n])?e.push(t):n!==t&&(t.then(Ya,Ya),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw es(e=t.reason),e;default:if("string"===typeof t.status)t.then(Ya,Ya);else{if(null!==(e=ru)&&100<e.shellSuspendCounter)throw Error(i(482));(e=t).status="pending",e.then((function(e){if("pending"===t.status){var n=t;n.status="fulfilled",n.value=e}}),(function(e){if("pending"===t.status){var n=t;n.status="rejected",n.reason=e}}))}switch(t.status){case"fulfilled":return t.value;case"rejected":throw es(e=t.reason),e}throw Ja=t,Ga}}var Ja=null;function Za(){if(null===Ja)throw Error(i(459));var e=Ja;return Ja=null,e}function es(e){if(e===Ga||e===qa)throw Error(i(483))}var ts=!1;function ns(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function rs(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function as(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function ss(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&nu)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,t=Fr(e),Ar(e,null,n),t}return $r(e,r,t,n),Fr(e)}function is(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194048&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Te(e,n)}}function os(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var i={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};null===s?a=s=i:s=s.next=i,n=n.next}while(null!==n);null===s?a=s=t:s=s.next=t}else a=s=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,callbacks:r.callbacks},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var ls=!1;function us(){if(ls){if(null!==za)throw za}}function cs(e,t,n,r){ls=!1;var a=e.updateQueue;ts=!1;var s=a.firstBaseUpdate,i=a.lastBaseUpdate,o=a.shared.pending;if(null!==o){a.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?s=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==s){var d=a.baseState;for(i=0,c=u=l=null,o=s;;){var p=-536870913&o.lane,f=p!==o.lane;if(f?(su&p)===p:(r&p)===p){0!==p&&p===Ma&&(ls=!0),null!==c&&(c=c.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});e:{var m=e,g=o;p=t;var b=n;switch(g.tag){case 1:if("function"===typeof(m=g.payload)){d=m.call(b,d,p);break e}d=m;break e;case 3:m.flags=-65537&m.flags|128;case 0:if(null===(p="function"===typeof(m=g.payload)?m.call(b,d,p):m)||void 0===p)break e;d=h({},d,p);break e;case 2:ts=!0}}null!==(p=o.callback)&&(e.flags|=64,f&&(e.flags|=8192),null===(f=a.callbacks)?a.callbacks=[p]:f.push(p))}else f={lane:p,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=f,l=d):c=c.next=f,i|=p;if(null===(o=o.next)){if(null===(o=a.shared.pending))break;o=(f=o).next,f.next=null,a.lastBaseUpdate=f,a.shared.pending=null}}null===c&&(l=d),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=c,null===s&&(a.shared.lanes=0),pu|=i,e.lanes=i,e.memoizedState=d}}function ds(e,t){if("function"!==typeof e)throw Error(i(191,e));e.call(t)}function hs(e,t){var n=e.callbacks;if(null!==n)for(e.callbacks=null,e=0;e<n.length;e++)ds(n[e],t)}var ps=P(null),fs=P(0);function ms(e,t){W(fs,e=du),W(ps,t),du=e|t.baseLanes}function gs(){W(fs,du),W(ps,ps.current)}function bs(){du=fs.current,B(ps),B(fs)}var ys=0,xs=null,vs=null,ws=null,ks=!1,Ss=!1,Is=!1,Ns=0,Cs=0,Ts=null,Es=0;function $s(){throw Error(i(321))}function Rs(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Xn(e[n],t[n]))return!1;return!0}function _s(e,t,n,r,a,s){return ys=s,xs=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,D.H=null===e||null===e.memoizedState?Gi:Hi,Is=!1,s=n(r,a),Is=!1,Ss&&(s=Fs(t,n,r,a)),As(e),s}function As(e){D.H=Vi;var t=null!==vs&&null!==vs.next;if(ys=0,ws=vs=xs=null,ks=!1,Cs=0,Ts=null,t)throw Error(i(300));null===e||To||null!==(e=e.dependencies)&&Ia(e)&&(To=!0)}function Fs(e,t,n,r){xs=e;var a=0;do{if(Ss&&(Ts=null),Cs=0,Ss=!1,25<=a)throw Error(i(301));if(a+=1,ws=vs=null,null!=e.updateQueue){var s=e.updateQueue;s.lastEffect=null,s.events=null,s.stores=null,null!=s.memoCache&&(s.memoCache.index=0)}D.H=qi,s=t(n,r)}while(Ss);return s}function Ds(){var e=D.H,t=e.useState()[0];return t="function"===typeof t.then?Bs(t):t,e=e.useState()[0],(null!==vs?vs.memoizedState:null)!==e&&(xs.flags|=1024),t}function Os(){var e=0!==Ns;return Ns=0,e}function Ls(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function Ms(e){if(ks){for(e=e.memoizedState;null!==e;){var t=e.queue;null!==t&&(t.pending=null),e=e.next}ks=!1}ys=0,ws=vs=xs=null,Ss=!1,Cs=Ns=0,Ts=null}function zs(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ws?xs.memoizedState=ws=e:ws=ws.next=e,ws}function Ps(){if(null===vs){var e=xs.alternate;e=null!==e?e.memoizedState:null}else e=vs.next;var t=null===ws?xs.memoizedState:ws.next;if(null!==t)ws=t,vs=e;else{if(null===e){if(null===xs.alternate)throw Error(i(467));throw Error(i(310))}e={memoizedState:(vs=e).memoizedState,baseState:vs.baseState,baseQueue:vs.baseQueue,queue:vs.queue,next:null},null===ws?xs.memoizedState=ws=e:ws=ws.next=e}return ws}function Bs(e){var t=Cs;return Cs+=1,null===Ts&&(Ts=[]),e=Qa(Ts,e,t),t=xs,null===(null===ws?t.memoizedState:ws.next)&&(t=t.alternate,D.H=null===t||null===t.memoizedState?Gi:Hi),e}function Ws(e){if(null!==e&&"object"===typeof e){if("function"===typeof e.then)return Bs(e);if(e.$$typeof===w)return Ca(e)}throw Error(i(438,String(e)))}function Us(e){var t=null,n=xs.updateQueue;if(null!==n&&(t=n.memoCache),null==t){var r=xs.alternate;null!==r&&(null!==(r=r.updateQueue)&&(null!=(r=r.memoCache)&&(t={data:r.data.map((function(e){return e.slice()})),index:0})))}if(null==t&&(t={data:[],index:0}),null===n&&(n={lastEffect:null,events:null,stores:null,memoCache:null},xs.updateQueue=n),n.memoCache=t,void 0===(n=t.data[t.index]))for(n=t.data[t.index]=Array(e),r=0;r<e;r++)n[r]=E;return t.index++,n}function js(e,t){return"function"===typeof t?t(e):t}function Vs(e){return Gs(Ps(),vs,e)}function Gs(e,t,n){var r=e.queue;if(null===r)throw Error(i(311));r.lastRenderedReducer=n;var a=e.baseQueue,s=r.pending;if(null!==s){if(null!==a){var o=a.next;a.next=s.next,s.next=o}t.baseQueue=a=s,r.pending=null}if(s=e.baseState,null===a)e.memoizedState=s;else{var l=o=null,u=null,c=t=a.next,d=!1;do{var h=-536870913&c.lane;if(h!==c.lane?(su&h)===h:(ys&h)===h){var p=c.revertLane;if(0===p)null!==u&&(u=u.next={lane:0,revertLane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),h===Ma&&(d=!0);else{if((ys&p)===p){c=c.next,p===Ma&&(d=!0);continue}h={lane:0,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=h,o=s):u=u.next=h,xs.lanes|=p,pu|=p}h=c.action,Is&&n(s,h),s=c.hasEagerState?c.eagerState:n(s,h)}else p={lane:h,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=p,o=s):u=u.next=p,xs.lanes|=h,pu|=h;c=c.next}while(null!==c&&c!==t);if(null===u?o=s:u.next=l,!Xn(s,e.memoizedState)&&(To=!0,d&&null!==(n=za)))throw n;e.memoizedState=s,e.baseState=o,e.baseQueue=u,r.lastRenderedState=s}return null===a&&(r.lanes=0),[e.memoizedState,r.dispatch]}function Hs(e){var t=Ps(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,s=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{s=e(s,o.action),o=o.next}while(o!==a);Xn(s,t.memoizedState)||(To=!0),t.memoizedState=s,null===t.baseQueue&&(t.baseState=s),n.lastRenderedState=s}return[s,r]}function qs(e,t,n){var r=xs,a=Ps(),s=sa;if(s){if(void 0===n)throw Error(i(407));n=n()}else n=t();var o=!Xn((vs||a).memoizedState,n);if(o&&(a.memoizedState=n,To=!0),a=a.queue,gi(2048,8,Ys.bind(null,r,a,e),[e]),a.getSnapshot!==t||o||null!==ws&&1&ws.memoizedState.tag){if(r.flags|=2048,pi(9,{destroy:void 0,resource:void 0},Xs.bind(null,r,a,n,t),null),null===ru)throw Error(i(349));s||0!==(124&ys)||Ks(r,t,n)}return n}function Ks(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=xs.updateQueue)?(t={lastEffect:null,events:null,stores:null,memoCache:null},xs.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Xs(e,t,n,r){t.value=n,t.getSnapshot=r,Qs(t)&&Js(e)}function Ys(e,t,n){return n((function(){Qs(t)&&Js(e)}))}function Qs(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Xn(e,n)}catch(r){return!0}}function Js(e){var t=_r(e,2);null!==t&&Lu(t,e,2)}function Zs(e){var t=zs();if("function"===typeof e){var n=e;if(e=n(),Is){he(!0);try{n()}finally{he(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:js,lastRenderedState:e},t}function ei(e,t,n,r){return e.baseState=n,Gs(e,vs,"function"===typeof r?r:js)}function ti(e,t,n,r,a){if(Wi(e))throw Error(i(485));if(null!==(e=t.action)){var s={payload:a,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(e){s.listeners.push(e)}};null!==D.T?n(!0):s.isTransition=!1,r(s),null===(n=t.pending)?(s.next=t.pending=s,ni(t,s)):(s.next=n.next,t.pending=n.next=s)}}function ni(e,t){var n=t.action,r=t.payload,a=e.state;if(t.isTransition){var s=D.T,i={};D.T=i;try{var o=n(a,r),l=D.S;null!==l&&l(i,o),ri(e,t,o)}catch(u){si(e,t,u)}finally{D.T=s}}else try{ri(e,t,s=n(a,r))}catch(c){si(e,t,c)}}function ri(e,t,n){null!==n&&"object"===typeof n&&"function"===typeof n.then?n.then((function(n){ai(e,t,n)}),(function(n){return si(e,t,n)})):ai(e,t,n)}function ai(e,t,n){t.status="fulfilled",t.value=n,ii(t),e.state=n,null!==(t=e.pending)&&((n=t.next)===t?e.pending=null:(n=n.next,t.next=n,ni(e,n)))}function si(e,t,n){var r=e.pending;if(e.pending=null,null!==r){r=r.next;do{t.status="rejected",t.reason=n,ii(t),t=t.next}while(t!==r)}e.action=null}function ii(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function oi(e,t){return t}function li(e,t){if(sa){var n=ru.formState;if(null!==n){e:{var r=xs;if(sa){if(aa){t:{for(var a=aa,s=oa;8!==a.nodeType;){if(!s){a=null;break t}if(null===(a=bd(a.nextSibling))){a=null;break t}}a="F!"===(s=a.data)||"F"===s?a:null}if(a){aa=bd(a.nextSibling),r="F!"===a.data;break e}}ua(r)}r=!1}r&&(t=n[0])}}return(n=zs()).memoizedState=n.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:oi,lastRenderedState:t},n.queue=r,n=zi.bind(null,xs,r),r.dispatch=n,r=Zs(!1),s=Bi.bind(null,xs,!1,r.queue),a={state:t,dispatch:null,action:e,pending:null},(r=zs()).queue=a,n=ti.bind(null,xs,a,s,n),a.dispatch=n,r.memoizedState=e,[t,n,!1]}function ui(e){return ci(Ps(),vs,e)}function ci(e,t,n){if(t=Gs(e,t,oi)[0],e=Vs(js)[0],"object"===typeof t&&null!==t&&"function"===typeof t.then)try{var r=Bs(t)}catch(i){if(i===Ga)throw qa;throw i}else r=t;var a=(t=Ps()).queue,s=a.dispatch;return n!==t.memoizedState&&(xs.flags|=2048,pi(9,{destroy:void 0,resource:void 0},di.bind(null,a,n),null)),[r,s,e]}function di(e,t){e.action=t}function hi(e){var t=Ps(),n=vs;if(null!==n)return ci(t,n,e);Ps(),t=t.memoizedState;var r=(n=Ps()).queue.dispatch;return n.memoizedState=e,[t,r,!1]}function pi(e,t,n,r){return e={tag:e,create:n,deps:r,inst:t,next:null},null===(t=xs.updateQueue)&&(t={lastEffect:null,events:null,stores:null,memoCache:null},xs.updateQueue=t),null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function fi(){return Ps().memoizedState}function mi(e,t,n,r){var a=zs();r=void 0===r?null:r,xs.flags|=e,a.memoizedState=pi(1|t,{destroy:void 0,resource:void 0},n,r)}function gi(e,t,n,r){var a=Ps();r=void 0===r?null:r;var s=a.memoizedState.inst;null!==vs&&null!==r&&Rs(r,vs.memoizedState.deps)?a.memoizedState=pi(t,s,n,r):(xs.flags|=e,a.memoizedState=pi(1|t,s,n,r))}function bi(e,t){mi(8390656,8,e,t)}function yi(e,t){gi(2048,8,e,t)}function xi(e,t){return gi(4,2,e,t)}function vi(e,t){return gi(4,4,e,t)}function wi(e,t){if("function"===typeof t){e=e();var n=t(e);return function(){"function"===typeof n?n():t(null)}}if(null!==t&&void 0!==t)return e=e(),t.current=e,function(){t.current=null}}function ki(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,gi(4,4,wi.bind(null,t,e),n)}function Si(){}function Ii(e,t){var n=Ps();t=void 0===t?null:t;var r=n.memoizedState;return null!==t&&Rs(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Ni(e,t){var n=Ps();t=void 0===t?null:t;var r=n.memoizedState;if(null!==t&&Rs(t,r[1]))return r[0];if(r=e(),Is){he(!0);try{e()}finally{he(!1)}}return n.memoizedState=[r,t],r}function Ci(e,t,n){return void 0===n||0!==(1073741824&ys)?e.memoizedState=t:(e.memoizedState=n,e=Ou(),xs.lanes|=e,pu|=e,n)}function Ti(e,t,n,r){return Xn(n,t)?n:null!==ps.current?(e=Ci(e,n,r),Xn(e,t)||(To=!0),e):0===(42&ys)?(To=!0,e.memoizedState=n):(e=Ou(),xs.lanes|=e,pu|=e,t)}function Ei(e,t,n,r,a){var s=O.p;O.p=0!==s&&8>s?s:8;var i=D.T,o={};D.T=o,Bi(e,!1,t,n);try{var l=a(),u=D.S;if(null!==u&&u(o,l),null!==l&&"object"===typeof l&&"function"===typeof l.then)Pi(e,t,function(e,t){var n=[],r={status:"pending",value:null,reason:null,then:function(e){n.push(e)}};return e.then((function(){r.status="fulfilled",r.value=t;for(var e=0;e<n.length;e++)(0,n[e])(t)}),(function(e){for(r.status="rejected",r.reason=e,e=0;e<n.length;e++)(0,n[e])(void 0)})),r}(l,r),Du());else Pi(e,t,r,Du())}catch(c){Pi(e,t,{then:function(){},status:"rejected",reason:c},Du())}finally{O.p=s,D.T=i}}function $i(){}function Ri(e,t,n,r){if(5!==e.tag)throw Error(i(476));var a=_i(e).queue;Ei(e,a,t,L,null===n?$i:function(){return Ai(e),n(r)})}function _i(e){var t=e.memoizedState;if(null!==t)return t;var n={};return(t={memoizedState:L,baseState:L,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:js,lastRenderedState:L},next:null}).next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:js,lastRenderedState:n},next:null},e.memoizedState=t,null!==(e=e.alternate)&&(e.memoizedState=t),t}function Ai(e){Pi(e,_i(e).next.queue,{},Du())}function Fi(){return Ca(Kd)}function Di(){return Ps().memoizedState}function Oi(){return Ps().memoizedState}function Li(e){for(var t=e.return;null!==t;){switch(t.tag){case 24:case 3:var n=Du(),r=ss(t,e=as(n),n);return null!==r&&(Lu(r,t,n),is(r,t,n)),t={cache:Fa()},void(e.payload=t)}t=t.return}}function Mi(e,t,n){var r=Du();n={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null},Wi(e)?Ui(t,n):null!==(n=Rr(e,t,n,r))&&(Lu(n,e,r),ji(n,t,r))}function zi(e,t,n){Pi(e,t,n,Du())}function Pi(e,t,n,r){var a={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null};if(Wi(e))Ui(t,a);else{var s=e.alternate;if(0===e.lanes&&(null===s||0===s.lanes)&&null!==(s=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=s(i,n);if(a.hasEagerState=!0,a.eagerState=o,Xn(o,i))return $r(e,t,a,0),null===ru&&Er(),!1}catch(l){}if(null!==(n=Rr(e,t,a,r)))return Lu(n,e,r),ji(n,t,r),!0}return!1}function Bi(e,t,n,r){if(r={lane:2,revertLane:$c(),action:r,hasEagerState:!1,eagerState:null,next:null},Wi(e)){if(t)throw Error(i(479))}else null!==(t=Rr(e,n,r,2))&&Lu(t,e,2)}function Wi(e){var t=e.alternate;return e===xs||null!==t&&t===xs}function Ui(e,t){Ss=ks=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function ji(e,t,n){if(0!==(4194048&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Te(e,n)}}var Vi={readContext:Ca,use:Ws,useCallback:$s,useContext:$s,useEffect:$s,useImperativeHandle:$s,useLayoutEffect:$s,useInsertionEffect:$s,useMemo:$s,useReducer:$s,useRef:$s,useState:$s,useDebugValue:$s,useDeferredValue:$s,useTransition:$s,useSyncExternalStore:$s,useId:$s,useHostTransitionStatus:$s,useFormState:$s,useActionState:$s,useOptimistic:$s,useMemoCache:$s,useCacheRefresh:$s},Gi={readContext:Ca,use:Ws,useCallback:function(e,t){return zs().memoizedState=[e,void 0===t?null:t],e},useContext:Ca,useEffect:bi,useImperativeHandle:function(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,mi(4194308,4,wi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return mi(4194308,4,e,t)},useInsertionEffect:function(e,t){mi(4,2,e,t)},useMemo:function(e,t){var n=zs();t=void 0===t?null:t;var r=e();if(Is){he(!0);try{e()}finally{he(!1)}}return n.memoizedState=[r,t],r},useReducer:function(e,t,n){var r=zs();if(void 0!==n){var a=n(t);if(Is){he(!0);try{n(t)}finally{he(!1)}}}else a=t;return r.memoizedState=r.baseState=a,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:a},r.queue=e,e=e.dispatch=Mi.bind(null,xs,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},zs().memoizedState=e},useState:function(e){var t=(e=Zs(e)).queue,n=zi.bind(null,xs,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:Si,useDeferredValue:function(e,t){return Ci(zs(),e,t)},useTransition:function(){var e=Zs(!1);return e=Ei.bind(null,xs,e.queue,!0,!1),zs().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var r=xs,a=zs();if(sa){if(void 0===n)throw Error(i(407));n=n()}else{if(n=t(),null===ru)throw Error(i(349));0!==(124&su)||Ks(r,t,n)}a.memoizedState=n;var s={value:n,getSnapshot:t};return a.queue=s,bi(Ys.bind(null,r,s,e),[e]),r.flags|=2048,pi(9,{destroy:void 0,resource:void 0},Xs.bind(null,r,s,n,t),null),n},useId:function(){var e=zs(),t=ru.identifierPrefix;if(sa){var n=Jr;t="\xab"+t+"R"+(n=(Qr&~(1<<32-pe(Qr)-1)).toString(32)+n),0<(n=Ns++)&&(t+="H"+n.toString(32)),t+="\xbb"}else t="\xab"+t+"r"+(n=Es++).toString(32)+"\xbb";return e.memoizedState=t},useHostTransitionStatus:Fi,useFormState:li,useActionState:li,useOptimistic:function(e){var t=zs();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=Bi.bind(null,xs,!0,n),n.dispatch=t,[e,t]},useMemoCache:Us,useCacheRefresh:function(){return zs().memoizedState=Li.bind(null,xs)}},Hi={readContext:Ca,use:Ws,useCallback:Ii,useContext:Ca,useEffect:yi,useImperativeHandle:ki,useInsertionEffect:xi,useLayoutEffect:vi,useMemo:Ni,useReducer:Vs,useRef:fi,useState:function(){return Vs(js)},useDebugValue:Si,useDeferredValue:function(e,t){return Ti(Ps(),vs.memoizedState,e,t)},useTransition:function(){var e=Vs(js)[0],t=Ps().memoizedState;return["boolean"===typeof e?e:Bs(e),t]},useSyncExternalStore:qs,useId:Di,useHostTransitionStatus:Fi,useFormState:ui,useActionState:ui,useOptimistic:function(e,t){return ei(Ps(),0,e,t)},useMemoCache:Us,useCacheRefresh:Oi},qi={readContext:Ca,use:Ws,useCallback:Ii,useContext:Ca,useEffect:yi,useImperativeHandle:ki,useInsertionEffect:xi,useLayoutEffect:vi,useMemo:Ni,useReducer:Hs,useRef:fi,useState:function(){return Hs(js)},useDebugValue:Si,useDeferredValue:function(e,t){var n=Ps();return null===vs?Ci(n,e,t):Ti(n,vs.memoizedState,e,t)},useTransition:function(){var e=Hs(js)[0],t=Ps().memoizedState;return["boolean"===typeof e?e:Bs(e),t]},useSyncExternalStore:qs,useId:Di,useHostTransitionStatus:Fi,useFormState:hi,useActionState:hi,useOptimistic:function(e,t){var n=Ps();return null!==vs?ei(n,0,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:Us,useCacheRefresh:Oi},Ki=null,Xi=0;function Yi(e){var t=Xi;return Xi+=1,null===Ki&&(Ki=[]),Qa(Ki,e,t)}function Qi(e,t){t=t.props.ref,e.ref=void 0!==t?t:null}function Ji(e,t){if(t.$$typeof===p)throw Error(i(525));throw e=Object.prototype.toString.call(t),Error(i(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Zi(e){return(0,e._init)(e._payload)}function eo(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e){for(var t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function a(e,t){return(e=zr(e,t)).index=0,e.sibling=null,e}function s(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=67108866,n):r:(t.flags|=67108866,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=67108866),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Ur(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function u(e,t,n,r){var s=n.type;return s===g?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===C&&Zi(s)===t.type)?(Qi(t=a(t,n.props),n),t.return=e,t):(Qi(t=Br(n.type,n.key,n.props,null,e.mode,r),n),t.return=e,t)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=jr(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function d(e,t,n,r,s){return null===t||7!==t.tag?((t=Wr(n,e.mode,r,s)).return=e,t):((t=a(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t||"bigint"===typeof t)return(t=Ur(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case f:return Qi(n=Br(t.type,t.key,t.props,null,e.mode,n),t),n.return=e,n;case m:return(t=jr(t,e.mode,n)).return=e,t;case C:return h(e,t=(0,t._init)(t._payload),n)}if(F(t)||R(t))return(t=Wr(t,e.mode,n,null)).return=e,t;if("function"===typeof t.then)return h(e,Yi(t),n);if(t.$$typeof===w)return h(e,Ta(e,t),n);Ji(e,t)}return null}function p(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n||"bigint"===typeof n)return null!==a?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case f:return n.key===a?u(e,t,n,r):null;case m:return n.key===a?c(e,t,n,r):null;case C:return p(e,t,n=(a=n._init)(n._payload),r)}if(F(n)||R(n))return null!==a?null:d(e,t,n,r,null);if("function"===typeof n.then)return p(e,t,Yi(n),r);if(n.$$typeof===w)return p(e,t,Ta(e,n),r);Ji(e,n)}return null}function b(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r||"bigint"===typeof r)return l(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case f:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case m:return c(t,e=e.get(null===r.key?n:r.key)||null,r,a);case C:return b(e,t,n,r=(0,r._init)(r._payload),a)}if(F(r)||R(r))return d(t,e=e.get(n)||null,r,a,null);if("function"===typeof r.then)return b(e,t,n,Yi(r),a);if(r.$$typeof===w)return b(e,t,n,Ta(t,r),a);Ji(t,r)}return null}function y(l,u,c,d){if("object"===typeof c&&null!==c&&c.type===g&&null===c.key&&(c=c.props.children),"object"===typeof c&&null!==c){switch(c.$$typeof){case f:e:{for(var x=c.key;null!==u;){if(u.key===x){if((x=c.type)===g){if(7===u.tag){n(l,u.sibling),(d=a(u,c.props.children)).return=l,l=d;break e}}else if(u.elementType===x||"object"===typeof x&&null!==x&&x.$$typeof===C&&Zi(x)===u.type){n(l,u.sibling),Qi(d=a(u,c.props),c),d.return=l,l=d;break e}n(l,u);break}t(l,u),u=u.sibling}c.type===g?((d=Wr(c.props.children,l.mode,d,c.key)).return=l,l=d):(Qi(d=Br(c.type,c.key,c.props,null,l.mode,d),c),d.return=l,l=d)}return o(l);case m:e:{for(x=c.key;null!==u;){if(u.key===x){if(4===u.tag&&u.stateNode.containerInfo===c.containerInfo&&u.stateNode.implementation===c.implementation){n(l,u.sibling),(d=a(u,c.children||[])).return=l,l=d;break e}n(l,u);break}t(l,u),u=u.sibling}(d=jr(c,l.mode,d)).return=l,l=d}return o(l);case C:return y(l,u,c=(x=c._init)(c._payload),d)}if(F(c))return function(a,i,o,l){for(var u=null,c=null,d=i,f=i=0,m=null;null!==d&&f<o.length;f++){d.index>f?(m=d,d=null):m=d.sibling;var g=p(a,d,o[f],l);if(null===g){null===d&&(d=m);break}e&&d&&null===g.alternate&&t(a,d),i=s(g,i,f),null===c?u=g:c.sibling=g,c=g,d=m}if(f===o.length)return n(a,d),sa&&Zr(a,f),u;if(null===d){for(;f<o.length;f++)null!==(d=h(a,o[f],l))&&(i=s(d,i,f),null===c?u=d:c.sibling=d,c=d);return sa&&Zr(a,f),u}for(d=r(d);f<o.length;f++)null!==(m=b(d,a,f,o[f],l))&&(e&&null!==m.alternate&&d.delete(null===m.key?f:m.key),i=s(m,i,f),null===c?u=m:c.sibling=m,c=m);return e&&d.forEach((function(e){return t(a,e)})),sa&&Zr(a,f),u}(l,u,c,d);if(R(c)){if("function"!==typeof(x=R(c)))throw Error(i(150));return function(a,o,l,u){if(null==l)throw Error(i(151));for(var c=null,d=null,f=o,m=o=0,g=null,y=l.next();null!==f&&!y.done;m++,y=l.next()){f.index>m?(g=f,f=null):g=f.sibling;var x=p(a,f,y.value,u);if(null===x){null===f&&(f=g);break}e&&f&&null===x.alternate&&t(a,f),o=s(x,o,m),null===d?c=x:d.sibling=x,d=x,f=g}if(y.done)return n(a,f),sa&&Zr(a,m),c;if(null===f){for(;!y.done;m++,y=l.next())null!==(y=h(a,y.value,u))&&(o=s(y,o,m),null===d?c=y:d.sibling=y,d=y);return sa&&Zr(a,m),c}for(f=r(f);!y.done;m++,y=l.next())null!==(y=b(f,a,m,y.value,u))&&(e&&null!==y.alternate&&f.delete(null===y.key?m:y.key),o=s(y,o,m),null===d?c=y:d.sibling=y,d=y);return e&&f.forEach((function(e){return t(a,e)})),sa&&Zr(a,m),c}(l,u,c=x.call(c),d)}if("function"===typeof c.then)return y(l,u,Yi(c),d);if(c.$$typeof===w)return y(l,u,Ta(l,c),d);Ji(l,c)}return"string"===typeof c&&""!==c||"number"===typeof c||"bigint"===typeof c?(c=""+c,null!==u&&6===u.tag?(n(l,u.sibling),(d=a(u,c)).return=l,l=d):(n(l,u),(d=Ur(c,l.mode,d)).return=l,l=d),o(l)):n(l,u)}return function(e,t,n,r){try{Xi=0;var a=y(e,t,n,r);return Ki=null,a}catch(i){if(i===Ga||i===qa)throw i;var s=Lr(29,i,null,e.mode);return s.lanes=r,s.return=e,s}}}var to=eo(!0),no=eo(!1),ro=P(null),ao=null;function so(e){var t=e.alternate;W(uo,1&uo.current),W(ro,e),null===ao&&(null===t||null!==ps.current||null!==t.memoizedState)&&(ao=e)}function io(e){if(22===e.tag){if(W(uo,uo.current),W(ro,e),null===ao){var t=e.alternate;null!==t&&null!==t.memoizedState&&(ao=e)}}else oo()}function oo(){W(uo,uo.current),W(ro,ro.current)}function lo(e){B(ro),ao===e&&(ao=null),B(uo)}var uo=P(0);function co(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||gd(n)))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function ho(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:h({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var po={enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Du(),a=as(r);a.payload=t,void 0!==n&&null!==n&&(a.callback=n),null!==(t=ss(e,a,r))&&(Lu(t,e,r),is(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Du(),a=as(r);a.tag=1,a.payload=t,void 0!==n&&null!==n&&(a.callback=n),null!==(t=ss(e,a,r))&&(Lu(t,e,r),is(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Du(),r=as(n);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=ss(e,r,n))&&(Lu(t,e,n),is(t,e,n))}};function fo(e,t,n,r,a,s,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,s,i):!t.prototype||!t.prototype.isPureReactComponent||(!Yn(n,r)||!Yn(a,s))}function mo(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&po.enqueueReplaceState(t,t.state,null)}function go(e,t){var n=t;if("ref"in t)for(var r in n={},t)"ref"!==r&&(n[r]=t[r]);if(e=e.defaultProps)for(var a in n===t&&(n=h({},n)),e)void 0===n[a]&&(n[a]=e[a]);return n}var bo="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function yo(e){bo(e)}function xo(e){console.error(e)}function vo(e){bo(e)}function wo(e,t){try{(0,e.onUncaughtError)(t.value,{componentStack:t.stack})}catch(n){setTimeout((function(){throw n}))}}function ko(e,t,n){try{(0,e.onCaughtError)(n.value,{componentStack:n.stack,errorBoundary:1===t.tag?t.stateNode:null})}catch(r){setTimeout((function(){throw r}))}}function So(e,t,n){return(n=as(n)).tag=3,n.payload={element:null},n.callback=function(){wo(e,t)},n}function Io(e){return(e=as(e)).tag=3,e}function No(e,t,n,r){var a=n.type.getDerivedStateFromError;if("function"===typeof a){var s=r.value;e.payload=function(){return a(s)},e.callback=function(){ko(t,n,r)}}var i=n.stateNode;null!==i&&"function"===typeof i.componentDidCatch&&(e.callback=function(){ko(t,n,r),"function"!==typeof a&&(null===Iu?Iu=new Set([this]):Iu.add(this));var e=r.stack;this.componentDidCatch(r.value,{componentStack:null!==e?e:""})})}var Co=Error(i(461)),To=!1;function Eo(e,t,n,r){t.child=null===e?no(t,null,n,r):to(t,e.child,n,r)}function $o(e,t,n,r,a){n=n.render;var s=t.ref;if("ref"in r){var i={};for(var o in r)"ref"!==o&&(i[o]=r[o])}else i=r;return Na(t),r=_s(e,t,n,i,s,a),o=Os(),null===e||To?(sa&&o&&ta(t),t.flags|=1,Eo(e,t,r,a),t.child):(Ls(e,t,a),Xo(e,t,a))}function Ro(e,t,n,r,a){if(null===e){var s=n.type;return"function"!==typeof s||Mr(s)||void 0!==s.defaultProps||null!==n.compare?((e=Br(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=s,_o(e,t,s,r,a))}if(s=e.child,!Yo(e,a)){var i=s.memoizedProps;if((n=null!==(n=n.compare)?n:Yn)(i,r)&&e.ref===t.ref)return Xo(e,t,a)}return t.flags|=1,(e=zr(s,r)).ref=t.ref,e.return=t,t.child=e}function _o(e,t,n,r,a){if(null!==e){var s=e.memoizedProps;if(Yn(s,r)&&e.ref===t.ref){if(To=!1,t.pendingProps=r=s,!Yo(e,a))return t.lanes=e.lanes,Xo(e,t,a);0!==(131072&e.flags)&&(To=!0)}}return Oo(e,t,n,r,a)}function Ao(e,t,n){var r=t.pendingProps,a=r.children,s=null!==e?e.memoizedState:null;if("hidden"===r.mode){if(0!==(128&t.flags)){if(r=null!==s?s.baseLanes|n:n,null!==e){for(a=t.child=e.child,s=0;null!==a;)s=s|a.lanes|a.childLanes,a=a.sibling;t.childLanes=s&~r}else t.childLanes=0,t.child=null;return Fo(e,t,r,n)}if(0===(536870912&n))return t.lanes=t.childLanes=536870912,Fo(e,t,null!==s?s.baseLanes|n:n,n);t.memoizedState={baseLanes:0,cachePool:null},null!==e&&ja(0,null!==s?s.cachePool:null),null!==s?ms(t,s):gs(),io(t)}else null!==s?(ja(0,s.cachePool),ms(t,s),oo(),t.memoizedState=null):(null!==e&&ja(0,null),gs(),oo());return Eo(e,t,a,n),t.child}function Fo(e,t,n,r){var a=Ua();return a=null===a?null:{parent:Aa._currentValue,pool:a},t.memoizedState={baseLanes:n,cachePool:a},null!==e&&ja(0,null),gs(),io(t),null!==e&&Sa(e,t,r,!0),null}function Do(e,t){var n=t.ref;if(null===n)null!==e&&null!==e.ref&&(t.flags|=4194816);else{if("function"!==typeof n&&"object"!==typeof n)throw Error(i(284));null!==e&&e.ref===n||(t.flags|=4194816)}}function Oo(e,t,n,r,a){return Na(t),n=_s(e,t,n,r,void 0,a),r=Os(),null===e||To?(sa&&r&&ta(t),t.flags|=1,Eo(e,t,n,a),t.child):(Ls(e,t,a),Xo(e,t,a))}function Lo(e,t,n,r,a,s){return Na(t),t.updateQueue=null,n=Fs(t,r,n,a),As(e),r=Os(),null===e||To?(sa&&r&&ta(t),t.flags|=1,Eo(e,t,n,s),t.child):(Ls(e,t,s),Xo(e,t,s))}function Mo(e,t,n,r,a){if(Na(t),null===t.stateNode){var s=Dr,i=n.contextType;"object"===typeof i&&null!==i&&(s=Ca(i)),s=new n(r,s),t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,s.updater=po,t.stateNode=s,s._reactInternals=t,(s=t.stateNode).props=r,s.state=t.memoizedState,s.refs={},ns(t),i=n.contextType,s.context="object"===typeof i&&null!==i?Ca(i):Dr,s.state=t.memoizedState,"function"===typeof(i=n.getDerivedStateFromProps)&&(ho(t,n,i,r),s.state=t.memoizedState),"function"===typeof n.getDerivedStateFromProps||"function"===typeof s.getSnapshotBeforeUpdate||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||(i=s.state,"function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),i!==s.state&&po.enqueueReplaceState(s,s.state,null),cs(t,r,s,a),us(),s.state=t.memoizedState),"function"===typeof s.componentDidMount&&(t.flags|=4194308),r=!0}else if(null===e){s=t.stateNode;var o=t.memoizedProps,l=go(n,o);s.props=l;var u=s.context,c=n.contextType;i=Dr,"object"===typeof c&&null!==c&&(i=Ca(c));var d=n.getDerivedStateFromProps;c="function"===typeof d||"function"===typeof s.getSnapshotBeforeUpdate,o=t.pendingProps!==o,c||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(o||u!==i)&&mo(t,s,r,i),ts=!1;var h=t.memoizedState;s.state=h,cs(t,r,s,a),us(),u=t.memoizedState,o||h!==u||ts?("function"===typeof d&&(ho(t,n,d,r),u=t.memoizedState),(l=ts||fo(t,n,l,r,h,u,i))?(c||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||("function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount()),"function"===typeof s.componentDidMount&&(t.flags|=4194308)):("function"===typeof s.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=u),s.props=r,s.state=u,s.context=i,r=l):("function"===typeof s.componentDidMount&&(t.flags|=4194308),r=!1)}else{s=t.stateNode,rs(e,t),c=go(n,i=t.memoizedProps),s.props=c,d=t.pendingProps,h=s.context,u=n.contextType,l=Dr,"object"===typeof u&&null!==u&&(l=Ca(u)),(u="function"===typeof(o=n.getDerivedStateFromProps)||"function"===typeof s.getSnapshotBeforeUpdate)||"function"!==typeof s.UNSAFE_componentWillReceiveProps&&"function"!==typeof s.componentWillReceiveProps||(i!==d||h!==l)&&mo(t,s,r,l),ts=!1,h=t.memoizedState,s.state=h,cs(t,r,s,a),us();var p=t.memoizedState;i!==d||h!==p||ts||null!==e&&null!==e.dependencies&&Ia(e.dependencies)?("function"===typeof o&&(ho(t,n,o,r),p=t.memoizedState),(c=ts||fo(t,n,c,r,h,p,l)||null!==e&&null!==e.dependencies&&Ia(e.dependencies))?(u||"function"!==typeof s.UNSAFE_componentWillUpdate&&"function"!==typeof s.componentWillUpdate||("function"===typeof s.componentWillUpdate&&s.componentWillUpdate(r,p,l),"function"===typeof s.UNSAFE_componentWillUpdate&&s.UNSAFE_componentWillUpdate(r,p,l)),"function"===typeof s.componentDidUpdate&&(t.flags|=4),"function"===typeof s.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof s.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=p),s.props=r,s.state=p,s.context=l,r=c):("function"!==typeof s.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof s.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return s=r,Do(e,t),r=0!==(128&t.flags),s||r?(s=t.stateNode,n=r&&"function"!==typeof n.getDerivedStateFromError?null:s.render(),t.flags|=1,null!==e&&r?(t.child=to(t,e.child,null,a),t.child=to(t,null,n,a)):Eo(e,t,n,a),t.memoizedState=s.state,e=t.child):e=Xo(e,t,a),e}function zo(e,t,n,r){return pa(),t.flags|=256,Eo(e,t,n,r),t.child}var Po={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Bo(e){return{baseLanes:e,cachePool:Va()}}function Wo(e,t,n){return e=null!==e?e.childLanes&~n:0,t&&(e|=gu),e}function Uo(e,t,n){var r,a=t.pendingProps,s=!1,o=0!==(128&t.flags);if((r=o)||(r=(null===e||null!==e.memoizedState)&&0!==(2&uo.current)),r&&(s=!0,t.flags&=-129),r=0!==(32&t.flags),t.flags&=-33,null===e){if(sa){if(s?so(t):oo(),sa){var l,u=aa;if(l=u){e:{for(l=u,u=oa;8!==l.nodeType;){if(!u){u=null;break e}if(null===(l=bd(l.nextSibling))){u=null;break e}}u=l}null!==u?(t.memoizedState={dehydrated:u,treeContext:null!==Yr?{id:Qr,overflow:Jr}:null,retryLane:536870912,hydrationErrors:null},(l=Lr(18,null,null,0)).stateNode=u,l.return=t,t.child=l,ra=t,aa=null,l=!0):l=!1}l||ua(t)}if(null!==(u=t.memoizedState)&&null!==(u=u.dehydrated))return gd(u)?t.lanes=32:t.lanes=536870912,null;lo(t)}return u=a.children,a=a.fallback,s?(oo(),u=Vo({mode:"hidden",children:u},s=t.mode),a=Wr(a,s,n,null),u.return=t,a.return=t,u.sibling=a,t.child=u,(s=t.child).memoizedState=Bo(n),s.childLanes=Wo(e,r,n),t.memoizedState=Po,a):(so(t),jo(t,u))}if(null!==(l=e.memoizedState)&&null!==(u=l.dehydrated)){if(o)256&t.flags?(so(t),t.flags&=-257,t=Go(e,t,n)):null!==t.memoizedState?(oo(),t.child=e.child,t.flags|=128,t=null):(oo(),s=a.fallback,u=t.mode,a=Vo({mode:"visible",children:a.children},u),(s=Wr(s,u,n,null)).flags|=2,a.return=t,s.return=t,a.sibling=s,t.child=a,to(t,e.child,null,n),(a=t.child).memoizedState=Bo(n),a.childLanes=Wo(e,r,n),t.memoizedState=Po,t=s);else if(so(t),gd(u)){if(r=u.nextSibling&&u.nextSibling.dataset)var c=r.dgst;r=c,(a=Error(i(419))).stack="",a.digest=r,ma({value:a,source:null,stack:null}),t=Go(e,t,n)}else if(To||Sa(e,t,n,!1),r=0!==(n&e.childLanes),To||r){if(null!==(r=ru)&&(0!==(a=0!==((a=0!==(42&(a=n&-n))?1:Ee(a))&(r.suspendedLanes|n))?0:a)&&a!==l.retryLane))throw l.retryLane=a,_r(e,a),Lu(r,e,a),Co;"$?"===u.data||qu(),t=Go(e,t,n)}else"$?"===u.data?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,aa=bd(u.nextSibling),ra=t,sa=!0,ia=null,oa=!1,null!==e&&(Kr[Xr++]=Qr,Kr[Xr++]=Jr,Kr[Xr++]=Yr,Qr=e.id,Jr=e.overflow,Yr=t),(t=jo(t,a.children)).flags|=4096);return t}return s?(oo(),s=a.fallback,u=t.mode,c=(l=e.child).sibling,(a=zr(l,{mode:"hidden",children:a.children})).subtreeFlags=65011712&l.subtreeFlags,null!==c?s=zr(c,s):(s=Wr(s,u,n,null)).flags|=2,s.return=t,a.return=t,a.sibling=s,t.child=a,a=s,s=t.child,null===(u=e.child.memoizedState)?u=Bo(n):(null!==(l=u.cachePool)?(c=Aa._currentValue,l=l.parent!==c?{parent:c,pool:c}:l):l=Va(),u={baseLanes:u.baseLanes|n,cachePool:l}),s.memoizedState=u,s.childLanes=Wo(e,r,n),t.memoizedState=Po,a):(so(t),e=(n=e.child).sibling,(n=zr(n,{mode:"visible",children:a.children})).return=t,n.sibling=null,null!==e&&(null===(r=t.deletions)?(t.deletions=[e],t.flags|=16):r.push(e)),t.child=n,t.memoizedState=null,n)}function jo(e,t){return(t=Vo({mode:"visible",children:t},e.mode)).return=e,e.child=t}function Vo(e,t){return(e=Lr(22,e,null,t)).lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function Go(e,t,n){return to(t,e.child,null,n),(e=jo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Ho(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),wa(e.return,t,n)}function qo(e,t,n,r,a){var s=e.memoizedState;null===s?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function Ko(e,t,n){var r=t.pendingProps,a=r.revealOrder,s=r.tail;if(Eo(e,t,r.children,n),0!==(2&(r=uo.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Ho(e,n,t);else if(19===e.tag)Ho(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}switch(W(uo,r),a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===co(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),qo(t,!1,a,n,s);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===co(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}qo(t,!0,n,null,s);break;case"together":qo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Xo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),pu|=t.lanes,0===(n&t.childLanes)){if(null===e)return null;if(Sa(e,t,n,!1),0===(n&t.childLanes))return null}if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=zr(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=zr(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Yo(e,t){return 0!==(e.lanes&t)||!(null===(e=e.dependencies)||!Ia(e))}function Qo(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps)To=!0;else{if(!Yo(e,n)&&0===(128&t.flags))return To=!1,function(e,t,n){switch(t.tag){case 3:H(t,t.stateNode.containerInfo),xa(0,Aa,e.memoizedState.cache),pa();break;case 27:case 5:K(t);break;case 4:H(t,t.stateNode.containerInfo);break;case 10:xa(0,t.type,t.memoizedProps.value);break;case 13:var r=t.memoizedState;if(null!==r)return null!==r.dehydrated?(so(t),t.flags|=128,null):0!==(n&t.child.childLanes)?Uo(e,t,n):(so(t),null!==(e=Xo(e,t,n))?e.sibling:null);so(t);break;case 19:var a=0!==(128&e.flags);if((r=0!==(n&t.childLanes))||(Sa(e,t,n,!1),r=0!==(n&t.childLanes)),a){if(r)return Ko(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),W(uo,uo.current),r)break;return null;case 22:case 23:return t.lanes=0,Ao(e,t,n);case 24:xa(0,Aa,e.memoizedState.cache)}return Xo(e,t,n)}(e,t,n);To=0!==(131072&e.flags)}else To=!1,sa&&0!==(1048576&t.flags)&&ea(t,qr,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var r=t.elementType,a=r._init;if(r=a(r._payload),t.type=r,"function"!==typeof r){if(void 0!==r&&null!==r){if((a=r.$$typeof)===k){t.tag=11,t=$o(null,t,r,e,n);break e}if(a===N){t.tag=14,t=Ro(null,t,r,e,n);break e}}throw t=A(r)||r,Error(i(306,t,""))}Mr(r)?(e=go(r,e),t.tag=1,t=Mo(null,t,r,e,n)):(t.tag=0,t=Oo(null,t,r,e,n))}return t;case 0:return Oo(e,t,t.type,t.pendingProps,n);case 1:return Mo(e,t,r=t.type,a=go(r,t.pendingProps),n);case 3:e:{if(H(t,t.stateNode.containerInfo),null===e)throw Error(i(387));r=t.pendingProps;var s=t.memoizedState;a=s.element,rs(e,t),cs(t,r,null,n);var o=t.memoizedState;if(r=o.cache,xa(0,Aa,r),r!==s.cache&&ka(t,[Aa],n,!0),us(),r=o.element,s.isDehydrated){if(s={element:r,isDehydrated:!1,cache:o.cache},t.updateQueue.baseState=s,t.memoizedState=s,256&t.flags){t=zo(e,t,r,n);break e}if(r!==a){ma(a=Ir(Error(i(424)),t)),t=zo(e,t,r,n);break e}if(9===(e=t.stateNode.containerInfo).nodeType)e=e.body;else e="HTML"===e.nodeName?e.ownerDocument.body:e;for(aa=bd(e.firstChild),ra=t,sa=!0,ia=null,oa=!0,n=no(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pa(),r===a){t=Xo(e,t,n);break e}Eo(e,t,r,n)}t=t.child}return t;case 26:return Do(e,t),null===e?(n=Ed(t.type,null,t.pendingProps,null))?t.memoizedState=n:sa||(n=t.type,e=t.pendingProps,(r=rd(V.current).createElement(n))[Ae]=t,r[Fe]=e,ed(r,n,e),Ge(r),t.stateNode=r):t.memoizedState=Ed(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return K(t),null===e&&sa&&(r=t.stateNode=vd(t.type,t.pendingProps,V.current),ra=t,oa=!0,a=aa,pd(t.type)?(yd=a,aa=bd(r.firstChild)):aa=a),Eo(e,t,t.pendingProps.children,n),Do(e,t),null===e&&(t.flags|=4194304),t.child;case 5:return null===e&&sa&&((a=r=aa)&&(null!==(r=function(e,t,n,r){for(;1===e.nodeType;){var a=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&("INPUT"!==e.nodeName||"hidden"!==e.type))break}else if(r){if(!e[Pe])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if("stylesheet"===(s=e.getAttribute("rel"))&&e.hasAttribute("data-precedence"))break;if(s!==a.rel||e.getAttribute("href")!==(null==a.href||""===a.href?null:a.href)||e.getAttribute("crossorigin")!==(null==a.crossOrigin?null:a.crossOrigin)||e.getAttribute("title")!==(null==a.title?null:a.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(((s=e.getAttribute("src"))!==(null==a.src?null:a.src)||e.getAttribute("type")!==(null==a.type?null:a.type)||e.getAttribute("crossorigin")!==(null==a.crossOrigin?null:a.crossOrigin))&&s&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else{if("input"!==t||"hidden"!==e.type)return e;var s=null==a.name?null:""+a.name;if("hidden"===a.type&&e.getAttribute("name")===s)return e}if(null===(e=bd(e.nextSibling)))break}return null}(r,t.type,t.pendingProps,oa))?(t.stateNode=r,ra=t,aa=bd(r.firstChild),oa=!1,a=!0):a=!1),a||ua(t)),K(t),a=t.type,s=t.pendingProps,o=null!==e?e.memoizedProps:null,r=s.children,id(a,s)?r=null:null!==o&&id(a,o)&&(t.flags|=32),null!==t.memoizedState&&(a=_s(e,t,Ds,null,null,n),Kd._currentValue=a),Do(e,t),Eo(e,t,r,n),t.child;case 6:return null===e&&sa&&((e=n=aa)&&(null!==(n=function(e,t,n){if(""===t)return null;for(;3!==e.nodeType;){if((1!==e.nodeType||"INPUT"!==e.nodeName||"hidden"!==e.type)&&!n)return null;if(null===(e=bd(e.nextSibling)))return null}return e}(n,t.pendingProps,oa))?(t.stateNode=n,ra=t,aa=null,e=!0):e=!1),e||ua(t)),null;case 13:return Uo(e,t,n);case 4:return H(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=to(t,null,r,n):Eo(e,t,r,n),t.child;case 11:return $o(e,t,t.type,t.pendingProps,n);case 7:return Eo(e,t,t.pendingProps,n),t.child;case 8:case 12:return Eo(e,t,t.pendingProps.children,n),t.child;case 10:return r=t.pendingProps,xa(0,t.type,r.value),Eo(e,t,r.children,n),t.child;case 9:return a=t.type._context,r=t.pendingProps.children,Na(t),r=r(a=Ca(a)),t.flags|=1,Eo(e,t,r,n),t.child;case 14:return Ro(e,t,t.type,t.pendingProps,n);case 15:return _o(e,t,t.type,t.pendingProps,n);case 19:return Ko(e,t,n);case 31:return r=t.pendingProps,n=t.mode,r={mode:r.mode,children:r.children},null===e?((n=Vo(r,n)).ref=t.ref,t.child=n,n.return=t,t=n):((n=zr(e.child,r)).ref=t.ref,t.child=n,n.return=t,t=n),t;case 22:return Ao(e,t,n);case 24:return Na(t),r=Ca(Aa),null===e?(null===(a=Ua())&&(a=ru,s=Fa(),a.pooledCache=s,s.refCount++,null!==s&&(a.pooledCacheLanes|=n),a=s),t.memoizedState={parent:r,cache:a},ns(t),xa(0,Aa,a)):(0!==(e.lanes&n)&&(rs(e,t),cs(t,null,null,n),us()),a=e.memoizedState,s=t.memoizedState,a.parent!==r?(a={parent:r,cache:r},t.memoizedState=a,0===t.lanes&&(t.memoizedState=t.updateQueue.baseState=a),xa(0,Aa,r)):(r=s.cache,xa(0,Aa,r),r!==a.cache&&ka(t,[Aa],n,!0))),Eo(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(i(156,t.tag))}function Jo(e){e.flags|=4}function Zo(e,t){if("stylesheet"!==t.type||0!==(4&t.state.loading))e.flags&=-16777217;else if(e.flags|=16777216,!Wd(t)){if(null!==(t=ro.current)&&((4194048&su)===su?null!==ao:(62914560&su)!==su&&0===(536870912&su)||t!==ao))throw Ja=Ka,Ha;e.flags|=8192}}function el(e,t){null!==t&&(e.flags|=4),16384&e.flags&&(t=22!==e.tag?Se():536870912,e.lanes|=t,bu|=t)}function tl(e,t){if(!sa)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function nl(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=65011712&a.subtreeFlags,r|=65011712&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function rl(e,t,n){var r=t.pendingProps;switch(na(t),t.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:case 1:return nl(t),null;case 3:return n=t.stateNode,r=null,null!==e&&(r=e.memoizedState.cache),t.memoizedState.cache!==r&&(t.flags|=2048),va(Aa),q(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(ha(t)?Jo(t):null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,fa())),nl(t),null;case 26:return n=t.memoizedState,null===e?(Jo(t),null!==n?(nl(t),Zo(t,n)):(nl(t),t.flags&=-16777217)):n?n!==e.memoizedState?(Jo(t),nl(t),Zo(t,n)):(nl(t),t.flags&=-16777217):(e.memoizedProps!==r&&Jo(t),nl(t),t.flags&=-16777217),null;case 27:X(t),n=V.current;var a=t.type;if(null!==e&&null!=t.stateNode)e.memoizedProps!==r&&Jo(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return nl(t),null}e=U.current,ha(t)?ca(t):(e=vd(a,r,n),t.stateNode=e,Jo(t))}return nl(t),null;case 5:if(X(t),n=t.type,null!==e&&null!=t.stateNode)e.memoizedProps!==r&&Jo(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return nl(t),null}if(e=U.current,ha(t))ca(t);else{switch(a=rd(V.current),e){case 1:e=a.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:e=a.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":e=a.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":e=a.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":(e=a.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e="string"===typeof r.is?a.createElement("select",{is:r.is}):a.createElement("select"),r.multiple?e.multiple=!0:r.size&&(e.size=r.size);break;default:e="string"===typeof r.is?a.createElement(n,{is:r.is}):a.createElement(n)}}e[Ae]=t,e[Fe]=r;e:for(a=t.child;null!==a;){if(5===a.tag||6===a.tag)e.appendChild(a.stateNode);else if(4!==a.tag&&27!==a.tag&&null!==a.child){a.child.return=a,a=a.child;continue}if(a===t)break e;for(;null===a.sibling;){if(null===a.return||a.return===t)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}t.stateNode=e;e:switch(ed(e,n,r),n){case"button":case"input":case"select":case"textarea":e=!!r.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&Jo(t)}}return nl(t),t.flags&=-16777217,null;case 6:if(e&&null!=t.stateNode)e.memoizedProps!==r&&Jo(t);else{if("string"!==typeof r&&null===t.stateNode)throw Error(i(166));if(e=V.current,ha(t)){if(e=t.stateNode,n=t.memoizedProps,r=null,null!==(a=ra))switch(a.tag){case 27:case 5:r=a.memoizedProps}e[Ae]=t,(e=!!(e.nodeValue===n||null!==r&&!0===r.suppressHydrationWarning||Yc(e.nodeValue,n)))||ua(t)}else(e=rd(e).createTextNode(r))[Ae]=t,t.stateNode=e}return nl(t),null;case 13:if(r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(a=ha(t),null!==r&&null!==r.dehydrated){if(null===e){if(!a)throw Error(i(318));if(!(a=null!==(a=t.memoizedState)?a.dehydrated:null))throw Error(i(317));a[Ae]=t}else pa(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;nl(t),a=!1}else a=fa(),null!==e&&null!==e.memoizedState&&(e.memoizedState.hydrationErrors=a),a=!0;if(!a)return 256&t.flags?(lo(t),t):(lo(t),null)}if(lo(t),0!==(128&t.flags))return t.lanes=n,t;if(n=null!==r,e=null!==e&&null!==e.memoizedState,n){a=null,null!==(r=t.child).alternate&&null!==r.alternate.memoizedState&&null!==r.alternate.memoizedState.cachePool&&(a=r.alternate.memoizedState.cachePool.pool);var s=null;null!==r.memoizedState&&null!==r.memoizedState.cachePool&&(s=r.memoizedState.cachePool.pool),s!==a&&(r.flags|=2048)}return n!==e&&n&&(t.child.flags|=8192),el(t,t.updateQueue),nl(t),null;case 4:return q(),null===e&&Bc(t.stateNode.containerInfo),nl(t),null;case 10:return va(t.type),nl(t),null;case 19:if(B(uo),null===(a=t.memoizedState))return nl(t),null;if(r=0!==(128&t.flags),null===(s=a.rendering))if(r)tl(a,!1);else{if(0!==hu||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(s=co(e))){for(t.flags|=128,tl(a,!1),e=s.updateQueue,t.updateQueue=e,el(t,e),t.subtreeFlags=0,e=n,n=t.child;null!==n;)Pr(n,e),n=n.sibling;return W(uo,1&uo.current|2),t.child}e=e.sibling}null!==a.tail&&te()>ku&&(t.flags|=128,r=!0,tl(a,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=co(s))){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,el(t,e),tl(a,!0),null===a.tail&&"hidden"===a.tailMode&&!s.alternate&&!sa)return nl(t),null}else 2*te()-a.renderingStartTime>ku&&536870912!==n&&(t.flags|=128,r=!0,tl(a,!1),t.lanes=4194304);a.isBackwards?(s.sibling=t.child,t.child=s):(null!==(e=a.last)?e.sibling=s:t.child=s,a.last=s)}return null!==a.tail?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=te(),t.sibling=null,e=uo.current,W(uo,r?1&e|2:1&e),t):(nl(t),null);case 22:case 23:return lo(t),bs(),r=null!==t.memoizedState,null!==e?null!==e.memoizedState!==r&&(t.flags|=8192):r&&(t.flags|=8192),r?0!==(536870912&n)&&0===(128&t.flags)&&(nl(t),6&t.subtreeFlags&&(t.flags|=8192)):nl(t),null!==(n=t.updateQueue)&&el(t,n.retryQueue),n=null,null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),r=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(r=t.memoizedState.cachePool.pool),r!==n&&(t.flags|=2048),null!==e&&B(Wa),null;case 24:return n=null,null!==e&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),va(Aa),nl(t),null;case 25:case 30:return null}throw Error(i(156,t.tag))}function al(e,t){switch(na(t),t.tag){case 1:return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return va(Aa),q(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 26:case 27:case 5:return X(t),null;case 13:if(lo(t),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(i(340));pa()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return B(uo),null;case 4:return q(),null;case 10:return va(t.type),null;case 22:case 23:return lo(t),bs(),null!==e&&B(Wa),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 24:return va(Aa),null;default:return null}}function sl(e,t){switch(na(t),t.tag){case 3:va(Aa),q();break;case 26:case 27:case 5:X(t);break;case 4:q();break;case 13:lo(t);break;case 19:B(uo);break;case 10:va(t.type);break;case 22:case 23:lo(t),bs(),null!==e&&B(Wa);break;case 24:va(Aa)}}function il(e,t){try{var n=t.updateQueue,r=null!==n?n.lastEffect:null;if(null!==r){var a=r.next;n=a;do{if((n.tag&e)===e){r=void 0;var s=n.create,i=n.inst;r=s(),i.destroy=r}n=n.next}while(n!==a)}}catch(o){cc(t,t.return,o)}}function ol(e,t,n){try{var r=t.updateQueue,a=null!==r?r.lastEffect:null;if(null!==a){var s=a.next;r=s;do{if((r.tag&e)===e){var i=r.inst,o=i.destroy;if(void 0!==o){i.destroy=void 0,a=t;var l=n,u=o;try{u()}catch(c){cc(a,l,c)}}}r=r.next}while(r!==s)}}catch(c){cc(t,t.return,c)}}function ll(e){var t=e.updateQueue;if(null!==t){var n=e.stateNode;try{hs(t,n)}catch(r){cc(e,e.return,r)}}}function ul(e,t,n){n.props=go(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(r){cc(e,t,r)}}function cl(e,t){try{var n=e.ref;if(null!==n){switch(e.tag){case 26:case 27:case 5:var r=e.stateNode;break;default:r=e.stateNode}"function"===typeof n?e.refCleanup=n(r):n.current=r}}catch(a){cc(e,t,a)}}function dl(e,t){var n=e.ref,r=e.refCleanup;if(null!==n)if("function"===typeof r)try{r()}catch(a){cc(e,t,a)}finally{e.refCleanup=null,null!=(e=e.alternate)&&(e.refCleanup=null)}else if("function"===typeof n)try{n(null)}catch(s){cc(e,t,s)}else n.current=null}function hl(e){var t=e.type,n=e.memoizedProps,r=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&r.focus();break e;case"img":n.src?r.src=n.src:n.srcSet&&(r.srcset=n.srcSet)}}catch(a){cc(e,e.return,a)}}function pl(e,t,n){try{var r=e.stateNode;!function(e,t,n,r){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var a=null,s=null,o=null,l=null,u=null,c=null,d=null;for(f in n){var h=n[f];if(n.hasOwnProperty(f)&&null!=h)switch(f){case"checked":case"value":break;case"defaultValue":u=h;default:r.hasOwnProperty(f)||Jc(e,t,f,null,r,h)}}for(var p in r){var f=r[p];if(h=n[p],r.hasOwnProperty(p)&&(null!=f||null!=h))switch(p){case"type":s=f;break;case"name":a=f;break;case"checked":c=f;break;case"defaultChecked":d=f;break;case"value":o=f;break;case"defaultValue":l=f;break;case"children":case"dangerouslySetInnerHTML":if(null!=f)throw Error(i(137,t));break;default:f!==h&&Jc(e,t,p,f,r,h)}}return void gt(e,o,l,u,c,d,s,a);case"select":for(s in f=o=l=p=null,n)if(u=n[s],n.hasOwnProperty(s)&&null!=u)switch(s){case"value":break;case"multiple":f=u;default:r.hasOwnProperty(s)||Jc(e,t,s,null,r,u)}for(a in r)if(s=r[a],u=n[a],r.hasOwnProperty(a)&&(null!=s||null!=u))switch(a){case"value":p=s;break;case"defaultValue":l=s;break;case"multiple":o=s;default:s!==u&&Jc(e,t,a,s,r,u)}return t=l,n=o,r=f,void(null!=p?xt(e,!!n,p,!1):!!r!==!!n&&(null!=t?xt(e,!!n,t,!0):xt(e,!!n,n?[]:"",!1)));case"textarea":for(l in f=p=null,n)if(a=n[l],n.hasOwnProperty(l)&&null!=a&&!r.hasOwnProperty(l))switch(l){case"value":case"children":break;default:Jc(e,t,l,null,r,a)}for(o in r)if(a=r[o],s=n[o],r.hasOwnProperty(o)&&(null!=a||null!=s))switch(o){case"value":p=a;break;case"defaultValue":f=a;break;case"children":break;case"dangerouslySetInnerHTML":if(null!=a)throw Error(i(91));break;default:a!==s&&Jc(e,t,o,a,r,s)}return void vt(e,p,f);case"option":for(var m in n)if(p=n[m],n.hasOwnProperty(m)&&null!=p&&!r.hasOwnProperty(m))if("selected"===m)e.selected=!1;else Jc(e,t,m,null,r,p);for(u in r)if(p=r[u],f=n[u],r.hasOwnProperty(u)&&p!==f&&(null!=p||null!=f))if("selected"===u)e.selected=p&&"function"!==typeof p&&"symbol"!==typeof p;else Jc(e,t,u,p,r,f);return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var g in n)p=n[g],n.hasOwnProperty(g)&&null!=p&&!r.hasOwnProperty(g)&&Jc(e,t,g,null,r,p);for(c in r)if(p=r[c],f=n[c],r.hasOwnProperty(c)&&p!==f&&(null!=p||null!=f))switch(c){case"children":case"dangerouslySetInnerHTML":if(null!=p)throw Error(i(137,t));break;default:Jc(e,t,c,p,r,f)}return;default:if(Ct(t)){for(var b in n)p=n[b],n.hasOwnProperty(b)&&void 0!==p&&!r.hasOwnProperty(b)&&Zc(e,t,b,void 0,r,p);for(d in r)p=r[d],f=n[d],!r.hasOwnProperty(d)||p===f||void 0===p&&void 0===f||Zc(e,t,d,p,r,f);return}}for(var y in n)p=n[y],n.hasOwnProperty(y)&&null!=p&&!r.hasOwnProperty(y)&&Jc(e,t,y,null,r,p);for(h in r)p=r[h],f=n[h],!r.hasOwnProperty(h)||p===f||null==p&&null==f||Jc(e,t,h,p,r,f)}(r,e.type,n,t),r[Fe]=t}catch(a){cc(e,e.return,a)}}function fl(e){return 5===e.tag||3===e.tag||26===e.tag||27===e.tag&&pd(e.type)||4===e.tag}function ml(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||fl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(27===e.tag&&pd(e.type))continue e;if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function gl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?(9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).insertBefore(e,t):((t=9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Qc));else if(4!==r&&(27===r&&pd(e.type)&&(n=e.stateNode,t=null),null!==(e=e.child)))for(gl(e,t,n),e=e.sibling;null!==e;)gl(e,t,n),e=e.sibling}function bl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&(27===r&&pd(e.type)&&(n=e.stateNode),null!==(e=e.child)))for(bl(e,t,n),e=e.sibling;null!==e;)bl(e,t,n),e=e.sibling}function yl(e){var t=e.stateNode,n=e.memoizedProps;try{for(var r=e.type,a=t.attributes;a.length;)t.removeAttributeNode(a[0]);ed(t,r,n),t[Ae]=e,t[Fe]=n}catch(s){cc(e,e.return,s)}}var xl=!1,vl=!1,wl=!1,kl="function"===typeof WeakSet?WeakSet:Set,Sl=null;function Il(e,t,n){var r=n.flags;switch(n.tag){case 0:case 11:case 15:Ml(e,n),4&r&&il(5,n);break;case 1:if(Ml(e,n),4&r)if(e=n.stateNode,null===t)try{e.componentDidMount()}catch(i){cc(n,n.return,i)}else{var a=go(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(a,t,e.__reactInternalSnapshotBeforeUpdate)}catch(o){cc(n,n.return,o)}}64&r&&ll(n),512&r&&cl(n,n.return);break;case 3:if(Ml(e,n),64&r&&null!==(e=n.updateQueue)){if(t=null,null!==n.child)switch(n.child.tag){case 27:case 5:case 1:t=n.child.stateNode}try{hs(e,t)}catch(i){cc(n,n.return,i)}}break;case 27:null===t&&4&r&&yl(n);case 26:case 5:Ml(e,n),null===t&&4&r&&hl(n),512&r&&cl(n,n.return);break;case 12:Ml(e,n);break;case 13:Ml(e,n),4&r&&Rl(e,n),64&r&&(null!==(e=n.memoizedState)&&(null!==(e=e.dehydrated)&&function(e,t){var n=e.ownerDocument;if("$?"!==e.data||"complete"===n.readyState)t();else{var r=function(){t(),n.removeEventListener("DOMContentLoaded",r)};n.addEventListener("DOMContentLoaded",r),e._reactRetry=r}}(e,n=fc.bind(null,n))));break;case 22:if(!(r=null!==n.memoizedState||xl)){t=null!==t&&null!==t.memoizedState||vl,a=xl;var s=vl;xl=r,(vl=t)&&!s?Pl(e,n,0!==(8772&n.subtreeFlags)):Ml(e,n),xl=a,vl=s}break;case 30:break;default:Ml(e,n)}}function Nl(e){var t=e.alternate;null!==t&&(e.alternate=null,Nl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&Be(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Cl=null,Tl=!1;function El(e,t,n){for(n=n.child;null!==n;)$l(e,t,n),n=n.sibling}function $l(e,t,n){if(de&&"function"===typeof de.onCommitFiberUnmount)try{de.onCommitFiberUnmount(ce,n)}catch(s){}switch(n.tag){case 26:vl||dl(n,t),El(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode).parentNode.removeChild(n);break;case 27:vl||dl(n,t);var r=Cl,a=Tl;pd(n.type)&&(Cl=n.stateNode,Tl=!1),El(e,t,n),wd(n.stateNode),Cl=r,Tl=a;break;case 5:vl||dl(n,t);case 6:if(r=Cl,a=Tl,Cl=null,El(e,t,n),Tl=a,null!==(Cl=r))if(Tl)try{(9===Cl.nodeType?Cl.body:"HTML"===Cl.nodeName?Cl.ownerDocument.body:Cl).removeChild(n.stateNode)}catch(i){cc(n,t,i)}else try{Cl.removeChild(n.stateNode)}catch(i){cc(n,t,i)}break;case 18:null!==Cl&&(Tl?(fd(9===(e=Cl).nodeType?e.body:"HTML"===e.nodeName?e.ownerDocument.body:e,n.stateNode),Th(e)):fd(Cl,n.stateNode));break;case 4:r=Cl,a=Tl,Cl=n.stateNode.containerInfo,Tl=!0,El(e,t,n),Cl=r,Tl=a;break;case 0:case 11:case 14:case 15:vl||ol(2,n,t),vl||ol(4,n,t),El(e,t,n);break;case 1:vl||(dl(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount&&ul(n,t,r)),El(e,t,n);break;case 21:El(e,t,n);break;case 22:vl=(r=vl)||null!==n.memoizedState,El(e,t,n),vl=r;break;default:El(e,t,n)}}function Rl(e,t){if(null===t.memoizedState&&(null!==(e=t.alternate)&&(null!==(e=e.memoizedState)&&null!==(e=e.dehydrated))))try{Th(e)}catch(n){cc(t,t.return,n)}}function _l(e,t){var n=function(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return null===t&&(t=e.stateNode=new kl),t;case 22:return null===(t=(e=e.stateNode)._retryCache)&&(t=e._retryCache=new kl),t;default:throw Error(i(435,e.tag))}}(e);t.forEach((function(t){var r=mc.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}function Al(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r],s=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 27:if(pd(l.type)){Cl=l.stateNode,Tl=!1;break e}break;case 5:Cl=l.stateNode,Tl=!1;break e;case 3:case 4:Cl=l.stateNode.containerInfo,Tl=!0;break e}l=l.return}if(null===Cl)throw Error(i(160));$l(s,o,a),Cl=null,Tl=!1,null!==(s=a.alternate)&&(s.return=null),a.return=null}if(13878&t.subtreeFlags)for(t=t.child;null!==t;)Dl(t,e),t=t.sibling}var Fl=null;function Dl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Al(t,e),Ol(e),4&r&&(ol(3,e,e.return),il(3,e),ol(5,e,e.return));break;case 1:Al(t,e),Ol(e),512&r&&(vl||null===n||dl(n,n.return)),64&r&&xl&&(null!==(e=e.updateQueue)&&(null!==(r=e.callbacks)&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=null===n?r:n.concat(r))));break;case 26:var a=Fl;if(Al(t,e),Ol(e),512&r&&(vl||null===n||dl(n,n.return)),4&r){var s=null!==n?n.memoizedState:null;if(r=e.memoizedState,null===n)if(null===r)if(null===e.stateNode){e:{r=e.type,n=e.memoizedProps,a=a.ownerDocument||a;t:switch(r){case"title":(!(s=a.getElementsByTagName("title")[0])||s[Pe]||s[Ae]||"http://www.w3.org/2000/svg"===s.namespaceURI||s.hasAttribute("itemprop"))&&(s=a.createElement(r),a.head.insertBefore(s,a.querySelector("head > title"))),ed(s,r,n),s[Ae]=e,Ge(s),r=s;break e;case"link":var o=Pd("link","href",a).get(r+(n.href||""));if(o)for(var l=0;l<o.length;l++)if((s=o[l]).getAttribute("href")===(null==n.href||""===n.href?null:n.href)&&s.getAttribute("rel")===(null==n.rel?null:n.rel)&&s.getAttribute("title")===(null==n.title?null:n.title)&&s.getAttribute("crossorigin")===(null==n.crossOrigin?null:n.crossOrigin)){o.splice(l,1);break t}ed(s=a.createElement(r),r,n),a.head.appendChild(s);break;case"meta":if(o=Pd("meta","content",a).get(r+(n.content||"")))for(l=0;l<o.length;l++)if((s=o[l]).getAttribute("content")===(null==n.content?null:""+n.content)&&s.getAttribute("name")===(null==n.name?null:n.name)&&s.getAttribute("property")===(null==n.property?null:n.property)&&s.getAttribute("http-equiv")===(null==n.httpEquiv?null:n.httpEquiv)&&s.getAttribute("charset")===(null==n.charSet?null:n.charSet)){o.splice(l,1);break t}ed(s=a.createElement(r),r,n),a.head.appendChild(s);break;default:throw Error(i(468,r))}s[Ae]=e,Ge(s),r=s}e.stateNode=r}else Bd(a,e.type,e.stateNode);else e.stateNode=Dd(a,r,e.memoizedProps);else s!==r?(null===s?null!==n.stateNode&&(n=n.stateNode).parentNode.removeChild(n):s.count--,null===r?Bd(a,e.type,e.stateNode):Dd(a,r,e.memoizedProps)):null===r&&null!==e.stateNode&&pl(e,e.memoizedProps,n.memoizedProps)}break;case 27:Al(t,e),Ol(e),512&r&&(vl||null===n||dl(n,n.return)),null!==n&&4&r&&pl(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Al(t,e),Ol(e),512&r&&(vl||null===n||dl(n,n.return)),32&e.flags){a=e.stateNode;try{kt(a,"")}catch(f){cc(e,e.return,f)}}4&r&&null!=e.stateNode&&pl(e,a=e.memoizedProps,null!==n?n.memoizedProps:a),1024&r&&(wl=!0);break;case 6:if(Al(t,e),Ol(e),4&r){if(null===e.stateNode)throw Error(i(162));r=e.memoizedProps,n=e.stateNode;try{n.nodeValue=r}catch(f){cc(e,e.return,f)}}break;case 3:if(zd=null,a=Fl,Fl=Id(t.containerInfo),Al(t,e),Fl=a,Ol(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Th(t.containerInfo)}catch(f){cc(e,e.return,f)}wl&&(wl=!1,Ll(e));break;case 4:r=Fl,Fl=Id(e.stateNode.containerInfo),Al(t,e),Ol(e),Fl=r;break;case 12:default:Al(t,e),Ol(e);break;case 13:Al(t,e),Ol(e),8192&e.child.flags&&null!==e.memoizedState!==(null!==n&&null!==n.memoizedState)&&(wu=te()),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,_l(e,r)));break;case 22:a=null!==e.memoizedState;var u=null!==n&&null!==n.memoizedState,c=xl,d=vl;if(xl=c||a,vl=d||u,Al(t,e),vl=d,xl=c,Ol(e),8192&r)e:for(t=e.stateNode,t._visibility=a?-2&t._visibility:1|t._visibility,a&&(null===n||u||xl||vl||zl(e)),n=null,t=e;;){if(5===t.tag||26===t.tag){if(null===n){u=n=t;try{if(s=u.stateNode,a)"function"===typeof(o=s.style).setProperty?o.setProperty("display","none","important"):o.display="none";else{l=u.stateNode;var h=u.memoizedProps.style,p=void 0!==h&&null!==h&&h.hasOwnProperty("display")?h.display:null;l.style.display=null==p||"boolean"===typeof p?"":(""+p).trim()}}catch(f){cc(u,u.return,f)}}}else if(6===t.tag){if(null===n){u=t;try{u.stateNode.nodeValue=a?"":u.memoizedProps}catch(f){cc(u,u.return,f)}}}else if((22!==t.tag&&23!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;null===t.sibling;){if(null===t.return||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}4&r&&(null!==(r=e.updateQueue)&&(null!==(n=r.retryQueue)&&(r.retryQueue=null,_l(e,n))));break;case 19:Al(t,e),Ol(e),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,_l(e,r)));case 30:case 21:}}function Ol(e){var t=e.flags;if(2&t){try{for(var n,r=e.return;null!==r;){if(fl(r)){n=r;break}r=r.return}if(null==n)throw Error(i(160));switch(n.tag){case 27:var a=n.stateNode;bl(e,ml(e),a);break;case 5:var s=n.stateNode;32&n.flags&&(kt(s,""),n.flags&=-33),bl(e,ml(e),s);break;case 3:case 4:var o=n.stateNode.containerInfo;gl(e,ml(e),o);break;default:throw Error(i(161))}}catch(l){cc(e,e.return,l)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function Ll(e){if(1024&e.subtreeFlags)for(e=e.child;null!==e;){var t=e;Ll(t),5===t.tag&&1024&t.flags&&t.stateNode.reset(),e=e.sibling}}function Ml(e,t){if(8772&t.subtreeFlags)for(t=t.child;null!==t;)Il(e,t.alternate,t),t=t.sibling}function zl(e){for(e=e.child;null!==e;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:ol(4,t,t.return),zl(t);break;case 1:dl(t,t.return);var n=t.stateNode;"function"===typeof n.componentWillUnmount&&ul(t,t.return,n),zl(t);break;case 27:wd(t.stateNode);case 26:case 5:dl(t,t.return),zl(t);break;case 22:null===t.memoizedState&&zl(t);break;default:zl(t)}e=e.sibling}}function Pl(e,t,n){for(n=n&&0!==(8772&t.subtreeFlags),t=t.child;null!==t;){var r=t.alternate,a=e,s=t,i=s.flags;switch(s.tag){case 0:case 11:case 15:Pl(a,s,n),il(4,s);break;case 1:if(Pl(a,s,n),"function"===typeof(a=(r=s).stateNode).componentDidMount)try{a.componentDidMount()}catch(u){cc(r,r.return,u)}if(null!==(a=(r=s).updateQueue)){var o=r.stateNode;try{var l=a.shared.hiddenCallbacks;if(null!==l)for(a.shared.hiddenCallbacks=null,a=0;a<l.length;a++)ds(l[a],o)}catch(u){cc(r,r.return,u)}}n&&64&i&&ll(s),cl(s,s.return);break;case 27:yl(s);case 26:case 5:Pl(a,s,n),n&&null===r&&4&i&&hl(s),cl(s,s.return);break;case 12:Pl(a,s,n);break;case 13:Pl(a,s,n),n&&4&i&&Rl(a,s);break;case 22:null===s.memoizedState&&Pl(a,s,n),cl(s,s.return);break;case 30:break;default:Pl(a,s,n)}t=t.sibling}}function Bl(e,t){var n=null;null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),e=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(e=t.memoizedState.cachePool.pool),e!==n&&(null!=e&&e.refCount++,null!=n&&Da(n))}function Wl(e,t){e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Da(e))}function Ul(e,t,n,r){if(10256&t.subtreeFlags)for(t=t.child;null!==t;)jl(e,t,n,r),t=t.sibling}function jl(e,t,n,r){var a=t.flags;switch(t.tag){case 0:case 11:case 15:Ul(e,t,n,r),2048&a&&il(9,t);break;case 1:case 13:default:Ul(e,t,n,r);break;case 3:Ul(e,t,n,r),2048&a&&(e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Da(e)));break;case 12:if(2048&a){Ul(e,t,n,r),e=t.stateNode;try{var s=t.memoizedProps,i=s.id,o=s.onPostCommit;"function"===typeof o&&o(i,null===t.alternate?"mount":"update",e.passiveEffectDuration,-0)}catch(l){cc(t,t.return,l)}}else Ul(e,t,n,r);break;case 23:break;case 22:s=t.stateNode,i=t.alternate,null!==t.memoizedState?2&s._visibility?Ul(e,t,n,r):Gl(e,t):2&s._visibility?Ul(e,t,n,r):(s._visibility|=2,Vl(e,t,n,r,0!==(10256&t.subtreeFlags))),2048&a&&Bl(i,t);break;case 24:Ul(e,t,n,r),2048&a&&Wl(t.alternate,t)}}function Vl(e,t,n,r,a){for(a=a&&0!==(10256&t.subtreeFlags),t=t.child;null!==t;){var s=e,i=t,o=n,l=r,u=i.flags;switch(i.tag){case 0:case 11:case 15:Vl(s,i,o,l,a),il(8,i);break;case 23:break;case 22:var c=i.stateNode;null!==i.memoizedState?2&c._visibility?Vl(s,i,o,l,a):Gl(s,i):(c._visibility|=2,Vl(s,i,o,l,a)),a&&2048&u&&Bl(i.alternate,i);break;case 24:Vl(s,i,o,l,a),a&&2048&u&&Wl(i.alternate,i);break;default:Vl(s,i,o,l,a)}t=t.sibling}}function Gl(e,t){if(10256&t.subtreeFlags)for(t=t.child;null!==t;){var n=e,r=t,a=r.flags;switch(r.tag){case 22:Gl(n,r),2048&a&&Bl(r.alternate,r);break;case 24:Gl(n,r),2048&a&&Wl(r.alternate,r);break;default:Gl(n,r)}t=t.sibling}}var Hl=8192;function ql(e){if(e.subtreeFlags&Hl)for(e=e.child;null!==e;)Kl(e),e=e.sibling}function Kl(e){switch(e.tag){case 26:ql(e),e.flags&Hl&&null!==e.memoizedState&&function(e,t,n){if(null===Ud)throw Error(i(475));var r=Ud;if("stylesheet"===t.type&&("string"!==typeof n.media||!1!==matchMedia(n.media).matches)&&0===(4&t.state.loading)){if(null===t.instance){var a=$d(n.href),s=e.querySelector(Rd(a));if(s)return null!==(e=s._p)&&"object"===typeof e&&"function"===typeof e.then&&(r.count++,r=Vd.bind(r),e.then(r,r)),t.state.loading|=4,t.instance=s,void Ge(s);s=e.ownerDocument||e,n=_d(n),(a=kd.get(a))&&Ld(n,a),Ge(s=s.createElement("link"));var o=s;o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),ed(s,"link",n),t.instance=s}null===r.stylesheets&&(r.stylesheets=new Map),r.stylesheets.set(t,e),(e=t.state.preload)&&0===(3&t.state.loading)&&(r.count++,t=Vd.bind(r),e.addEventListener("load",t),e.addEventListener("error",t))}}(Fl,e.memoizedState,e.memoizedProps);break;case 5:default:ql(e);break;case 3:case 4:var t=Fl;Fl=Id(e.stateNode.containerInfo),ql(e),Fl=t;break;case 22:null===e.memoizedState&&(null!==(t=e.alternate)&&null!==t.memoizedState?(t=Hl,Hl=16777216,ql(e),Hl=t):ql(e))}}function Xl(e){var t=e.alternate;if(null!==t&&null!==(e=t.child)){t.child=null;do{t=e.sibling,e.sibling=null,e=t}while(null!==e)}}function Yl(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Sl=r,Zl(r,e)}Xl(e)}if(10256&e.subtreeFlags)for(e=e.child;null!==e;)Ql(e),e=e.sibling}function Ql(e){switch(e.tag){case 0:case 11:case 15:Yl(e),2048&e.flags&&ol(9,e,e.return);break;case 3:case 12:default:Yl(e);break;case 22:var t=e.stateNode;null!==e.memoizedState&&2&t._visibility&&(null===e.return||13!==e.return.tag)?(t._visibility&=-3,Jl(e)):Yl(e)}}function Jl(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Sl=r,Zl(r,e)}Xl(e)}for(e=e.child;null!==e;){switch((t=e).tag){case 0:case 11:case 15:ol(8,t,t.return),Jl(t);break;case 22:2&(n=t.stateNode)._visibility&&(n._visibility&=-3,Jl(t));break;default:Jl(t)}e=e.sibling}}function Zl(e,t){for(;null!==Sl;){var n=Sl;switch(n.tag){case 0:case 11:case 15:ol(8,n,t);break;case 23:case 22:if(null!==n.memoizedState&&null!==n.memoizedState.cachePool){var r=n.memoizedState.cachePool.pool;null!=r&&r.refCount++}break;case 24:Da(n.memoizedState.cache)}if(null!==(r=n.child))r.return=n,Sl=r;else e:for(n=e;null!==Sl;){var a=(r=Sl).sibling,s=r.return;if(Nl(r),r===n){Sl=null;break e}if(null!==a){a.return=s,Sl=a;break e}Sl=s}}}var eu={getCacheForType:function(e){var t=Ca(Aa),n=t.data.get(e);return void 0===n&&(n=e(),t.data.set(e,n)),n}},tu="function"===typeof WeakMap?WeakMap:Map,nu=0,ru=null,au=null,su=0,iu=0,ou=null,lu=!1,uu=!1,cu=!1,du=0,hu=0,pu=0,fu=0,mu=0,gu=0,bu=0,yu=null,xu=null,vu=!1,wu=0,ku=1/0,Su=null,Iu=null,Nu=0,Cu=null,Tu=null,Eu=0,$u=0,Ru=null,_u=null,Au=0,Fu=null;function Du(){if(0!==(2&nu)&&0!==su)return su&-su;if(null!==D.T){return 0!==Ma?Ma:$c()}return Re()}function Ou(){0===gu&&(gu=0===(536870912&su)||sa?ke():536870912);var e=ro.current;return null!==e&&(e.flags|=32),gu}function Lu(e,t,n){(e!==ru||2!==iu&&9!==iu)&&null===e.cancelPendingCommit||(ju(e,0),Bu(e,su,gu,!1)),Ne(e,n),0!==(2&nu)&&e===ru||(e===ru&&(0===(2&nu)&&(fu|=n),4===hu&&Bu(e,su,gu,!1)),kc(e))}function Mu(e,t,n){if(0!==(6&nu))throw Error(i(327));for(var r=!n&&0===(124&t)&&0===(t&e.expiredLanes)||ve(e,t),a=r?function(e,t){var n=nu;nu|=2;var r=Gu(),a=Hu();ru!==e||su!==t?(Su=null,ku=te()+500,ju(e,t)):uu=ve(e,t);e:for(;;)try{if(0!==iu&&null!==au){t=au;var s=ou;t:switch(iu){case 1:iu=0,ou=null,Zu(e,t,s,1);break;case 2:case 9:if(Xa(s)){iu=0,ou=null,Ju(t);break}t=function(){2!==iu&&9!==iu||ru!==e||(iu=7),kc(e)},s.then(t,t);break e;case 3:iu=7;break e;case 4:iu=5;break e;case 7:Xa(s)?(iu=0,ou=null,Ju(t)):(iu=0,ou=null,Zu(e,t,s,7));break;case 5:var o=null;switch(au.tag){case 26:o=au.memoizedState;case 5:case 27:var l=au;if(!o||Wd(o)){iu=0,ou=null;var u=l.sibling;if(null!==u)au=u;else{var c=l.return;null!==c?(au=c,ec(c)):au=null}break t}}iu=0,ou=null,Zu(e,t,s,5);break;case 6:iu=0,ou=null,Zu(e,t,s,6);break;case 8:Uu(),hu=6;break e;default:throw Error(i(462))}}Yu();break}catch(d){Vu(e,d)}return ya=ba=null,D.H=r,D.A=a,nu=n,null!==au?0:(ru=null,su=0,Er(),hu)}(e,t):Ku(e,t,!0),s=r;;){if(0===a){uu&&!r&&Bu(e,t,0,!1);break}if(n=e.current.alternate,!s||Pu(n)){if(2===a){if(s=t,e.errorRecoveryDisabledLanes&s)var o=0;else o=0!==(o=-536870913&e.pendingLanes)?o:536870912&o?536870912:0;if(0!==o){t=o;e:{var l=e;a=yu;var u=l.current.memoizedState.isDehydrated;if(u&&(ju(l,o).flags|=256),2!==(o=Ku(l,o,!1))){if(cu&&!u){l.errorRecoveryDisabledLanes|=s,fu|=s,a=4;break e}s=xu,xu=a,null!==s&&(null===xu?xu=s:xu.push.apply(xu,s))}a=o}if(s=!1,2!==a)continue}}if(1===a){ju(e,0),Bu(e,t,0,!0);break}e:{switch(r=e,s=a){case 0:case 1:throw Error(i(345));case 4:if((4194048&t)!==t)break;case 6:Bu(r,t,gu,!lu);break e;case 2:xu=null;break;case 3:case 5:break;default:throw Error(i(329))}if((62914560&t)===t&&10<(a=wu+300-te())){if(Bu(r,t,gu,!lu),0!==xe(r,0,!0))break e;r.timeoutHandle=ld(zu.bind(null,r,n,xu,Su,vu,t,gu,fu,bu,lu,s,2,-0,0),a)}else zu(r,n,xu,Su,vu,t,gu,fu,bu,lu,s,0,-0,0)}break}a=Ku(e,t,!1),s=!1}kc(e)}function zu(e,t,n,r,a,s,o,l,u,c,d,h,p,f){if(e.timeoutHandle=-1,(8192&(h=t.subtreeFlags)||16785408===(16785408&h))&&(Ud={stylesheets:null,count:0,unsuspend:jd},Kl(t),null!==(h=function(){if(null===Ud)throw Error(i(475));var e=Ud;return e.stylesheets&&0===e.count&&Hd(e,e.stylesheets),0<e.count?function(t){var n=setTimeout((function(){if(e.stylesheets&&Hd(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}}),6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(n)}}:null}())))return e.cancelPendingCommit=h(nc.bind(null,e,t,s,n,r,a,o,l,u,d,1,p,f)),void Bu(e,s,o,!c);nc(e,t,s,n,r,a,o,l,u)}function Pu(e){for(var t=e;;){var n=t.tag;if((0===n||11===n||15===n)&&16384&t.flags&&(null!==(n=t.updateQueue)&&null!==(n=n.stores)))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!Xn(s(),a))return!1}catch(i){return!1}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Bu(e,t,n,r){t&=~mu,t&=~fu,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var a=t;0<a;){var s=31-pe(a),i=1<<s;r[s]=-1,a&=~i}0!==n&&Ce(e,n,t)}function Wu(){return 0!==(6&nu)||(Sc(0,!1),!1)}function Uu(){if(null!==au){if(0===iu)var e=au.return;else ya=ba=null,Ms(e=au),Ki=null,Xi=0,e=au;for(;null!==e;)sl(e.alternate,e),e=e.return;au=null}}function ju(e,t){var n=e.timeoutHandle;-1!==n&&(e.timeoutHandle=-1,ud(n)),null!==(n=e.cancelPendingCommit)&&(e.cancelPendingCommit=null,n()),Uu(),ru=e,au=n=zr(e.current,null),su=t,iu=0,ou=null,lu=!1,uu=ve(e,t),cu=!1,bu=gu=mu=fu=pu=hu=0,xu=yu=null,vu=!1,0!==(8&t)&&(t|=32&t);var r=e.entangledLanes;if(0!==r)for(e=e.entanglements,r&=t;0<r;){var a=31-pe(r),s=1<<a;t|=e[a],r&=~s}return du=t,Er(),n}function Vu(e,t){xs=null,D.H=Vi,t===Ga||t===qa?(t=Za(),iu=3):t===Ha?(t=Za(),iu=4):iu=t===Co?8:null!==t&&"object"===typeof t&&"function"===typeof t.then?6:1,ou=t,null===au&&(hu=1,wo(e,Ir(t,e.current)))}function Gu(){var e=D.H;return D.H=Vi,null===e?Vi:e}function Hu(){var e=D.A;return D.A=eu,e}function qu(){hu=4,lu||(4194048&su)!==su&&null!==ro.current||(uu=!0),0===(134217727&pu)&&0===(134217727&fu)||null===ru||Bu(ru,su,gu,!1)}function Ku(e,t,n){var r=nu;nu|=2;var a=Gu(),s=Hu();ru===e&&su===t||(Su=null,ju(e,t)),t=!1;var i=hu;e:for(;;)try{if(0!==iu&&null!==au){var o=au,l=ou;switch(iu){case 8:Uu(),i=6;break e;case 3:case 2:case 9:case 6:null===ro.current&&(t=!0);var u=iu;if(iu=0,ou=null,Zu(e,o,l,u),n&&uu){i=0;break e}break;default:u=iu,iu=0,ou=null,Zu(e,o,l,u)}}Xu(),i=hu;break}catch(c){Vu(e,c)}return t&&e.shellSuspendCounter++,ya=ba=null,nu=r,D.H=a,D.A=s,null===au&&(ru=null,su=0,Er()),i}function Xu(){for(;null!==au;)Qu(au)}function Yu(){for(;null!==au&&!Z();)Qu(au)}function Qu(e){var t=Qo(e.alternate,e,du);e.memoizedProps=e.pendingProps,null===t?ec(e):au=t}function Ju(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=Lo(n,t,t.pendingProps,t.type,void 0,su);break;case 11:t=Lo(n,t,t.pendingProps,t.type.render,t.ref,su);break;case 5:Ms(t);default:sl(n,t),t=Qo(n,t=au=Pr(t,du),du)}e.memoizedProps=e.pendingProps,null===t?ec(e):au=t}function Zu(e,t,n,r){ya=ba=null,Ms(t),Ki=null,Xi=0;var a=t.return;try{if(function(e,t,n,r,a){if(n.flags|=32768,null!==r&&"object"===typeof r&&"function"===typeof r.then){if(null!==(t=n.alternate)&&Sa(t,n,a,!0),null!==(n=ro.current)){switch(n.tag){case 13:return null===ao?qu():null===n.alternate&&0===hu&&(hu=3),n.flags&=-257,n.flags|=65536,n.lanes=a,r===Ka?n.flags|=16384:(null===(t=n.updateQueue)?n.updateQueue=new Set([r]):t.add(r),dc(e,r,a)),!1;case 22:return n.flags|=65536,r===Ka?n.flags|=16384:(null===(t=n.updateQueue)?(t={transitions:null,markerInstances:null,retryQueue:new Set([r])},n.updateQueue=t):null===(n=t.retryQueue)?t.retryQueue=new Set([r]):n.add(r),dc(e,r,a)),!1}throw Error(i(435,n.tag))}return dc(e,r,a),qu(),!1}if(sa)return null!==(t=ro.current)?(0===(65536&t.flags)&&(t.flags|=256),t.flags|=65536,t.lanes=a,r!==la&&ma(Ir(e=Error(i(422),{cause:r}),n))):(r!==la&&ma(Ir(t=Error(i(423),{cause:r}),n)),(e=e.current.alternate).flags|=65536,a&=-a,e.lanes|=a,r=Ir(r,n),os(e,a=So(e.stateNode,r,a)),4!==hu&&(hu=2)),!1;var s=Error(i(520),{cause:r});if(s=Ir(s,n),null===yu?yu=[s]:yu.push(s),4!==hu&&(hu=2),null===t)return!0;r=Ir(r,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=a&-a,n.lanes|=e,os(n,e=So(n.stateNode,r,e)),!1;case 1:if(t=n.type,s=n.stateNode,0===(128&n.flags)&&("function"===typeof t.getDerivedStateFromError||null!==s&&"function"===typeof s.componentDidCatch&&(null===Iu||!Iu.has(s))))return n.flags|=65536,a&=-a,n.lanes|=a,No(a=Io(a),e,n,r),os(n,a),!1}n=n.return}while(null!==n);return!1}(e,a,t,n,su))return hu=1,wo(e,Ir(n,e.current)),void(au=null)}catch(s){if(null!==a)throw au=a,s;return hu=1,wo(e,Ir(n,e.current)),void(au=null)}32768&t.flags?(sa||1===r?e=!0:uu||0!==(536870912&su)?e=!1:(lu=e=!0,(2===r||9===r||3===r||6===r)&&(null!==(r=ro.current)&&13===r.tag&&(r.flags|=16384))),tc(t,e)):ec(t)}function ec(e){var t=e;do{if(0!==(32768&t.flags))return void tc(t,lu);e=t.return;var n=rl(t.alternate,t,du);if(null!==n)return void(au=n);if(null!==(t=t.sibling))return void(au=t);au=t=e}while(null!==t);0===hu&&(hu=5)}function tc(e,t){do{var n=al(e.alternate,e);if(null!==n)return n.flags&=32767,void(au=n);if(null!==(n=e.return)&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&null!==(e=e.sibling))return void(au=e);au=e=n}while(null!==e);hu=6,au=null}function nc(e,t,n,r,a,s,o,l,u){e.cancelPendingCommit=null;do{oc()}while(0!==Nu);if(0!==(6&nu))throw Error(i(327));if(null!==t){if(t===e.current)throw Error(i(177));if(s=t.lanes|t.childLanes,function(e,t,n,r,a,s){var i=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var o=e.entanglements,l=e.expirationTimes,u=e.hiddenUpdates;for(n=i&~n;0<n;){var c=31-pe(n),d=1<<c;o[c]=0,l[c]=-1;var h=u[c];if(null!==h)for(u[c]=null,c=0;c<h.length;c++){var p=h[c];null!==p&&(p.lane&=-536870913)}n&=~d}0!==r&&Ce(e,r,0),0!==s&&0===a&&0!==e.tag&&(e.suspendedLanes|=s&~(i&~t))}(e,n,s|=Tr,o,l,u),e===ru&&(au=ru=null,su=0),Tu=t,Cu=e,Eu=n,$u=s,Ru=a,_u=r,0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?(e.callbackNode=null,e.callbackPriority=0,Q(se,(function(){return lc(),null}))):(e.callbackNode=null,e.callbackPriority=0),r=0!==(13878&t.flags),0!==(13878&t.subtreeFlags)||r){r=D.T,D.T=null,a=O.p,O.p=2,o=nu,nu|=4;try{!function(e,t){if(e=e.containerInfo,td=nh,tr(e=er(e))){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,s=r.focusNode;r=r.focusOffset;try{n.nodeType,s.nodeType}catch(g){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==a&&3!==h.nodeType||(l=o+a),h!==s||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===a&&(l=o),p===s&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(nd={focusedElem:e,selectionRange:n},nh=!1,Sl=t;null!==Sl;)if(e=(t=Sl).child,0!==(1024&t.subtreeFlags)&&null!==e)e.return=t,Sl=e;else for(;null!==Sl;){switch(s=(t=Sl).alternate,e=t.flags,t.tag){case 0:case 11:case 15:case 5:case 26:case 27:case 6:case 4:case 17:break;case 1:if(0!==(1024&e)&&null!==s){e=void 0,n=t,a=s.memoizedProps,s=s.memoizedState,r=n.stateNode;try{var m=go(n.type,a,(n.elementType,n.type));e=r.getSnapshotBeforeUpdate(m,s),r.__reactInternalSnapshotBeforeUpdate=e}catch(b){cc(n,n.return,b)}}break;case 3:if(0!==(1024&e))if(9===(n=(e=t.stateNode.containerInfo).nodeType))md(e);else if(1===n)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":md(e);break;default:e.textContent=""}break;default:if(0!==(1024&e))throw Error(i(163))}if(null!==(e=t.sibling)){e.return=t.return,Sl=e;break}Sl=t.return}}(e,t)}finally{nu=o,O.p=a,D.T=r}}Nu=1,rc(),ac(),sc()}}function rc(){if(1===Nu){Nu=0;var e=Cu,t=Tu,n=0!==(13878&t.flags);if(0!==(13878&t.subtreeFlags)||n){n=D.T,D.T=null;var r=O.p;O.p=2;var a=nu;nu|=4;try{Dl(t,e);var s=nd,i=er(e.containerInfo),o=s.focusedElem,l=s.selectionRange;if(i!==o&&o&&o.ownerDocument&&Zn(o.ownerDocument.documentElement,o)){if(null!==l&&tr(o)){var u=l.start,c=l.end;if(void 0===c&&(c=u),"selectionStart"in o)o.selectionStart=u,o.selectionEnd=Math.min(c,o.value.length);else{var d=o.ownerDocument||document,h=d&&d.defaultView||window;if(h.getSelection){var p=h.getSelection(),f=o.textContent.length,m=Math.min(l.start,f),g=void 0===l.end?m:Math.min(l.end,f);!p.extend&&m>g&&(i=g,g=m,m=i);var b=Jn(o,m),y=Jn(o,g);if(b&&y&&(1!==p.rangeCount||p.anchorNode!==b.node||p.anchorOffset!==b.offset||p.focusNode!==y.node||p.focusOffset!==y.offset)){var x=d.createRange();x.setStart(b.node,b.offset),p.removeAllRanges(),m>g?(p.addRange(x),p.extend(y.node,y.offset)):(x.setEnd(y.node,y.offset),p.addRange(x))}}}}for(d=[],p=o;p=p.parentNode;)1===p.nodeType&&d.push({element:p,left:p.scrollLeft,top:p.scrollTop});for("function"===typeof o.focus&&o.focus(),o=0;o<d.length;o++){var v=d[o];v.element.scrollLeft=v.left,v.element.scrollTop=v.top}}nh=!!td,nd=td=null}finally{nu=a,O.p=r,D.T=n}}e.current=t,Nu=2}}function ac(){if(2===Nu){Nu=0;var e=Cu,t=Tu,n=0!==(8772&t.flags);if(0!==(8772&t.subtreeFlags)||n){n=D.T,D.T=null;var r=O.p;O.p=2;var a=nu;nu|=4;try{Il(e,t.alternate,t)}finally{nu=a,O.p=r,D.T=n}}Nu=3}}function sc(){if(4===Nu||3===Nu){Nu=0,ee();var e=Cu,t=Tu,n=Eu,r=_u;0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?Nu=5:(Nu=0,Tu=Cu=null,ic(e,e.pendingLanes));var a=e.pendingLanes;if(0===a&&(Iu=null),$e(n),t=t.stateNode,de&&"function"===typeof de.onCommitFiberRoot)try{de.onCommitFiberRoot(ce,t,void 0,128===(128&t.current.flags))}catch(l){}if(null!==r){t=D.T,a=O.p,O.p=2,D.T=null;try{for(var s=e.onRecoverableError,i=0;i<r.length;i++){var o=r[i];s(o.value,{componentStack:o.stack})}}finally{D.T=t,O.p=a}}0!==(3&Eu)&&oc(),kc(e),a=e.pendingLanes,0!==(4194090&n)&&0!==(42&a)?e===Fu?Au++:(Au=0,Fu=e):Au=0,Sc(0,!1)}}function ic(e,t){0===(e.pooledCacheLanes&=t)&&(null!=(t=e.pooledCache)&&(e.pooledCache=null,Da(t)))}function oc(e){return rc(),ac(),sc(),lc()}function lc(){if(5!==Nu)return!1;var e=Cu,t=$u;$u=0;var n=$e(Eu),r=D.T,a=O.p;try{O.p=32>n?32:n,D.T=null,n=Ru,Ru=null;var s=Cu,o=Eu;if(Nu=0,Tu=Cu=null,Eu=0,0!==(6&nu))throw Error(i(331));var l=nu;if(nu|=4,Ql(s.current),jl(s,s.current,o,n),nu=l,Sc(0,!1),de&&"function"===typeof de.onPostCommitFiberRoot)try{de.onPostCommitFiberRoot(ce,s)}catch(u){}return!0}finally{O.p=a,D.T=r,ic(e,t)}}function uc(e,t,n){t=Ir(n,t),null!==(e=ss(e,t=So(e.stateNode,t,2),2))&&(Ne(e,2),kc(e))}function cc(e,t,n){if(3===e.tag)uc(e,e,n);else for(;null!==t;){if(3===t.tag){uc(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Iu||!Iu.has(r))){e=Ir(n,e),null!==(r=ss(t,n=Io(2),2))&&(No(n,r,t,e),Ne(r,2),kc(r));break}}t=t.return}}function dc(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new tu;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(cu=!0,a.add(n),e=hc.bind(null,e,t,n),t.then(e,e))}function hc(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,ru===e&&(su&n)===n&&(4===hu||3===hu&&(62914560&su)===su&&300>te()-wu?0===(2&nu)&&ju(e,0):mu|=n,bu===su&&(bu=0)),kc(e)}function pc(e,t){0===t&&(t=Se()),null!==(e=_r(e,t))&&(Ne(e,t),kc(e))}function fc(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),pc(e,n)}function mc(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;case 22:r=e.stateNode._retryCache;break;default:throw Error(i(314))}null!==r&&r.delete(t),pc(e,n)}var gc=null,bc=null,yc=!1,xc=!1,vc=!1,wc=0;function kc(e){e!==bc&&null===e.next&&(null===bc?gc=bc=e:bc=bc.next=e),xc=!0,yc||(yc=!0,dd((function(){0!==(6&nu)?Q(re,Ic):Nc()})))}function Sc(e,t){if(!vc&&xc){vc=!0;do{for(var n=!1,r=gc;null!==r;){if(!t)if(0!==e){var a=r.pendingLanes;if(0===a)var s=0;else{var i=r.suspendedLanes,o=r.pingedLanes;s=(1<<31-pe(42|e)+1)-1,s=201326741&(s&=a&~(i&~o))?201326741&s|1:s?2|s:0}0!==s&&(n=!0,Ec(r,s))}else s=su,0===(3&(s=xe(r,r===ru?s:0,null!==r.cancelPendingCommit||-1!==r.timeoutHandle)))||ve(r,s)||(n=!0,Ec(r,s));r=r.next}}while(n);vc=!1}}function Ic(){Nc()}function Nc(){xc=yc=!1;var e=0;0!==wc&&(function(){var e=window.event;if(e&&"popstate"===e.type)return e!==od&&(od=e,!0);return od=null,!1}()&&(e=wc),wc=0);for(var t=te(),n=null,r=gc;null!==r;){var a=r.next,s=Cc(r,t);0===s?(r.next=null,null===n?gc=a:n.next=a,null===a&&(bc=n)):(n=r,(0!==e||0!==(3&s))&&(xc=!0)),r=a}Sc(e,!1)}function Cc(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,s=-62914561&e.pendingLanes;0<s;){var i=31-pe(s),o=1<<i,l=a[i];-1===l?0!==(o&n)&&0===(o&r)||(a[i]=we(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}if(n=su,n=xe(e,e===(t=ru)?n:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle),r=e.callbackNode,0===n||e===t&&(2===iu||9===iu)||null!==e.cancelPendingCommit)return null!==r&&null!==r&&J(r),e.callbackNode=null,e.callbackPriority=0;if(0===(3&n)||ve(e,n)){if((t=n&-n)===e.callbackPriority)return t;switch(null!==r&&J(r),$e(n)){case 2:case 8:n=ae;break;case 32:default:n=se;break;case 268435456:n=oe}return r=Tc.bind(null,e),n=Q(n,r),e.callbackPriority=t,e.callbackNode=n,t}return null!==r&&null!==r&&J(r),e.callbackPriority=2,e.callbackNode=null,2}function Tc(e,t){if(0!==Nu&&5!==Nu)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(oc()&&e.callbackNode!==n)return null;var r=su;return 0===(r=xe(e,e===ru?r:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle))?null:(Mu(e,r,t),Cc(e,te()),null!=e.callbackNode&&e.callbackNode===n?Tc.bind(null,e):null)}function Ec(e,t){if(oc())return null;Mu(e,t,!0)}function $c(){return 0===wc&&(wc=ke()),wc}function Rc(e){return null==e||"symbol"===typeof e||"boolean"===typeof e?null:"function"===typeof e?e:$t(""+e)}function _c(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}for(var Ac=0;Ac<wr.length;Ac++){var Fc=wr[Ac];kr(Fc.toLowerCase(),"on"+(Fc[0].toUpperCase()+Fc.slice(1)))}kr(pr,"onAnimationEnd"),kr(fr,"onAnimationIteration"),kr(mr,"onAnimationStart"),kr("dblclick","onDoubleClick"),kr("focusin","onFocus"),kr("focusout","onBlur"),kr(gr,"onTransitionRun"),kr(br,"onTransitionStart"),kr(yr,"onTransitionCancel"),kr(xr,"onTransitionEnd"),Xe("onMouseEnter",["mouseout","mouseover"]),Xe("onMouseLeave",["mouseout","mouseover"]),Xe("onPointerEnter",["pointerout","pointerover"]),Xe("onPointerLeave",["pointerout","pointerover"]),Ke("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ke("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ke("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ke("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ke("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ke("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Dc="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Oc=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Dc));function Lc(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var s=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==s&&a.isPropagationStopped())break e;s=o,a.currentTarget=u;try{s(a)}catch(c){bo(c)}a.currentTarget=null,s=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==s&&a.isPropagationStopped())break e;s=o,a.currentTarget=u;try{s(a)}catch(c){bo(c)}a.currentTarget=null,s=l}}}}function Mc(e,t){var n=t[Oe];void 0===n&&(n=t[Oe]=new Set);var r=e+"__bubble";n.has(r)||(Wc(t,e,2,!1),n.add(r))}function zc(e,t,n){var r=0;t&&(r|=4),Wc(n,e,r,t)}var Pc="_reactListening"+Math.random().toString(36).slice(2);function Bc(e){if(!e[Pc]){e[Pc]=!0,He.forEach((function(t){"selectionchange"!==t&&(Oc.has(t)||zc(t,!1,e),zc(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Pc]||(t[Pc]=!0,zc("selectionchange",!1,t))}}function Wc(e,t,n,r){switch(uh(t)){case 2:var a=rh;break;case 8:a=ah;break;default:a=sh}n=a.bind(null,t,n,e),a=void 0,!Pt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Uc(e,t,n,r,a){var s=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===a)break;if(4===i)for(i=r.return;null!==i;){var u=i.tag;if((3===u||4===u)&&i.stateNode.containerInfo===a)return;i=i.return}for(;null!==o;){if(null===(i=We(o)))return;if(5===(u=i.tag)||6===u||26===u||27===u){r=s=i;continue e}o=o.parentNode}}r=r.return}Lt((function(){var r=s,a=_t(n),i=[];e:{var o=vr.get(e);if(void 0!==o){var u=Zt,c=e;switch(e){case"keypress":if(0===Gt(n))break e;case"keydown":case"keyup":u=mn;break;case"focusin":c="focus",u=sn;break;case"focusout":c="blur",u=sn;break;case"beforeblur":case"afterblur":u=sn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":u=rn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":u=an;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":u=bn;break;case pr:case fr:case mr:u=on;break;case xr:u=yn;break;case"scroll":case"scrollend":u=tn;break;case"wheel":u=xn;break;case"copy":case"cut":case"paste":u=ln;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":u=gn;break;case"toggle":case"beforetoggle":u=vn}var d=0!==(4&t),h=!d&&("scroll"===e||"scrollend"===e),p=d?null!==o?o+"Capture":null:o;d=[];for(var f,m=r;null!==m;){var g=m;if(f=g.stateNode,5!==(g=g.tag)&&26!==g&&27!==g||null===f||null===p||null!=(g=Mt(m,p))&&d.push(jc(m,g,f)),h)break;m=m.return}0<d.length&&(o=new u(o,c,null,n,a),i.push({event:o,listeners:d}))}}if(0===(7&t)){if(u="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===Rt||!(c=n.relatedTarget||n.fromElement)||!We(c)&&!c[De])&&(u||o)&&(o=a.window===a?a:(o=a.ownerDocument)?o.defaultView||o.parentWindow:window,u?(u=r,null!==(c=(c=n.relatedTarget||n.toElement)?We(c):null)&&(h=l(c),d=c.tag,c!==h||5!==d&&27!==d&&6!==d)&&(c=null)):(u=null,c=r),u!==c)){if(d=rn,g="onMouseLeave",p="onMouseEnter",m="mouse","pointerout"!==e&&"pointerover"!==e||(d=gn,g="onPointerLeave",p="onPointerEnter",m="pointer"),h=null==u?o:je(u),f=null==c?o:je(c),(o=new d(g,m+"leave",u,n,a)).target=h,o.relatedTarget=f,g=null,We(a)===r&&((d=new d(p,m+"enter",c,n,a)).target=f,d.relatedTarget=h,g=d),h=g,u&&c)e:{for(p=c,m=0,f=d=u;f;f=Gc(f))m++;for(f=0,g=p;g;g=Gc(g))f++;for(;0<m-f;)d=Gc(d),m--;for(;0<f-m;)p=Gc(p),f--;for(;m--;){if(d===p||null!==p&&d===p.alternate)break e;d=Gc(d),p=Gc(p)}d=null}else d=null;null!==u&&Hc(i,o,u,d,!1),null!==c&&null!==h&&Hc(i,h,c,d,!0)}if("select"===(u=(o=r?je(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===u&&"file"===o.type)var b=zn;else if(An(o))if(Pn)b=Kn;else{b=Hn;var y=Gn}else!(u=o.nodeName)||"input"!==u.toLowerCase()||"checkbox"!==o.type&&"radio"!==o.type?r&&Ct(r.elementType)&&(b=zn):b=qn;switch(b&&(b=b(e,r))?Fn(i,b,n,a):(y&&y(e,o,r),"focusout"===e&&r&&"number"===o.type&&null!=r.memoizedProps.value&&yt(o,"number",o.value)),y=r?je(r):window,e){case"focusin":(An(y)||"true"===y.contentEditable)&&(rr=y,ar=r,sr=null);break;case"focusout":sr=ar=rr=null;break;case"mousedown":ir=!0;break;case"contextmenu":case"mouseup":case"dragend":ir=!1,or(i,n,a);break;case"selectionchange":if(nr)break;case"keydown":case"keyup":or(i,n,a)}var x;if(kn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Rn?En(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Nn&&"ko"!==n.locale&&(Rn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Rn&&(x=Vt()):(Ut="value"in(Wt=a)?Wt.value:Wt.textContent,Rn=!0)),0<(y=Vc(r,v)).length&&(v=new un(v,e,null,n,a),i.push({event:v,listeners:y}),x?v.data=x:null!==(x=$n(n))&&(v.data=x))),(x=In?function(e,t){switch(e){case"compositionend":return $n(t);case"keypress":return 32!==t.which?null:(Tn=!0,Cn);case"textInput":return(e=t.data)===Cn&&Tn?null:e;default:return null}}(e,n):function(e,t){if(Rn)return"compositionend"===e||!kn&&En(e,t)?(e=Vt(),jt=Ut=Wt=null,Rn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Nn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(v=Vc(r,"onBeforeInput")).length&&(y=new un("onBeforeInput","beforeinput",null,n,a),i.push({event:y,listeners:v}),y.data=x)),function(e,t,n,r,a){if("submit"===t&&n&&n.stateNode===a){var s=Rc((a[Fe]||null).action),i=r.submitter;i&&null!==(t=(t=i[Fe]||null)?Rc(t.formAction):i.getAttribute("formAction"))&&(s=t,i=null);var o=new Zt("action","action",null,r,a);e.push({event:o,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(0!==wc){var e=i?_c(a,i):new FormData(a);Ri(n,{pending:!0,data:e,method:a.method,action:s},null,e)}}else"function"===typeof s&&(o.preventDefault(),e=i?_c(a,i):new FormData(a),Ri(n,{pending:!0,data:e,method:a.method,action:s},s,e))},currentTarget:a}]})}}(i,e,r,n,a)}Lc(i,t)}))}function jc(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Vc(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,s=a.stateNode;if(5!==(a=a.tag)&&26!==a&&27!==a||null===s||(null!=(a=Mt(e,n))&&r.unshift(jc(e,a,s)),null!=(a=Mt(e,t))&&r.push(jc(e,a,s))),3===e.tag)return r;e=e.return}return[]}function Gc(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag&&27!==e.tag);return e||null}function Hc(e,t,n,r,a){for(var s=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(o=o.tag,null!==l&&l===r)break;5!==o&&26!==o&&27!==o||null===u||(l=u,a?null!=(u=Mt(n,s))&&i.unshift(jc(n,u,l)):a||null!=(u=Mt(n,s))&&i.push(jc(n,u,l))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var qc=/\r\n?/g,Kc=/\u0000|\uFFFD/g;function Xc(e){return("string"===typeof e?e:""+e).replace(qc,"\n").replace(Kc,"")}function Yc(e,t){return t=Xc(t),Xc(e)===t}function Qc(){}function Jc(e,t,n,r,a,s){switch(n){case"children":"string"===typeof r?"body"===t||"textarea"===t&&""===r||kt(e,r):("number"===typeof r||"bigint"===typeof r)&&"body"!==t&&kt(e,""+r);break;case"className":nt(e,"class",r);break;case"tabIndex":nt(e,"tabindex",r);break;case"dir":case"role":case"viewBox":case"width":case"height":nt(e,n,r);break;case"style":Nt(e,r,s);break;case"data":if("object"!==t){nt(e,"data",r);break}case"src":case"href":if(""===r&&("a"!==t||"href"!==n)){e.removeAttribute(n);break}if(null==r||"function"===typeof r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=$t(""+r),e.setAttribute(n,r);break;case"action":case"formAction":if("function"===typeof r){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}if("function"===typeof s&&("formAction"===n?("input"!==t&&Jc(e,t,"name",a.name,a,null),Jc(e,t,"formEncType",a.formEncType,a,null),Jc(e,t,"formMethod",a.formMethod,a,null),Jc(e,t,"formTarget",a.formTarget,a,null)):(Jc(e,t,"encType",a.encType,a,null),Jc(e,t,"method",a.method,a,null),Jc(e,t,"target",a.target,a,null))),null==r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=$t(""+r),e.setAttribute(n,r);break;case"onClick":null!=r&&(e.onclick=Qc);break;case"onScroll":null!=r&&Mc("scroll",e);break;case"onScrollEnd":null!=r&&Mc("scrollend",e);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=a.children)throw Error(i(60));e.innerHTML=n}}break;case"multiple":e.multiple=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"muted":e.muted=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":case"autoFocus":break;case"xlinkHref":if(null==r||"function"===typeof r||"boolean"===typeof r||"symbol"===typeof r){e.removeAttribute("xlink:href");break}n=$t(""+r),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""+r):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":!0===r?e.setAttribute(n,""):!1!==r&&null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,r):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":null!=r&&"function"!==typeof r&&"symbol"!==typeof r&&!isNaN(r)&&1<=r?e.setAttribute(n,r):e.removeAttribute(n);break;case"rowSpan":case"start":null==r||"function"===typeof r||"symbol"===typeof r||isNaN(r)?e.removeAttribute(n):e.setAttribute(n,r);break;case"popover":Mc("beforetoggle",e),Mc("toggle",e),tt(e,"popover",r);break;case"xlinkActuate":rt(e,"http://www.w3.org/1999/xlink","xlink:actuate",r);break;case"xlinkArcrole":rt(e,"http://www.w3.org/1999/xlink","xlink:arcrole",r);break;case"xlinkRole":rt(e,"http://www.w3.org/1999/xlink","xlink:role",r);break;case"xlinkShow":rt(e,"http://www.w3.org/1999/xlink","xlink:show",r);break;case"xlinkTitle":rt(e,"http://www.w3.org/1999/xlink","xlink:title",r);break;case"xlinkType":rt(e,"http://www.w3.org/1999/xlink","xlink:type",r);break;case"xmlBase":rt(e,"http://www.w3.org/XML/1998/namespace","xml:base",r);break;case"xmlLang":rt(e,"http://www.w3.org/XML/1998/namespace","xml:lang",r);break;case"xmlSpace":rt(e,"http://www.w3.org/XML/1998/namespace","xml:space",r);break;case"is":tt(e,"is",r);break;case"innerText":case"textContent":break;default:(!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&tt(e,n=Tt.get(n)||n,r)}}function Zc(e,t,n,r,a,s){switch(n){case"style":Nt(e,r,s);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=a.children)throw Error(i(60));e.innerHTML=n}}break;case"children":"string"===typeof r?kt(e,r):("number"===typeof r||"bigint"===typeof r)&&kt(e,""+r);break;case"onScroll":null!=r&&Mc("scroll",e);break;case"onScrollEnd":null!=r&&Mc("scrollend",e);break;case"onClick":null!=r&&(e.onclick=Qc);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":case"innerText":case"textContent":break;default:qe.hasOwnProperty(n)||("o"!==n[0]||"n"!==n[1]||(a=n.endsWith("Capture"),t=n.slice(2,a?n.length-7:void 0),"function"===typeof(s=null!=(s=e[Fe]||null)?s[n]:null)&&e.removeEventListener(t,s,a),"function"!==typeof r)?n in e?e[n]=r:!0===r?e.setAttribute(n,""):tt(e,n,r):("function"!==typeof s&&null!==s&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,r,a)))}}function ed(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Mc("error",e),Mc("load",e);var r,a=!1,s=!1;for(r in n)if(n.hasOwnProperty(r)){var o=n[r];if(null!=o)switch(r){case"src":a=!0;break;case"srcSet":s=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:Jc(e,t,r,o,n,null)}}return s&&Jc(e,t,"srcSet",n.srcSet,n,null),void(a&&Jc(e,t,"src",n.src,n,null));case"input":Mc("invalid",e);var l=r=o=s=null,u=null,c=null;for(a in n)if(n.hasOwnProperty(a)){var d=n[a];if(null!=d)switch(a){case"name":s=d;break;case"type":o=d;break;case"checked":u=d;break;case"defaultChecked":c=d;break;case"value":r=d;break;case"defaultValue":l=d;break;case"children":case"dangerouslySetInnerHTML":if(null!=d)throw Error(i(137,t));break;default:Jc(e,t,a,d,n,null)}}return bt(e,r,l,u,c,o,s,!1),void dt(e);case"select":for(s in Mc("invalid",e),a=o=r=null,n)if(n.hasOwnProperty(s)&&null!=(l=n[s]))switch(s){case"value":r=l;break;case"defaultValue":o=l;break;case"multiple":a=l;default:Jc(e,t,s,l,n,null)}return t=r,n=o,e.multiple=!!a,void(null!=t?xt(e,!!a,t,!1):null!=n&&xt(e,!!a,n,!0));case"textarea":for(o in Mc("invalid",e),r=s=a=null,n)if(n.hasOwnProperty(o)&&null!=(l=n[o]))switch(o){case"value":a=l;break;case"defaultValue":s=l;break;case"children":r=l;break;case"dangerouslySetInnerHTML":if(null!=l)throw Error(i(91));break;default:Jc(e,t,o,l,n,null)}return wt(e,a,s,r),void dt(e);case"option":for(u in n)if(n.hasOwnProperty(u)&&null!=(a=n[u]))if("selected"===u)e.selected=a&&"function"!==typeof a&&"symbol"!==typeof a;else Jc(e,t,u,a,n,null);return;case"dialog":Mc("beforetoggle",e),Mc("toggle",e),Mc("cancel",e),Mc("close",e);break;case"iframe":case"object":Mc("load",e);break;case"video":case"audio":for(a=0;a<Dc.length;a++)Mc(Dc[a],e);break;case"image":Mc("error",e),Mc("load",e);break;case"details":Mc("toggle",e);break;case"embed":case"source":case"link":Mc("error",e),Mc("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(c in n)if(n.hasOwnProperty(c)&&null!=(a=n[c]))switch(c){case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:Jc(e,t,c,a,n,null)}return;default:if(Ct(t)){for(d in n)n.hasOwnProperty(d)&&(void 0!==(a=n[d])&&Zc(e,t,d,a,n,void 0));return}}for(l in n)n.hasOwnProperty(l)&&(null!=(a=n[l])&&Jc(e,t,l,a,n,null))}var td=null,nd=null;function rd(e){return 9===e.nodeType?e:e.ownerDocument}function ad(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function sd(e,t){if(0===e)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return 1===e&&"foreignObject"===t?0:e}function id(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"bigint"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var od=null;var ld="function"===typeof setTimeout?setTimeout:void 0,ud="function"===typeof clearTimeout?clearTimeout:void 0,cd="function"===typeof Promise?Promise:void 0,dd="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof cd?function(e){return cd.resolve(null).then(e).catch(hd)}:ld;function hd(e){setTimeout((function(){throw e}))}function pd(e){return"head"===e}function fd(e,t){var n=t,r=0,a=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&8===s.nodeType)if("/$"===(n=s.data)){if(0<r&&8>r){n=r;var i=e.ownerDocument;if(1&n&&wd(i.documentElement),2&n&&wd(i.body),4&n)for(wd(n=i.head),i=n.firstChild;i;){var o=i.nextSibling,l=i.nodeName;i[Pe]||"SCRIPT"===l||"STYLE"===l||"LINK"===l&&"stylesheet"===i.rel.toLowerCase()||n.removeChild(i),i=o}}if(0===a)return e.removeChild(s),void Th(t);a--}else"$"===n||"$?"===n||"$!"===n?a++:r=n.charCodeAt(0)-48;else r=0;n=s}while(n);Th(t)}function md(e){var t=e.firstChild;for(t&&10===t.nodeType&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":md(n),Be(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if("stylesheet"===n.rel.toLowerCase())continue}e.removeChild(n)}}function gd(e){return"$!"===e.data||"$?"===e.data&&"complete"===e.ownerDocument.readyState}function bd(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t||"F!"===t||"F"===t)break;if("/$"===t)return null}}return e}var yd=null;function xd(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}function vd(e,t,n){switch(t=rd(n),e){case"html":if(!(e=t.documentElement))throw Error(i(452));return e;case"head":if(!(e=t.head))throw Error(i(453));return e;case"body":if(!(e=t.body))throw Error(i(454));return e;default:throw Error(i(451))}}function wd(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);Be(e)}var kd=new Map,Sd=new Set;function Id(e){return"function"===typeof e.getRootNode?e.getRootNode():9===e.nodeType?e:e.ownerDocument}var Nd=O.d;O.d={f:function(){var e=Nd.f(),t=Wu();return e||t},r:function(e){var t=Ue(e);null!==t&&5===t.tag&&"form"===t.type?Ai(t):Nd.r(e)},D:function(e){Nd.D(e),Td("dns-prefetch",e,null)},C:function(e,t){Nd.C(e,t),Td("preconnect",e,t)},L:function(e,t,n){Nd.L(e,t,n);var r=Cd;if(r&&e&&t){var a='link[rel="preload"][as="'+mt(t)+'"]';"image"===t&&n&&n.imageSrcSet?(a+='[imagesrcset="'+mt(n.imageSrcSet)+'"]',"string"===typeof n.imageSizes&&(a+='[imagesizes="'+mt(n.imageSizes)+'"]')):a+='[href="'+mt(e)+'"]';var s=a;switch(t){case"style":s=$d(e);break;case"script":s=Ad(e)}kd.has(s)||(e=h({rel:"preload",href:"image"===t&&n&&n.imageSrcSet?void 0:e,as:t},n),kd.set(s,e),null!==r.querySelector(a)||"style"===t&&r.querySelector(Rd(s))||"script"===t&&r.querySelector(Fd(s))||(ed(t=r.createElement("link"),"link",e),Ge(t),r.head.appendChild(t)))}},m:function(e,t){Nd.m(e,t);var n=Cd;if(n&&e){var r=t&&"string"===typeof t.as?t.as:"script",a='link[rel="modulepreload"][as="'+mt(r)+'"][href="'+mt(e)+'"]',s=a;switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":s=Ad(e)}if(!kd.has(s)&&(e=h({rel:"modulepreload",href:e},t),kd.set(s,e),null===n.querySelector(a))){switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(Fd(s)))return}ed(r=n.createElement("link"),"link",e),Ge(r),n.head.appendChild(r)}}},X:function(e,t){Nd.X(e,t);var n=Cd;if(n&&e){var r=Ve(n).hoistableScripts,a=Ad(e),s=r.get(a);s||((s=n.querySelector(Fd(a)))||(e=h({src:e,async:!0},t),(t=kd.get(a))&&Md(e,t),Ge(s=n.createElement("script")),ed(s,"link",e),n.head.appendChild(s)),s={type:"script",instance:s,count:1,state:null},r.set(a,s))}},S:function(e,t,n){Nd.S(e,t,n);var r=Cd;if(r&&e){var a=Ve(r).hoistableStyles,s=$d(e);t=t||"default";var i=a.get(s);if(!i){var o={loading:0,preload:null};if(i=r.querySelector(Rd(s)))o.loading=5;else{e=h({rel:"stylesheet",href:e,"data-precedence":t},n),(n=kd.get(s))&&Ld(e,n);var l=i=r.createElement("link");Ge(l),ed(l,"link",e),l._p=new Promise((function(e,t){l.onload=e,l.onerror=t})),l.addEventListener("load",(function(){o.loading|=1})),l.addEventListener("error",(function(){o.loading|=2})),o.loading|=4,Od(i,t,r)}i={type:"stylesheet",instance:i,count:1,state:o},a.set(s,i)}}},M:function(e,t){Nd.M(e,t);var n=Cd;if(n&&e){var r=Ve(n).hoistableScripts,a=Ad(e),s=r.get(a);s||((s=n.querySelector(Fd(a)))||(e=h({src:e,async:!0,type:"module"},t),(t=kd.get(a))&&Md(e,t),Ge(s=n.createElement("script")),ed(s,"link",e),n.head.appendChild(s)),s={type:"script",instance:s,count:1,state:null},r.set(a,s))}}};var Cd="undefined"===typeof document?null:document;function Td(e,t,n){var r=Cd;if(r&&"string"===typeof t&&t){var a=mt(t);a='link[rel="'+e+'"][href="'+a+'"]',"string"===typeof n&&(a+='[crossorigin="'+n+'"]'),Sd.has(a)||(Sd.add(a),e={rel:e,crossOrigin:n,href:t},null===r.querySelector(a)&&(ed(t=r.createElement("link"),"link",e),Ge(t),r.head.appendChild(t)))}}function Ed(e,t,n,r){var a,s,o,l,u=(u=V.current)?Id(u):null;if(!u)throw Error(i(446));switch(e){case"meta":case"title":return null;case"style":return"string"===typeof n.precedence&&"string"===typeof n.href?(t=$d(n.href),(r=(n=Ve(u).hoistableStyles).get(t))||(r={type:"style",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};case"link":if("stylesheet"===n.rel&&"string"===typeof n.href&&"string"===typeof n.precedence){e=$d(n.href);var c=Ve(u).hoistableStyles,d=c.get(e);if(d||(u=u.ownerDocument||u,d={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},c.set(e,d),(c=u.querySelector(Rd(e)))&&!c._p&&(d.instance=c,d.state.loading=5),kd.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},kd.set(e,n),c||(a=u,s=e,o=n,l=d.state,a.querySelector('link[rel="preload"][as="style"]['+s+"]")?l.loading=1:(s=a.createElement("link"),l.preload=s,s.addEventListener("load",(function(){return l.loading|=1})),s.addEventListener("error",(function(){return l.loading|=2})),ed(s,"link",o),Ge(s),a.head.appendChild(s))))),t&&null===r)throw Error(i(528,""));return d}if(t&&null!==r)throw Error(i(529,""));return null;case"script":return t=n.async,"string"===typeof(n=n.src)&&t&&"function"!==typeof t&&"symbol"!==typeof t?(t=Ad(n),(r=(n=Ve(u).hoistableScripts).get(t))||(r={type:"script",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};default:throw Error(i(444,e))}}function $d(e){return'href="'+mt(e)+'"'}function Rd(e){return'link[rel="stylesheet"]['+e+"]"}function _d(e){return h({},e,{"data-precedence":e.precedence,precedence:null})}function Ad(e){return'[src="'+mt(e)+'"]'}function Fd(e){return"script[async]"+e}function Dd(e,t,n){if(t.count++,null===t.instance)switch(t.type){case"style":var r=e.querySelector('style[data-href~="'+mt(n.href)+'"]');if(r)return t.instance=r,Ge(r),r;var a=h({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return Ge(r=(e.ownerDocument||e).createElement("style")),ed(r,"style",a),Od(r,n.precedence,e),t.instance=r;case"stylesheet":a=$d(n.href);var s=e.querySelector(Rd(a));if(s)return t.state.loading|=4,t.instance=s,Ge(s),s;r=_d(n),(a=kd.get(a))&&Ld(r,a),Ge(s=(e.ownerDocument||e).createElement("link"));var o=s;return o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),ed(s,"link",r),t.state.loading|=4,Od(s,n.precedence,e),t.instance=s;case"script":return s=Ad(n.src),(a=e.querySelector(Fd(s)))?(t.instance=a,Ge(a),a):(r=n,(a=kd.get(s))&&Md(r=h({},n),a),Ge(a=(e=e.ownerDocument||e).createElement("script")),ed(a,"link",r),e.head.appendChild(a),t.instance=a);case"void":return null;default:throw Error(i(443,t.type))}else"stylesheet"===t.type&&0===(4&t.state.loading)&&(r=t.instance,t.state.loading|=4,Od(r,n.precedence,e));return t.instance}function Od(e,t,n){for(var r=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),a=r.length?r[r.length-1]:null,s=a,i=0;i<r.length;i++){var o=r[i];if(o.dataset.precedence===t)s=o;else if(s!==a)break}s?s.parentNode.insertBefore(e,s.nextSibling):(t=9===n.nodeType?n.head:n).insertBefore(e,t.firstChild)}function Ld(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.title&&(e.title=t.title)}function Md(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.integrity&&(e.integrity=t.integrity)}var zd=null;function Pd(e,t,n){if(null===zd){var r=new Map,a=zd=new Map;a.set(n,r)}else(r=(a=zd).get(n))||(r=new Map,a.set(n,r));if(r.has(e))return r;for(r.set(e,null),n=n.getElementsByTagName(e),a=0;a<n.length;a++){var s=n[a];if(!(s[Pe]||s[Ae]||"link"===e&&"stylesheet"===s.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==s.namespaceURI){var i=s.getAttribute(t)||"";i=e+i;var o=r.get(i);o?o.push(s):r.set(i,[s])}}return r}function Bd(e,t,n){(e=e.ownerDocument||e).head.insertBefore(n,"title"===t?e.querySelector("head > title"):null)}function Wd(e){return"stylesheet"!==e.type||0!==(3&e.state.loading)}var Ud=null;function jd(){}function Vd(){if(this.count--,0===this.count)if(this.stylesheets)Hd(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}var Gd=null;function Hd(e,t){e.stylesheets=null,null!==e.unsuspend&&(e.count++,Gd=new Map,t.forEach(qd,e),Gd=null,Vd.call(e))}function qd(e,t){if(!(4&t.state.loading)){var n=Gd.get(e);if(n)var r=n.get(null);else{n=new Map,Gd.set(e,n);for(var a=e.querySelectorAll("link[data-precedence],style[data-precedence]"),s=0;s<a.length;s++){var i=a[s];"LINK"!==i.nodeName&&"not all"===i.getAttribute("media")||(n.set(i.dataset.precedence,i),r=i)}r&&n.set(null,r)}i=(a=t.instance).getAttribute("data-precedence"),(s=n.get(i)||r)===r&&n.set(null,a),n.set(i,a),this.count++,r=Vd.bind(this),a.addEventListener("load",r),a.addEventListener("error",r),s?s.parentNode.insertBefore(a,s.nextSibling):(e=9===e.nodeType?e.head:e).insertBefore(a,e.firstChild),t.state.loading|=4}}var Kd={$$typeof:w,Provider:null,Consumer:null,_currentValue:L,_currentValue2:L,_threadCount:0};function Xd(e,t,n,r,a,s,i,o){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ie(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ie(0),this.hiddenUpdates=Ie(null),this.identifierPrefix=r,this.onUncaughtError=a,this.onCaughtError=s,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=o,this.incompleteTransitions=new Map}function Yd(e,t,n,r,a,s,i,o,l,u,c,d){return e=new Xd(e,t,n,i,o,l,u,d),t=1,!0===s&&(t|=24),s=Lr(3,null,null,t),e.current=s,s.stateNode=e,(t=Fa()).refCount++,e.pooledCache=t,t.refCount++,s.memoizedState={element:r,isDehydrated:n,cache:t},ns(s),e}function Qd(e){return e?e=Dr:Dr}function Jd(e,t,n,r,a,s){a=Qd(a),null===r.context?r.context=a:r.pendingContext=a,(r=as(t)).payload={element:n},null!==(s=void 0===s?null:s)&&(r.callback=s),null!==(n=ss(e,r,t))&&(Lu(n,0,t),is(n,e,t))}function Zd(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function eh(e,t){Zd(e,t),(e=e.alternate)&&Zd(e,t)}function th(e){if(13===e.tag){var t=_r(e,67108864);null!==t&&Lu(t,0,67108864),eh(e,67108864)}}var nh=!0;function rh(e,t,n,r){var a=D.T;D.T=null;var s=O.p;try{O.p=2,sh(e,t,n,r)}finally{O.p=s,D.T=a}}function ah(e,t,n,r){var a=D.T;D.T=null;var s=O.p;try{O.p=8,sh(e,t,n,r)}finally{O.p=s,D.T=a}}function sh(e,t,n,r){if(nh){var a=ih(r);if(null===a)Uc(e,t,r,oh,n),yh(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return dh=xh(dh,e,t,n,r,a),!0;case"dragenter":return hh=xh(hh,e,t,n,r,a),!0;case"mouseover":return ph=xh(ph,e,t,n,r,a),!0;case"pointerover":var s=a.pointerId;return fh.set(s,xh(fh.get(s)||null,e,t,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,mh.set(s,xh(mh.get(s)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(yh(e,r),4&t&&-1<bh.indexOf(e)){for(;null!==a;){var s=Ue(a);if(null!==s)switch(s.tag){case 3:if((s=s.stateNode).current.memoizedState.isDehydrated){var i=ye(s.pendingLanes);if(0!==i){var o=s;for(o.pendingLanes|=2,o.entangledLanes|=2;i;){var l=1<<31-pe(i);o.entanglements[1]|=l,i&=~l}kc(s),0===(6&nu)&&(ku=te()+500,Sc(0,!1))}}break;case 13:null!==(o=_r(s,2))&&Lu(o,0,2),Wu(),eh(s,2)}if(null===(s=ih(r))&&Uc(e,t,r,oh,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else Uc(e,t,r,null,n)}}function ih(e){return lh(e=_t(e))}var oh=null;function lh(e){if(oh=null,null!==(e=We(e))){var t=l(e);if(null===t)e=null;else{var n=t.tag;if(13===n){if(null!==(e=u(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return oh=e,null}function uh(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ne()){case re:return 2;case ae:return 8;case se:case ie:return 32;case oe:return 268435456;default:return 32}default:return 32}}var ch=!1,dh=null,hh=null,ph=null,fh=new Map,mh=new Map,gh=[],bh="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function yh(e,t){switch(e){case"focusin":case"focusout":dh=null;break;case"dragenter":case"dragleave":hh=null;break;case"mouseover":case"mouseout":ph=null;break;case"pointerover":case"pointerout":fh.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":mh.delete(t.pointerId)}}function xh(e,t,n,r,a,s){return null===e||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==t&&(null!==(t=Ue(t))&&th(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function vh(e){var t=We(e.target);if(null!==t){var n=l(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=u(n)))return e.blockedOn=t,void function(e,t){var n=O.p;try{return O.p=e,t()}finally{O.p=n}}(e.priority,(function(){if(13===n.tag){var e=Du();e=Ee(e);var t=_r(n,e);null!==t&&Lu(t,0,e),eh(n,e)}}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function wh(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=ih(e.nativeEvent);if(null!==n)return null!==(t=Ue(n))&&th(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);Rt=r,n.target.dispatchEvent(r),Rt=null,t.shift()}return!0}function kh(e,t,n){wh(e)&&n.delete(t)}function Sh(){ch=!1,null!==dh&&wh(dh)&&(dh=null),null!==hh&&wh(hh)&&(hh=null),null!==ph&&wh(ph)&&(ph=null),fh.forEach(kh),mh.forEach(kh)}function Ih(e,t){e.blockedOn===t&&(e.blockedOn=null,ch||(ch=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Sh)))}var Nh=null;function Ch(e){Nh!==e&&(Nh=e,r.unstable_scheduleCallback(r.unstable_NormalPriority,(function(){Nh===e&&(Nh=null);for(var t=0;t<e.length;t+=3){var n=e[t],r=e[t+1],a=e[t+2];if("function"!==typeof r){if(null===lh(r||n))continue;break}var s=Ue(n);null!==s&&(e.splice(t,3),t-=3,Ri(s,{pending:!0,data:a,method:n.method,action:r},r,a))}})))}function Th(e){function t(t){return Ih(t,e)}null!==dh&&Ih(dh,e),null!==hh&&Ih(hh,e),null!==ph&&Ih(ph,e),fh.forEach(t),mh.forEach(t);for(var n=0;n<gh.length;n++){var r=gh[n];r.blockedOn===e&&(r.blockedOn=null)}for(;0<gh.length&&null===(n=gh[0]).blockedOn;)vh(n),null===n.blockedOn&&gh.shift();if(null!=(n=(e.ownerDocument||e).$$reactFormReplay))for(r=0;r<n.length;r+=3){var a=n[r],s=n[r+1],i=a[Fe]||null;if("function"===typeof s)i||Ch(n);else if(i){var o=null;if(s&&s.hasAttribute("formAction")){if(a=s,i=s[Fe]||null)o=i.formAction;else if(null!==lh(a))continue}else o=i.action;"function"===typeof o?n[r+1]=o:(n.splice(r,3),r-=3),Ch(n)}}}function Eh(e){this._internalRoot=e}function $h(e){this._internalRoot=e}$h.prototype.render=Eh.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(i(409));Jd(t.current,Du(),e,t,null,null)},$h.prototype.unmount=Eh.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;Jd(e.current,2,null,e,null,null),Wu(),t[De]=null}},$h.prototype.unstable_scheduleHydration=function(e){if(e){var t=Re();e={blockedOn:null,target:e,priority:t};for(var n=0;n<gh.length&&0!==t&&t<gh[n].priority;n++);gh.splice(n,0,e),0===n&&vh(e)}};var Rh=a.version;if("19.1.0"!==Rh)throw Error(i(527,Rh,"19.1.0"));O.findDOMNode=function(e){var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw e=Object.keys(e).join(","),Error(i(268,e))}return e=function(e){var t=e.alternate;if(!t){if(null===(t=l(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var s=a.alternate;if(null===s){if(null!==(r=a.return)){n=r;continue}break}if(a.child===s.child){for(s=a.child;s;){if(s===n)return c(a),e;if(s===r)return c(a),t;s=s.sibling}throw Error(i(188))}if(n.return!==r.return)n=a,r=s;else{for(var o=!1,u=a.child;u;){if(u===n){o=!0,n=a,r=s;break}if(u===r){o=!0,r=a,n=s;break}u=u.sibling}if(!o){for(u=s.child;u;){if(u===n){o=!0,n=s,r=a;break}if(u===r){o=!0,r=s,n=a;break}u=u.sibling}if(!o)throw Error(i(189))}}if(n.alternate!==r)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(t),e=null===(e=null!==e?d(e):null)?null:e.stateNode};var _h={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:D,reconcilerVersion:"19.1.0"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var Ah=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Ah.isDisabled&&Ah.supportsFiber)try{ce=Ah.inject(_h),de=Ah}catch(Dh){}}t.createRoot=function(e,t){if(!o(e))throw Error(i(299));var n=!1,r="",a=yo,s=xo,l=vo;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onUncaughtError&&(a=t.onUncaughtError),void 0!==t.onCaughtError&&(s=t.onCaughtError),void 0!==t.onRecoverableError&&(l=t.onRecoverableError),void 0!==t.unstable_transitionCallbacks&&t.unstable_transitionCallbacks),t=Yd(e,1,!1,null,0,n,r,a,s,l,0,null),e[De]=t.current,Bc(e),new Eh(t)},t.hydrateRoot=function(e,t,n){if(!o(e))throw Error(i(299));var r=!1,a="",s=yo,l=xo,u=vo,c=null;return null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onUncaughtError&&(s=n.onUncaughtError),void 0!==n.onCaughtError&&(l=n.onCaughtError),void 0!==n.onRecoverableError&&(u=n.onRecoverableError),void 0!==n.unstable_transitionCallbacks&&n.unstable_transitionCallbacks,void 0!==n.formState&&(c=n.formState)),(t=Yd(e,1,!0,t,0,r,a,s,l,u,0,c)).context=Qd(null),n=t.current,(a=as(r=Ee(r=Du()))).callback=null,ss(n,a,r),n=r,t.current.lanes=n,Ne(t,n),kc(t),e[De]=t.current,Bc(e),new $h(t)},t.version="19.1.0"},16:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},43:(e,t,n)=>{"use strict";e.exports=n(288)},66:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},108:()=>{},234:()=>{},262:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},288:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.consumer"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function b(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function y(){}function x(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var v=x.prototype=new y;v.constructor=x,m(v,b.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k={H:null,A:null,T:null,S:null,V:null},S=Object.prototype.hasOwnProperty;function I(e,t,r,a,s,i){return r=i.ref,{$$typeof:n,type:e,key:t,ref:void 0!==r?r:null,props:i}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var C=/\/+/g;function T(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function E(){}function $(e,t,a,s,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l,u,c=!1;if(null===e)c=!0;else switch(o){case"bigint":case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case r:c=!0;break;case h:return $((c=e._init)(e._payload),t,a,s,i)}}if(c)return i=i(e),c=""===s?"."+T(e,0):s,w(i)?(a="",null!=c&&(a=c.replace(C,"$&/")+"/"),$(i,t,a,"",(function(e){return e}))):null!=i&&(N(i)&&(l=i,u=a+(null==i.key||e&&e.key===i.key?"":(""+i.key).replace(C,"$&/")+"/")+c,i=I(l.type,u,void 0,0,0,l.props)),t.push(i)),1;c=0;var d,f=""===s?".":s+":";if(w(e))for(var m=0;m<e.length;m++)c+=$(s=e[m],t,a,o=f+T(s,m),i);else if("function"===typeof(m=null===(d=e)||"object"!==typeof d?null:"function"===typeof(d=p&&d[p]||d["@@iterator"])?d:null))for(e=m.call(e),m=0;!(s=e.next()).done;)c+=$(s=s.value,t,a,o=f+T(s,m++),i);else if("object"===o){if("function"===typeof e.then)return $(function(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch("string"===typeof e.status?e.then(E,E):(e.status="pending",e.then((function(t){"pending"===e.status&&(e.status="fulfilled",e.value=t)}),(function(t){"pending"===e.status&&(e.status="rejected",e.reason=t)}))),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}(e),t,a,s,i);throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return c}function R(e,t,n){if(null==e)return e;var r=[],a=0;return $(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function _(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var A="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function F(){}t.Children={map:R,forEach:function(e,t,n){R(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return R(e,(function(){t++})),t},toArray:function(e){return R(e,(function(e){return e}))||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=a,t.Profiler=i,t.PureComponent=x,t.StrictMode=s,t.Suspense=c,t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,t.__COMPILER_RUNTIME={__proto__:null,c:function(e){return k.H.useMemoCache(e)}},t.cache=function(e){return function(){return e.apply(null,arguments)}},t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error("The argument must be a React element, but you passed "+e+".");var r=m({},e.props),a=e.key;if(null!=t)for(s in void 0!==t.ref&&void 0,void 0!==t.key&&(a=""+t.key),t)!S.call(t,s)||"key"===s||"__self"===s||"__source"===s||"ref"===s&&void 0===t.ref||(r[s]=t[s]);var s=arguments.length-2;if(1===s)r.children=n;else if(1<s){for(var i=Array(s),o=0;o<s;o++)i[o]=arguments[o+2];r.children=i}return I(e.type,a,void 0,0,0,r)},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider=e,e.Consumer={$$typeof:o,_context:e},e},t.createElement=function(e,t,n){var r,a={},s=null;if(null!=t)for(r in void 0!==t.key&&(s=""+t.key),t)S.call(t,r)&&"key"!==r&&"__self"!==r&&"__source"!==r&&(a[r]=t[r]);var i=arguments.length-2;if(1===i)a.children=n;else if(1<i){for(var o=Array(i),l=0;l<i;l++)o[l]=arguments[l+2];a.children=o}if(e&&e.defaultProps)for(r in i=e.defaultProps)void 0===a[r]&&(a[r]=i[r]);return I(e,s,void 0,0,0,a)},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:_}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=k.T,n={};k.T=n;try{var r=e(),a=k.S;null!==a&&a(n,r),"object"===typeof r&&null!==r&&"function"===typeof r.then&&r.then(F,A)}catch(s){A(s)}finally{k.T=t}},t.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},t.use=function(e){return k.H.use(e)},t.useActionState=function(e,t,n){return k.H.useActionState(e,t,n)},t.useCallback=function(e,t){return k.H.useCallback(e,t)},t.useContext=function(e){return k.H.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e,t){return k.H.useDeferredValue(e,t)},t.useEffect=function(e,t,n){var r=k.H;if("function"===typeof n)throw Error("useEffect CRUD overload is not enabled in this build of React.");return r.useEffect(e,t)},t.useId=function(){return k.H.useId()},t.useImperativeHandle=function(e,t,n){return k.H.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return k.H.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return k.H.useLayoutEffect(e,t)},t.useMemo=function(e,t){return k.H.useMemo(e,t)},t.useOptimistic=function(e,t){return k.H.useOptimistic(e,t)},t.useReducer=function(e,t,n){return k.H.useReducer(e,t,n)},t.useRef=function(e){return k.H.useRef(e)},t.useState=function(e){return k.H.useState(e)},t.useSyncExternalStore=function(e,t,n){return k.H.useSyncExternalStore(e,t,n)},t.useTransition=function(){return k.H.useTransition()},t.version="19.1.0"},334:(e,t,n)=>{var r=n(359),a=n(66),s=n(16),i=n(538),o=n(907),l=n(262),u=n(430);u.alea=r,u.xor128=a,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(s[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=l(e,e<0?-1:0,!1),i&&(a[e]=n),n)}function o(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=o(u(n,8)),s=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));s=s.mul(h).add(o(d))}else s=(s=s.mul(a)).add(o(d))}return s.unsigned=t,s}function d(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var b=i(0,!0);n.UZERO=b;var y=i(1);n.ONE=y;var x=i(1,!0);n.UONE=x;var v=i(-1);n.NEG_ONE=v;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=o(u(e,6),this.unsigned),s=this,i="";;){var l=s.div(a),c=(s.sub(l.mul(a)).toInt()>>>0).toString(e);if((s=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(y)},I.neg=I.negate,I.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,h+=(p+=a+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,x=0;return y+=(x+=i*p)>>>16,b+=(y+=s*p)>>>16,y&=65535,b+=(y+=i*h)>>>16,f+=(b+=a*p)>>>16,b&=65535,f+=(b+=s*h)>>>16,b&=65535,f+=(b+=i*c)>>>16,f+=n*p+a*h+s*c+i*u,l((y&=65535)<<16|(x&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,a,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;s=b}else{if(this.eq(S))return e.eq(y)||e.eq(v)?S:e.eq(S)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:v:(a=this.sub(e.mul(n)),s=n.add(a.div(e)));if(e.eq(S))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(a);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=y),s=s.add(h),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},358:(e,t)=>{"use strict";const n=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,r=/^[\u0021-\u003A\u003C-\u007E]*$/,a=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,s=/^[\u0020-\u003A\u003D-\u007E]*$/,i=Object.prototype.toString,o=(()=>{const e=function(){};return e.prototype=Object.create(null),e})();function l(e,t,n){do{const n=e.charCodeAt(t);if(32!==n&&9!==n)return t}while(++t<n);return n}function u(e,t,n){for(;t>n;){const n=e.charCodeAt(--t);if(32!==n&&9!==n)return t+1}return n}function c(e){if(-1===e.indexOf("%"))return e;try{return decodeURIComponent(e)}catch(t){return e}}},359:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new s(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},391:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(4)},430:function(e,t,n){var r;!function(a,s,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=255;function p(e,t,n){var r=[],h=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(s)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(e)),y(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,y(s)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,b(y(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(x,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<l;)i[a]=a++;for(a=0;a<l;a++)i[a]=i[s=h&s+e[a%n]+(t=i[a])],i[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,i=r.S;e--;)t=i[a=h&a+1],n=n*l+i[h&(i[a]=i[s=h&s+t])+(i[s]=t)];return r.i=a,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(g(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function b(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(b(i.random(),s),e.exports){e.exports=p;try{o=n(234)}catch(x){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},530:()=>{},538:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},551:()=>{},579:(e,t,n)=>{"use strict";e.exports=n(799)},590:()=>{},672:(e,t,n)=>{"use strict";var r=n(43);function a(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function s(){}var i={d:{f:s,r:function(){throw Error(a(522))},D:s,C:s,L:s,m:s,X:s,S:s,M:s},p:0,findDOMNode:null},o=Symbol.for("react.portal");var l=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function u(e,t){return"font"===e?"":"string"===typeof t?"use-credentials"===t?t:"":void 0}t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)throw Error(a(299));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:o,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.flushSync=function(e){var t=l.T,n=i.p;try{if(l.T=null,i.p=2,e)return e()}finally{l.T=t,i.p=n,i.d.f()}},t.preconnect=function(e,t){"string"===typeof e&&(t?t="string"===typeof(t=t.crossOrigin)?"use-credentials"===t?t:"":void 0:t=null,i.d.C(e,t))},t.prefetchDNS=function(e){"string"===typeof e&&i.d.D(e)},t.preinit=function(e,t){if("string"===typeof e&&t&&"string"===typeof t.as){var n=t.as,r=u(n,t.crossOrigin),a="string"===typeof t.integrity?t.integrity:void 0,s="string"===typeof t.fetchPriority?t.fetchPriority:void 0;"style"===n?i.d.S(e,"string"===typeof t.precedence?t.precedence:void 0,{crossOrigin:r,integrity:a,fetchPriority:s}):"script"===n&&i.d.X(e,{crossOrigin:r,integrity:a,fetchPriority:s,nonce:"string"===typeof t.nonce?t.nonce:void 0})}},t.preinitModule=function(e,t){if("string"===typeof e)if("object"===typeof t&&null!==t){if(null==t.as||"script"===t.as){var n=u(t.as,t.crossOrigin);i.d.M(e,{crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0})}}else null==t&&i.d.M(e)},t.preload=function(e,t){if("string"===typeof e&&"object"===typeof t&&null!==t&&"string"===typeof t.as){var n=t.as,r=u(n,t.crossOrigin);i.d.L(e,n,{crossOrigin:r,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0,type:"string"===typeof t.type?t.type:void 0,fetchPriority:"string"===typeof t.fetchPriority?t.fetchPriority:void 0,referrerPolicy:"string"===typeof t.referrerPolicy?t.referrerPolicy:void 0,imageSrcSet:"string"===typeof t.imageSrcSet?t.imageSrcSet:void 0,imageSizes:"string"===typeof t.imageSizes?t.imageSizes:void 0,media:"string"===typeof t.media?t.media:void 0})}},t.preloadModule=function(e,t){if("string"===typeof e)if(t){var n=u(t.as,t.crossOrigin);i.d.m(e,{as:"string"===typeof t.as&&"script"!==t.as?t.as:void 0,crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0})}else i.d.m(e)},t.requestFormReset=function(e){i.d.r(e)},t.unstable_batchedUpdates=function(e,t){return e(t)},t.useFormState=function(e,t,n){return l.H.useFormState(e,t,n)},t.useFormStatus=function(){return l.H.useHostTransitionStatus()},t.version="19.1.0"},799:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.fragment");function a(e,t,r){var a=null;if(void 0!==r&&(a=""+r),void 0!==t.key&&(a=""+t.key),"key"in t)for(var s in r={},t)"key"!==s&&(r[s]=t[s]);else r=t;return t=r.ref,{$$typeof:n,type:e,key:a,ref:void 0!==t?t:null,props:r}}t.Fragment=r,t.jsx=a,t.jsxs=a},817:()=>{},853:(e,t,n)=>{"use strict";e.exports=n(896)},896:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<s(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>s(l,n))u<a&&0>s(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<a&&0>s(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if(t.unstable_now=void 0,"object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,b=!1,y="function"===typeof setTimeout?setTimeout:null,x="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function w(e){for(var t=r(c);null!==t;){if(null===t.callback)a(c);else{if(!(t.startTime<=e))break;a(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function k(e){if(g=!1,w(e),!m)if(null!==r(u))m=!0,I||(I=!0,S());else{var t=r(c);null!==t&&A(k,t.startTime-e)}}var S,I=!1,N=-1,C=5,T=-1;function E(){return!!b||!(t.unstable_now()-T<C)}function $(){if(b=!1,I){var e=t.unstable_now();T=e;var n=!0;try{e:{m=!1,g&&(g=!1,x(N),N=-1),f=!0;var s=p;try{t:{for(w(e),h=r(u);null!==h&&!(h.expirationTime>e&&E());){var i=h.callback;if("function"===typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=e);if(e=t.unstable_now(),"function"===typeof o){h.callback=o,w(e),n=!0;break t}h===r(u)&&a(u),w(e)}else a(u);h=r(u)}if(null!==h)n=!0;else{var l=r(c);null!==l&&A(k,l.startTime-e),n=!1}}break e}finally{h=null,p=s,f=!1}n=void 0}}finally{n?S():I=!1}}}if("function"===typeof v)S=function(){v($)};else if("undefined"!==typeof MessageChannel){var R=new MessageChannel,_=R.port2;R.port1.onmessage=$,S=function(){_.postMessage(null)}}else S=function(){y($,0)};function A(e,n){N=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_requestPaint=function(){b=!0},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,a,s){var i=t.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?i+s:i:s=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:a,priorityLevel:e,startTime:s,expirationTime:o=s+o,sortIndex:-1},s>i?(e.sortIndex=s,n(c,e),null===r(u)&&e===r(c)&&(g?(x(N),N=-1):g=!0,A(k,s-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,I||(I=!0,S()))),e},t.unstable_shouldYield=E,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},907:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(672)}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,r)=>(n.f[r](e,t),t)),[])),n.u=e=>"static/js/"+e+".de0a5969.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="academix:";n.l=(r,a,s,i)=>{if(e[r])e[r].push(a);else{var o,l;if(void 0!==s)for(var u=document.getElementsByTagName("script"),c=0;c<u.length;c++){var d=u[c];if(d.getAttribute("src")==r||d.getAttribute("data-webpack")==t+s){o=d;break}}o||(l=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,n.nc&&o.setAttribute("nonce",n.nc),o.setAttribute("data-webpack",t+s),o.src=r),e[r]=[a];var h=(t,n)=>{o.onerror=o.onload=null,clearTimeout(p);var a=e[r];if(delete e[r],o.parentNode&&o.parentNode.removeChild(o),a&&a.forEach((e=>e(n))),t)return t(n)},p=setTimeout(h.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=h.bind(null,o.onerror),o.onload=h.bind(null,o.onload),l&&document.head.appendChild(o)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/",(()=>{var e={792:0};n.f.j=(t,r)=>{var a=n.o(e,t)?e[t]:void 0;if(0!==a)if(a)r.push(a[2]);else{var s=new Promise(((n,r)=>a=e[t]=[n,r]));r.push(a[2]=s);var i=n.p+n.u(t),o=new Error;n.l(i,(r=>{if(n.o(e,t)&&(0!==(a=e[t])&&(e[t]=void 0),a)){var s=r&&("load"===r.type?"missing":r.type),i=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+s+": "+i+")",o.name="ChunkLoadError",o.type=s,o.request=i,a[1](o)}}),"chunk-"+t,t)}};var t=(t,r)=>{var a,s,i=r[0],o=r[1],l=r[2],u=0;if(i.some((t=>0!==e[t]))){for(a in o)n.o(o,a)&&(n.m[a]=o[a]);if(l)l(n)}for(t&&t(r);u<i.length;u++)s=i[u],n.o(e,s)&&e[s]&&e[s][0](),e[s]=0},r=self.webpackChunkacademix=self.webpackChunkacademix||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{hasBrowserEnv:()=>xn,hasStandardBrowserEnv:()=>wn,hasStandardBrowserWebWorkerEnv:()=>kn,navigator:()=>vn,origin:()=>Sn});var t={};n.r(t),n.d(t,{assertParamsValid:()=>Vc,computeFlatOffset:()=>rd,computeOutShape:()=>Hc,getNormalizedAxes:()=>Yc,isSliceContinous:()=>nd,maskToAxes:()=>Gc,parseSliceParams:()=>ad,sliceInfo:()=>sd,startForAxis:()=>ed,startIndicesWithElidedDims:()=>Qc,stopForAxis:()=>td,stopIndicesWithElidedDims:()=>Jc,stridesForAxis:()=>Zc,stridesWithElidedDims:()=>qc});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>Im,computeOutShape:()=>Sm,segOpComputeOptimalWindowSize:()=>km});var a={};n.r(a),n.d(a,{ERF_A1:()=>Bf,ERF_A2:()=>Wf,ERF_A3:()=>Uf,ERF_A4:()=>jf,ERF_A5:()=>Vf,ERF_P:()=>Pf,PARALLELIZE_THRESHOLD:()=>Nf,RowPartitionType:()=>vf,SELU_SCALE:()=>zf,SELU_SCALEALPHA:()=>Mf,applyActivation:()=>Ip,assertAndGetBroadcastShape:()=>Tc,assertAxesAreInnerMostDims:()=>mh,assertParamsConsistent:()=>yf,assignToTypedArray:()=>Yf,axesAreInnerMostDims:()=>dh,calculateShapes:()=>Lf,checkEinsumDimSizes:()=>sm,checkPadOnDimRoundingMode:()=>Id,combineLocations:()=>hh,combineRaggedTensorToTensorShapes:()=>wf,complexWithEvenIndex:()=>qf,complexWithOddIndex:()=>Kf,computeConv2DInfo:()=>pd,computeConv3DInfo:()=>fd,computeDefaultPad:()=>md,computeDilation2DInfo:()=>cd,computeOptimalWindowSize:()=>Cf,computeOutAndReduceShapes:()=>ph,computeOutShape:()=>xf,computePool2DInfo:()=>dd,computePool3DInfo:()=>hd,convertConv2DDataFormat:()=>Sd,decodeEinsumEquation:()=>rm,eitherStridesOrDilationsAreOne:()=>wd,expandShapeToKeepDim:()=>fh,exponent:()=>Jf,exponents:()=>Qf,fromStringArrayToUint8:()=>Cm,fromUint8ToStringArray:()=>Nm,getAxesPermutation:()=>gh,getBroadcastDims:()=>Nc,getComplexWithIndex:()=>Xf,getEinsumComputePath:()=>im,getEinsumPermutation:()=>am,getFusedBiasGradient:()=>Sp,getFusedDyActivation:()=>kp,getImageCenter:()=>Tf,getInnerMostAxes:()=>yh,getPermuted:()=>$f,getRaggedRank:()=>Sf,getReductionAxes:()=>Cc,getReshaped:()=>Ef,getReshapedPermuted:()=>Rf,getRowPartitionTypesHelper:()=>kf,getSliceBeginCoords:()=>_f,getSliceSize:()=>Af,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>cm,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>dm,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>hm,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>mm,getSparseReshapeInputOutputMismatchErrorMessage:()=>bm,getSparseReshapeInputOutputMultipleErrorMessage:()=>gm,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>pm,getSparseReshapeNegativeOutputDimErrorMessage:()=>fm,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>wm,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ym,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>xm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>vm,getUndoAxesPermutation:()=>bh,isIdentityPermutation:()=>om,log:()=>Po,mergeRealAndImagArrays:()=>Gf,prepareAndValidate:()=>Ff,prepareSplitSize:()=>um,segment_util:()=>r,shouldFuse:()=>Np,slice_util:()=>t,splitRealAndImagArrays:()=>Hf,stridesOrDilationsArePositive:()=>kd,tupleValuesAreOne:()=>vd,upcastType:()=>Ml,validateDefaultValueShape:()=>If,validateInput:()=>Of,validateUpdateShape:()=>Df,warn:()=>zo});var s={};n.r(s),n.d(s,{mx:()=>mN,XI:()=>oC,Nk:()=>lC,f6:()=>cC,ct:()=>cN,YG:()=>pC,hH:()=>xC,z3:()=>rT,sG:()=>fT,uM:()=>xT,vS:()=>LT,qB:()=>VT,GG:()=>HT,lg:()=>QT,rq:()=>KT,cu:()=>cE,WR:()=>oE,GE:()=>pE,px:()=>mE,jC:()=>RE,He:()=>FE,hE:()=>jE,BF:()=>XC,Dk:()=>ZE,cl:()=>o$,_B:()=>v$,ub:()=>N$,_f:()=>E$,Ku:()=>D$,qy:()=>L$,Zy:()=>K$,bu:()=>Q$,zv:()=>tN,dH:()=>IN,HS:()=>rC,yH:()=>bR,l3:()=>xR,z9:()=>wR,x6:()=>CR,_m:()=>FR,eW:()=>zR,GK:()=>WR,SP:()=>VR,yr:()=>HR,dl:()=>NT,Dw:()=>JR,xT:()=>n_,_X:()=>_N,wz:()=>u_});var i=n(43),o=n(391),l=(n(358),"popstate");function u(){return g((function(e,t){let{pathname:n,search:r,hash:a}=e.location;return p("",{pathname:n,search:r,hash:a},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:f(t)}),null,arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}function c(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function d(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function h(e,t){return{usr:e.state,key:e.key,idx:t}}function p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3?arguments[3]:void 0;return{pathname:"string"===typeof e?e:e.pathname,search:"",hash:"",..."string"===typeof t?m(t):t,state:n,key:t&&t.key||r||Math.random().toString(36).substring(2,10)}}function f(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function m(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substring(r),e=e.substring(0,r)),e&&(t.pathname=e)}return t}function g(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},{window:a=document.defaultView,v5Compat:s=!1}=r,i=a.history,o="POP",u=null,d=m();function m(){return(i.state||{idx:null}).idx}function g(){o="POP";let e=m(),t=null==e?null:e-d;d=e,u&&u({action:o,location:y.location,delta:t})}function b(e){let t="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof e?e:f(e);return n=n.replace(/ $/,"%20"),c(t,`No window.location.(origin|href) available to create URL for href: ${n}`),new URL(n,t)}null==d&&(d=0,i.replaceState({...i.state,idx:d},""));let y={get action(){return o},get location(){return e(a,i)},listen(e){if(u)throw new Error("A history only accepts one active listener");return a.addEventListener(l,g),u=e,()=>{a.removeEventListener(l,g),u=null}},createHref:e=>t(a,e),createURL:b,encodeLocation(e){let t=b(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o="PUSH";let r=p(y.location,e,t);n&&n(r,e),d=m()+1;let l=h(r,d),c=y.createHref(r);try{i.pushState(l,"",c)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;a.location.assign(c)}s&&u&&u({action:o,location:y.location,delta:1})},replace:function(e,t){o="REPLACE";let r=p(y.location,e,t);n&&n(r,e),d=m();let a=h(r,d),l=y.createHref(r);i.replaceState(a,"",l),s&&u&&u({action:o,location:y.location,delta:0})},go:e=>i.go(e)};return y}new WeakMap;function b(e,t){return y(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/",!1)}function y(e,t,n,r){let a=F(("string"===typeof t?m(t):t).pathname||"/",n);if(null==a)return null;let s=x(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(s);let i=null;for(let o=0;null==i&&o<s.length;++o){let e=A(a);i=$(s[o],e,r)}return i}function x(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",a=(e,a,s)=>{let i={relativePath:void 0===s?e.path||"":s,caseSensitive:!0===e.caseSensitive,childrenIndex:a,route:e};i.relativePath.startsWith("/")&&(c(i.relativePath.startsWith(r),`Absolute route path "${i.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),i.relativePath=i.relativePath.slice(r.length));let o=z([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(c(!0!==e.index,`Index routes must not have child routes. Please remove all child routes from route path "${o}".`),x(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:E(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{if(""!==e.path&&e.path?.includes("?"))for(let n of v(e.path))a(e,t,n);else a(e,t)})),t}function v(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let i=v(r.join("/")),o=[];return o.push(...i.map((e=>""===e?s:[s,e].join("/")))),a&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}var w=/^:[\w-]+$/,k=3,S=2,I=1,N=10,C=-2,T=e=>"*"===e;function E(e,t){let n=e.split("/"),r=n.length;return n.some(T)&&(r+=C),t&&(r+=S),n.filter((e=>!T(e))).reduce(((e,t)=>e+(w.test(t)?k:""===t?I:N)),r)}function $(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{routesMeta:r}=e,a={},s="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===s?t:t.slice(s.length)||"/",c=R({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),d=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=R({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(a,c.params),i.push({params:a,pathname:z([s,c.pathname]),pathnameBase:P(z([s,c.pathnameBase])),route:d}),"/"!==c.pathnameBase&&(s=z([s,c.pathnameBase]))}return i}function R(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=_(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let s=a[0],i=s.replace(/(.)\/+$/,"$1"),o=a.slice(1);return{params:r.reduce(((e,t,n)=>{let{paramName:r,isOptional:a}=t;if("*"===r){let e=o[n]||"";i=s.slice(0,s.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:s,pathnameBase:i,pattern:e}}function _(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];d("*"===e||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));return e.endsWith("*")?(r.push({paramName:"*"}),a+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==e&&"/"!==e&&(a+="(?:(?=\\/|$))"),[new RegExp(a,t?void 0:"i"),r]}function A(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return d(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),e}}function F(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function D(e,t,n,r){return`Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function O(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function L(e){let t=O(e);return t.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase))}function M(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];"string"===typeof e?r=m(e):(r={...e},c(!r.pathname||!r.pathname.includes("?"),D("?","pathname","search",r)),c(!r.pathname||!r.pathname.includes("#"),D("#","pathname","hash",r)),c(!r.search||!r.search.includes("#"),D("#","search","hash",r)));let s,i=""===e||""===r.pathname,o=i?"/":r.pathname;if(null==o)s=n;else{let e=t.length-1;if(!a&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;r.pathname=t.join("/")}s=e>=0?t[e]:"/"}let l=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"/",{pathname:n,search:r="",hash:a=""}="string"===typeof e?m(e):e,s=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:s,search:B(r),hash:W(a)}}(r,s),u=o&&"/"!==o&&o.endsWith("/"),d=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!d||(l.pathname+="/"),l}var z=e=>e.join("/").replace(/\/\/+/g,"/"),P=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),B=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",W=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";function U(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}var j=["POST","PUT","PATCH","DELETE"],V=(new Set(j),["GET",...j]);new Set(V),Symbol("ResetLoaderData");var G=i.createContext(null);G.displayName="DataRouter";var H=i.createContext(null);H.displayName="DataRouterState";var q=i.createContext({isTransitioning:!1});q.displayName="ViewTransition";var K=i.createContext(new Map);K.displayName="Fetchers";var X=i.createContext(null);X.displayName="Await";var Y=i.createContext(null);Y.displayName="Navigation";var Q=i.createContext(null);Q.displayName="Location";var J=i.createContext({outlet:null,matches:[],isDataRoute:!1});J.displayName="Route";var Z=i.createContext(null);Z.displayName="RouteError";function ee(){return null!=i.useContext(Q)}function te(){return c(ee(),"useLocation() may be used only in the context of a <Router> component."),i.useContext(Q).location}var ne="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function re(e){i.useContext(Y).static||i.useLayoutEffect(e)}function ae(){let{isDataRoute:e}=i.useContext(J);return e?function(){let{router:e}=pe("useNavigate"),t=me("useNavigate"),n=i.useRef(!1);re((()=>{n.current=!0}));let r=i.useCallback((async function(r){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};d(n.current,ne),n.current&&("number"===typeof r?e.navigate(r):await e.navigate(r,{fromRouteId:t,...a}))}),[e,t]);return r}():function(){c(ee(),"useNavigate() may be used only in the context of a <Router> component.");let e=i.useContext(G),{basename:t,navigator:n}=i.useContext(Y),{matches:r}=i.useContext(J),{pathname:a}=te(),s=JSON.stringify(L(r)),o=i.useRef(!1);re((()=>{o.current=!0}));let l=i.useCallback((function(r){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(d(o.current,ne),!o.current)return;if("number"===typeof r)return void n.go(r);let l=M(r,JSON.parse(s),a,"path"===i.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:z([t,l.pathname])),(i.replace?n.replace:n.push)(l,i.state,i)}),[t,n,s,a,e]);return l}()}i.createContext(null);function se(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{matches:n}=i.useContext(J),{pathname:r}=te(),a=JSON.stringify(L(n));return i.useMemo((()=>M(e,JSON.parse(a),r,"path"===t)),[e,a,r,t])}function ie(e,t,n,r){c(ee(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:a,static:s}=i.useContext(Y),{matches:o}=i.useContext(J),l=o[o.length-1],u=l?l.params:{},h=l?l.pathname:"/",p=l?l.pathnameBase:"/",f=l&&l.route;{let e=f&&f.path||"";ye(h,!f||e.endsWith("*")||e.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${h}" (under <Route path="${e}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="${e}"> to <Route path="${"/"===e?"*":`${e}/*`}">.`)}let g,y=te();if(t){let e="string"===typeof t?m(t):t;c("/"===p||e.pathname?.startsWith(p),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${p}" but pathname "${e.pathname}" was given in the \`location\` prop.`),g=e}else g=y;let x=g.pathname||"/",v=x;if("/"!==p){let e=p.replace(/^\//,"").split("/");v="/"+x.replace(/^\//,"").split("/").slice(e.length).join("/")}let w=!s&&n&&n.matches&&n.matches.length>0?n.matches:b(e,{pathname:v});d(f||null!=w,`No routes matched location "${g.pathname}${g.search}${g.hash}" `),d(null==w||void 0!==w[w.length-1].route.element||void 0!==w[w.length-1].route.Component||void 0!==w[w.length-1].route.lazy,`Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let k=de(w&&w.map((e=>Object.assign({},e,{params:Object.assign({},u,e.params),pathname:z([p,a.encodeLocation?a.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?p:z([p,a.encodeLocation?a.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),o,n,r);return t&&k?i.createElement(Q.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...g},navigationType:"POP"}},k):k}function oe(){let e=ge(),t=U(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r},s={padding:"2px 4px",backgroundColor:r},o=null;return console.error("Error handled by React Router default ErrorBoundary:",e),o=i.createElement(i.Fragment,null,i.createElement("p",null,"\ud83d\udcbf Hey developer \ud83d\udc4b"),i.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",i.createElement("code",{style:s},"ErrorBoundary")," or"," ",i.createElement("code",{style:s},"errorElement")," prop on your route.")),i.createElement(i.Fragment,null,i.createElement("h2",null,"Unexpected Application Error!"),i.createElement("h3",{style:{fontStyle:"italic"}},t),n?i.createElement("pre",{style:a},n):null,o)}var le=i.createElement(oe,null),ue=class extends i.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?i.createElement(J.Provider,{value:this.props.routeContext},i.createElement(Z.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function ce(e){let{routeContext:t,match:n,children:r}=e,a=i.useContext(G);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),i.createElement(J.Provider,{value:t},r)}function de(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(null==e){if(!n)return null;if(n.errors)e=n.matches;else{if(0!==t.length||n.initialized||!(n.matches.length>0))return null;e=n.matches}}let r=e,a=n?.errors;if(null!=a){let e=r.findIndex((e=>e.route.id&&void 0!==a?.[e.route.id]));c(e>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),r=r.slice(0,Math.min(r.length,e+1))}let s=!1,o=-1;if(n)for(let i=0;i<r.length;i++){let e=r[i];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(o=i),e.route.id){let{loaderData:t,errors:a}=n,i=e.route.loader&&!t.hasOwnProperty(e.route.id)&&(!a||void 0===a[e.route.id]);if(e.route.lazy||i){s=!0,r=o>=0?r.slice(0,o+1):[r[0]];break}}}return r.reduceRight(((e,l,u)=>{let c,d=!1,h=null,p=null;n&&(c=a&&l.route.id?a[l.route.id]:void 0,h=l.route.errorElement||le,s&&(o<0&&0===u?(ye("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),d=!0,p=null):o===u&&(d=!0,p=l.route.hydrateFallbackElement||null)));let f=t.concat(r.slice(0,u+1)),m=()=>{let t;return t=c?h:d?p:l.route.Component?i.createElement(l.route.Component,null):l.route.element?l.route.element:e,i.createElement(ce,{match:l,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(l.route.ErrorBoundary||l.route.errorElement||0===u)?i.createElement(ue,{location:n.location,revalidation:n.revalidation,component:h,error:c,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()}),null)}function he(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function pe(e){let t=i.useContext(G);return c(t,he(e)),t}function fe(e){let t=i.useContext(H);return c(t,he(e)),t}function me(e){let t=function(e){let t=i.useContext(J);return c(t,he(e)),t}(e),n=t.matches[t.matches.length-1];return c(n.route.id,`${e} can only be used on routes that contain a unique "id"`),n.route.id}function ge(){let e=i.useContext(Z),t=fe("useRouteError"),n=me("useRouteError");return void 0!==e?e:t.errors?.[n]}var be={};function ye(e,t,n){t||be[e]||(be[e]=!0,d(!1,n))}i.memo((function(e){let{routes:t,future:n,state:r}=e;return ie(t,void 0,r,n)}));function xe(e){c(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function ve(e){let{basename:t="/",children:n=null,location:r,navigationType:a="POP",navigator:s,static:o=!1}=e;c(!ee(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let l=t.replace(/^\/*/,"/"),u=i.useMemo((()=>({basename:l,navigator:s,static:o,future:{}})),[l,s,o]);"string"===typeof r&&(r=m(r));let{pathname:h="/",search:p="",hash:f="",state:g=null,key:b="default"}=r,y=i.useMemo((()=>{let e=F(h,l);return null==e?null:{location:{pathname:e,search:p,hash:f,state:g,key:b},navigationType:a}}),[l,h,p,f,g,b,a]);return d(null!=y,`<Router basename="${l}"> is not able to match the URL "${h}${p}${f}" because it does not start with the basename, so the <Router> won't render anything.`),null==y?null:i.createElement(Y.Provider,{value:u},i.createElement(Q.Provider,{children:n,value:y}))}function we(e){let{children:t,location:n}=e;return ie(ke(t),n)}i.Component;function ke(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=[];return i.Children.forEach(e,((e,r)=>{if(!i.isValidElement(e))return;let a=[...t,r];if(e.type===i.Fragment)return void n.push.apply(n,ke(e.props.children,a));c(e.type===xe,`[${"string"===typeof e.type?e.type:e.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),c(!e.props.index||!e.props.children,"An index route cannot have child routes.");let s={id:e.props.id||a.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,hydrateFallbackElement:e.props.hydrateFallbackElement,HydrateFallback:e.props.HydrateFallback,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:!0===e.props.hasErrorBoundary||null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(s.children=ke(e.props.children,a)),n.push(s)})),n}var Se="get",Ie="application/x-www-form-urlencoded";function Ne(e){return null!=e&&"string"===typeof e.tagName}var Ce=null;var Te=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function Ee(e){return null==e||Te.has(e)?e:(d(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Ie}"`),null)}function $e(e,t){let n,r,a,s,i;if(Ne(o=e)&&"form"===o.tagName.toLowerCase()){let i=e.getAttribute("action");r=i?F(i,t):null,n=e.getAttribute("method")||Se,a=Ee(e.getAttribute("enctype"))||Ie,s=new FormData(e)}else if(function(e){return Ne(e)&&"button"===e.tagName.toLowerCase()}(e)||function(e){return Ne(e)&&"input"===e.tagName.toLowerCase()}(e)&&("submit"===e.type||"image"===e.type)){let i=e.form;if(null==i)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let o=e.getAttribute("formaction")||i.getAttribute("action");if(r=o?F(o,t):null,n=e.getAttribute("formmethod")||i.getAttribute("method")||Se,a=Ee(e.getAttribute("formenctype"))||Ee(i.getAttribute("enctype"))||Ie,s=new FormData(i,e),!function(){if(null===Ce)try{new FormData(document.createElement("form"),0),Ce=!1}catch(e){Ce=!0}return Ce}()){let{name:t,type:n,value:r}=e;if("image"===n){let e=t?`${t}.`:"";s.append(`${e}x`,"0"),s.append(`${e}y`,"0")}else t&&s.append(t,r)}}else{if(Ne(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=Se,r=null,a=Ie,i=e}var o;return s&&"text/plain"===a&&(i=s,s=void 0),{action:r,method:n.toLowerCase(),encType:a,formData:s,body:i}}function Re(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}async function _e(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise((()=>{}))}}function Ae(e){return null!=e&&"string"===typeof e.page}function Fe(e){return null!=e&&(null==e.href?"preload"===e.rel&&"string"===typeof e.imageSrcSet&&"string"===typeof e.imageSizes:"string"===typeof e.rel&&"string"===typeof e.href)}function De(e,t,n,r,a,s){let i=(e,t)=>!n[t]||e.route.id!==n[t].route.id,o=(e,t)=>n[t].pathname!==e.pathname||n[t].route.path?.endsWith("*")&&n[t].params["*"]!==e.params["*"];return"assets"===s?t.filter(((e,t)=>i(e,t)||o(e,t))):"data"===s?t.filter(((t,s)=>{let l=r.routes[t.route.id];if(!l||!l.hasLoader)return!1;if(i(t,s)||o(t,s))return!0;if(t.route.shouldRevalidate){let r=t.route.shouldRevalidate({currentUrl:new URL(a.pathname+a.search+a.hash,window.origin),currentParams:n[0]?.params||{},nextUrl:new URL(e,window.origin),nextParams:t.params,defaultShouldRevalidate:!0});if("boolean"===typeof r)return r}return!0})):[]}function Oe(e,t){let{includeHydrateFallback:n}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r=e.map((e=>{let r=t.routes[e.route.id];if(!r)return[];let a=[r.module];return r.clientActionModule&&(a=a.concat(r.clientActionModule)),r.clientLoaderModule&&(a=a.concat(r.clientLoaderModule)),n&&r.hydrateFallbackModule&&(a=a.concat(r.hydrateFallbackModule)),r.imports&&(a=a.concat(r.imports)),a})).flat(1),[...new Set(r)];var r}function Le(e,t){let n=new Set,r=new Set(t);return e.reduce(((e,a)=>{if(t&&!Ae(a)&&"script"===a.as&&a.href&&r.has(a.href))return e;let s=JSON.stringify(function(e){let t={},n=Object.keys(e).sort();for(let r of n)t[r]=e[r];return t}(a));return n.has(s)||(n.add(s),e.push({key:s,link:a})),e}),[])}function Me(e){return{__html:e}}Symbol("SingleFetchRedirect");var ze=new Set([100,101,204,205]);function Pe(e,t){let n="string"===typeof e?new URL(e,"undefined"===typeof window?"server://singlefetch/":window.location.origin):e;return"/"===n.pathname?n.pathname="_root.data":t&&"/"===F(n.pathname,t)?n.pathname=`${t.replace(/\/$/,"")}/_root.data`:n.pathname=`${n.pathname.replace(/\/$/,"")}.data`,n}i.Component;function Be(e){let{error:t,isOutsideRemixApp:n}=e;console.error(t);let r,a=i.createElement("script",{dangerouslySetInnerHTML:{__html:'\n        console.log(\n          "\ud83d\udcbf Hey developer \ud83d\udc4b. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."\n        );\n      '}});if(U(t))return i.createElement(We,{title:"Unhandled Thrown Response!"},i.createElement("h1",{style:{fontSize:"24px"}},t.status," ",t.statusText),a);if(t instanceof Error)0;else{let e=null==t?"Unknown Error":"object"===typeof t&&"toString"in t?t.toString():JSON.stringify(t);new Error(e)}return i.createElement(We,{title:"Application Error!",isOutsideRemixApp:n},i.createElement("h1",{style:{fontSize:"24px"}},"Application Error"),i.createElement("pre",{style:{padding:"2rem",background:"hsla(10, 50%, 50%, 0.1)",color:"red",overflow:"auto"}},r.stack),a)}function We(e){let{title:t,renderScripts:n,isOutsideRemixApp:r,children:a}=e,{routeModules:s}=He();return s.root?.Layout&&!r?a:i.createElement("html",{lang:"en"},i.createElement("head",null,i.createElement("meta",{charSet:"utf-8"}),i.createElement("meta",{name:"viewport",content:"width=device-width,initial-scale=1,viewport-fit=cover"}),i.createElement("title",null,t)),i.createElement("body",null,i.createElement("main",{style:{fontFamily:"system-ui, sans-serif",padding:"2rem"}},a,n?i.createElement(Ze,null):null)))}function Ue(e){return!0===e}function je(){let e=i.useContext(G);return Re(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function Ve(){let e=i.useContext(H);return Re(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var Ge=i.createContext(void 0);function He(){let e=i.useContext(Ge);return Re(e,"You must render this element inside a <HydratedRouter> element"),e}function qe(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function Ke(e,t,n){if(n&&!Je)return[e[0]];if(t){let n=e.findIndex((e=>void 0!==t[e.route.id]));return e.slice(0,n+1)}return e}function Xe(e){let{page:t,...n}=e,{router:r}=je(),a=i.useMemo((()=>b(r.routes,t,r.basename)),[r.routes,t,r.basename]);return a?i.createElement(Qe,{page:t,matches:a,...n}):null}function Ye(e){let{manifest:t,routeModules:n}=He(),[r,a]=i.useState([]);return i.useEffect((()=>{let r=!1;return async function(e,t,n){let r=await Promise.all(e.map((async e=>{let r=t.routes[e.route.id];if(r){let e=await _e(r,n);return e.links?e.links():[]}return[]})));return Le(r.flat(1).filter(Fe).filter((e=>"stylesheet"===e.rel||"preload"===e.rel)).map((e=>"stylesheet"===e.rel?{...e,rel:"prefetch",as:"style"}:{...e,rel:"prefetch"})))}(e,t,n).then((e=>{r||a(e)})),()=>{r=!0}}),[e,t,n]),r}function Qe(e){let{page:t,matches:n,...r}=e,a=te(),{manifest:s,routeModules:o}=He(),{basename:l}=je(),{loaderData:u,matches:c}=Ve(),d=i.useMemo((()=>De(t,n,c,s,a,"data")),[t,n,c,s,a]),h=i.useMemo((()=>De(t,n,c,s,a,"assets")),[t,n,c,s,a]),p=i.useMemo((()=>{if(t===a.pathname+a.search+a.hash)return[];let e=new Set,r=!1;if(n.forEach((t=>{let n=s.routes[t.route.id];n&&n.hasLoader&&(!d.some((e=>e.route.id===t.route.id))&&t.route.id in u&&o[t.route.id]?.shouldRevalidate||n.hasClientLoader?r=!0:e.add(t.route.id))})),0===e.size)return[];let i=Pe(t,l);return r&&e.size>0&&i.searchParams.set("_routes",n.filter((t=>e.has(t.route.id))).map((e=>e.route.id)).join(",")),[i.pathname+i.search]}),[l,u,a,s,d,n,t,o]),f=i.useMemo((()=>Oe(h,s)),[h,s]),m=Ye(h);return i.createElement(i.Fragment,null,p.map((e=>i.createElement("link",{key:e,rel:"prefetch",as:"fetch",href:e,...r}))),f.map((e=>i.createElement("link",{key:e,rel:"modulepreload",href:e,...r}))),m.map((e=>{let{key:t,link:n}=e;return i.createElement("link",{key:t,...n})})))}Ge.displayName="FrameworkContext";var Je=!1;function Ze(e){let{manifest:t,serverHandoffString:n,isSpaMode:r,ssr:a,renderMeta:s}=He(),{router:o,static:l,staticContext:u}=je(),{matches:c}=Ve(),d=Ue(a);s&&(s.didRenderScripts=!0);let h=Ke(c,null,r);i.useEffect((()=>{0}),[]);let p=i.useMemo((()=>{let r=u?`window.__reactRouterContext = ${n};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());`:" ",a=l?`${t.hmr?.runtime?`import ${JSON.stringify(t.hmr.runtime)};`:""}${d?"":`import ${JSON.stringify(t.url)}`};\n${h.map(((e,n)=>{let r=`route${n}`,a=t.routes[e.route.id];Re(a,`Route ${e.route.id} not found in manifest`);let{clientActionModule:s,clientLoaderModule:i,clientMiddlewareModule:o,hydrateFallbackModule:l,module:u}=a,c=[...s?[{module:s,varName:`${r}_clientAction`}]:[],...i?[{module:i,varName:`${r}_clientLoader`}]:[],...o?[{module:o,varName:`${r}_clientMiddleware`}]:[],...l?[{module:l,varName:`${r}_HydrateFallback`}]:[],{module:u,varName:`${r}_main`}];return 1===c.length?`import * as ${r} from ${JSON.stringify(u)};`:[c.map((e=>`import * as ${e.varName} from "${e.module}";`)).join("\n"),`const ${r} = {${c.map((e=>`...${e.varName}`)).join(",")}};`].join("\n")})).join("\n")}\n  ${d?`window.__reactRouterManifest = ${JSON.stringify(function(e,t){let{sri:n,...r}=e,a=new Set(t.state.matches.map((e=>e.route.id))),s=t.state.location.pathname.split("/").filter(Boolean),i=["/"];for(s.pop();s.length>0;)i.push(`/${s.join("/")}`),s.pop();i.forEach((e=>{let n=b(t.routes,e,t.basename);n&&n.forEach((e=>a.add(e.route.id)))}));let o=[...a].reduce(((e,t)=>Object.assign(e,{[t]:r.routes[t]})),{});return{...r,routes:o,sri:!!n||void 0}}(t,o),null,2)};`:""}\n  window.__reactRouterRouteModules = {${h.map(((e,t)=>`${JSON.stringify(e.route.id)}:route${t}`)).join(",")}};\n\nimport(${JSON.stringify(t.entry.module)});`:" ";return i.createElement(i.Fragment,null,i.createElement("script",{...e,suppressHydrationWarning:!0,dangerouslySetInnerHTML:Me(r),type:void 0}),i.createElement("script",{...e,suppressHydrationWarning:!0,dangerouslySetInnerHTML:Me(a),type:"module",async:!0}))}),[]),f=Je?[]:function(e){return[...new Set(e)]}(t.entry.imports.concat(Oe(h,t,{includeHydrateFallback:!0}))),m="object"===typeof t.sri?t.sri:{};return Je?null:i.createElement(i.Fragment,null,"object"===typeof t.sri?i.createElement("script",{"rr-importmap":"",type:"importmap",suppressHydrationWarning:!0,dangerouslySetInnerHTML:{__html:JSON.stringify({integrity:m})}}):null,d?null:i.createElement("link",{rel:"modulepreload",href:t.url,crossOrigin:e.crossOrigin,integrity:m[t.url],suppressHydrationWarning:!0}),i.createElement("link",{rel:"modulepreload",href:t.entry.module,crossOrigin:e.crossOrigin,integrity:m[t.entry.module],suppressHydrationWarning:!0}),f.map((t=>i.createElement("link",{key:t,rel:"modulepreload",href:t,crossOrigin:e.crossOrigin,integrity:m[t],suppressHydrationWarning:!0}))),p)}function et(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>{t.forEach((t=>{"function"===typeof t?t(e):null!=t&&(t.current=e)}))}}var tt="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement;try{tt&&(window.__reactRouterVersion="7.5.1")}catch(FW){}function nt(e){let{basename:t,children:n,window:r}=e,a=i.useRef();null==a.current&&(a.current=u({window:r,v5Compat:!0}));let s=a.current,[o,l]=i.useState({action:s.action,location:s.location}),c=i.useCallback((e=>{i.startTransition((()=>l(e)))}),[l]);return i.useLayoutEffect((()=>s.listen(c)),[s,c]),i.createElement(ve,{basename:t,children:n,location:o.location,navigationType:o.action,navigator:s})}var rt=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,at=i.forwardRef((function(e,t){let n,{onClick:r,discover:a="render",prefetch:s="none",relative:o,reloadDocument:l,replace:u,state:h,target:p,to:m,preventScrollReset:g,viewTransition:b,...y}=e,{basename:x}=i.useContext(Y),v="string"===typeof m&&rt.test(m),w=!1;if("string"===typeof m&&v&&(n=m,tt))try{let e=new URL(window.location.href),t=m.startsWith("//")?new URL(e.protocol+m):new URL(m),n=F(t.pathname,x);t.origin===e.origin&&null!=n?m=n+t.search+t.hash:w=!0}catch(FW){d(!1,`<Link to="${m}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let k=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};c(ee(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:r}=i.useContext(Y),{hash:a,pathname:s,search:o}=se(e,{relative:t}),l=s;return"/"!==n&&(l="/"===s?n:z([n,s])),r.createHref({pathname:l,search:o,hash:a})}(m,{relative:o}),[S,I,N]=function(e,t){let n=i.useContext(Ge),[r,a]=i.useState(!1),[s,o]=i.useState(!1),{onFocus:l,onBlur:u,onMouseEnter:c,onMouseLeave:d,onTouchStart:h}=t,p=i.useRef(null);i.useEffect((()=>{if("render"===e&&o(!0),"viewport"===e){let e=new IntersectionObserver((e=>{e.forEach((e=>{o(e.isIntersecting)}))}),{threshold:.5});return p.current&&e.observe(p.current),()=>{e.disconnect()}}}),[e]),i.useEffect((()=>{if(r){let e=setTimeout((()=>{o(!0)}),100);return()=>{clearTimeout(e)}}}),[r]);let f=()=>{a(!0)},m=()=>{a(!1),o(!1)};return n?"intent"!==e?[s,p,{}]:[s,p,{onFocus:qe(l,f),onBlur:qe(u,m),onMouseEnter:qe(c,f),onMouseLeave:qe(d,m),onTouchStart:qe(h,f)}]:[!1,p,{}]}(s,y),C=function(e){let{target:t,replace:n,state:r,preventScrollReset:a,relative:s,viewTransition:o}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},l=ae(),u=te(),c=se(e,{relative:s});return i.useCallback((i=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(i,t)){i.preventDefault();let t=void 0!==n?n:f(u)===f(c);l(e,{replace:t,state:r,preventScrollReset:a,relative:s,viewTransition:o})}}),[u,l,c,n,r,t,e,a,s,o])}(m,{replace:u,state:h,target:p,preventScrollReset:g,relative:o,viewTransition:b});let T=i.createElement("a",{...y,...N,href:n||k,onClick:w||l?r:function(e){r&&r(e),e.defaultPrevented||C(e)},ref:et(t,I),target:p,"data-discover":v||"render"!==a?void 0:"true"});return S&&!v?i.createElement(i.Fragment,null,T,i.createElement(Xe,{page:k})):T}));at.displayName="Link";var st=i.forwardRef((function(e,t){let{"aria-current":n="page",caseSensitive:r=!1,className:a="",end:s=!1,style:o,to:l,viewTransition:u,children:d,...h}=e,p=se(l,{relative:h.relative}),f=te(),m=i.useContext(H),{navigator:g,basename:b}=i.useContext(Y),y=null!=m&&function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=i.useContext(q);c(null!=n,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:r}=lt("useViewTransitionState"),a=se(e,{relative:t.relative});if(!n.isTransitioning)return!1;let s=F(n.currentLocation.pathname,r)||n.currentLocation.pathname,o=F(n.nextLocation.pathname,r)||n.nextLocation.pathname;return null!=R(a.pathname,o)||null!=R(a.pathname,s)}(p)&&!0===u,x=g.encodeLocation?g.encodeLocation(p).pathname:p.pathname,v=f.pathname,w=m&&m.navigation&&m.navigation.location?m.navigation.location.pathname:null;r||(v=v.toLowerCase(),w=w?w.toLowerCase():null,x=x.toLowerCase()),w&&b&&(w=F(w,b)||w);const k="/"!==x&&x.endsWith("/")?x.length-1:x.length;let S,I=v===x||!s&&v.startsWith(x)&&"/"===v.charAt(k),N=null!=w&&(w===x||!s&&w.startsWith(x)&&"/"===w.charAt(x.length)),C={isActive:I,isPending:N,isTransitioning:y},T=I?n:void 0;S="function"===typeof a?a(C):[a,I?"active":null,N?"pending":null,y?"transitioning":null].filter(Boolean).join(" ");let E="function"===typeof o?o(C):o;return i.createElement(at,{...h,"aria-current":T,className:S,ref:t,style:E,to:l,viewTransition:u},"function"===typeof d?d(C):d)}));st.displayName="NavLink";var it=i.forwardRef(((e,t)=>{let{discover:n="render",fetcherKey:r,navigate:a,reloadDocument:s,replace:o,state:l,method:u=Se,action:d,onSubmit:h,relative:p,preventScrollReset:m,viewTransition:g,...b}=e,y=dt(),x=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{basename:n}=i.useContext(Y),r=i.useContext(J);c(r,"useFormAction must be used inside a RouteContext");let[a]=r.matches.slice(-1),s={...se(e||".",{relative:t})},o=te();if(null==e){s.search=o.search;let e=new URLSearchParams(s.search),t=e.getAll("index");if(t.some((e=>""===e))){e.delete("index"),t.filter((e=>e)).forEach((t=>e.append("index",t)));let n=e.toString();s.search=n?`?${n}`:""}}e&&"."!==e||!a.route.index||(s.search=s.search?s.search.replace(/^\?/,"?index&"):"?index");"/"!==n&&(s.pathname="/"===s.pathname?n:z([n,s.pathname]));return f(s)}(d,{relative:p}),v="get"===u.toLowerCase()?"get":"post",w="string"===typeof d&&rt.test(d);return i.createElement("form",{ref:t,method:v,action:x,onSubmit:s?h:e=>{if(h&&h(e),e.defaultPrevented)return;e.preventDefault();let t=e.nativeEvent.submitter,n=t?.getAttribute("formmethod")||u;y(t||e.currentTarget,{fetcherKey:r,method:n,navigate:a,replace:o,state:l,relative:p,preventScrollReset:m,viewTransition:g})},...b,"data-discover":w||"render"!==n?void 0:"true"})}));function ot(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function lt(e){let t=i.useContext(G);return c(t,ot(e)),t}it.displayName="Form";var ut=0,ct=()=>`__${String(++ut)}__`;function dt(){let{router:e}=lt("useSubmit"),{basename:t}=i.useContext(Y),n=me("useRouteId");return i.useCallback((async function(r){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{action:s,method:i,encType:o,formData:l,body:u}=$e(r,t);if(!1===a.navigate){let t=a.fetcherKey||ct();await e.fetch(t,n,a.action||s,{preventScrollReset:a.preventScrollReset,formData:l,body:u,formMethod:a.method||i,formEncType:a.encType||o,flushSync:a.flushSync})}else await e.navigate(a.action||s,{preventScrollReset:a.preventScrollReset,formData:l,body:u,formMethod:a.method||i,formEncType:a.encType||o,replace:a.replace,state:a.state,fromRouteId:n,flushSync:a.flushSync,viewTransition:a.viewTransition})}),[e,t,n])}new TextEncoder;var ht=n(579);const pt=()=>{const e=ae();return(0,ht.jsxs)("div",{className:"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white font-sans",children:[(0,ht.jsx)("header",{className:"bg-gray-900 shadow-md py-5",children:(0,ht.jsxs)("div",{className:"container mx-auto flex justify-between items-center px-8",children:[(0,ht.jsx)("h1",{className:"text-2xl font-extrabold text-blue-400",children:"EduTech"}),(0,ht.jsxs)("div",{children:[(0,ht.jsx)("button",{className:"px-5 py-2 text-white border border-gray-500 rounded-lg mr-4 hover:bg-gray-700 transition duration-300",onClick:()=>e("/login"),children:"Sign In"}),(0,ht.jsx)("button",{className:"px-5 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition duration-300",onClick:()=>e("/signup"),children:"Get Started"})]})]})}),(0,ht.jsx)("section",{className:"text-center py-24 px-6",children:(0,ht.jsxs)("div",{className:"container mx-auto",children:[(0,ht.jsxs)("h1",{className:"text-5xl font-extrabold leading-tight",children:["Find Your Perfect ",(0,ht.jsx)("span",{className:"text-blue-400",children:"EduTech Partner"})]}),(0,ht.jsx)("p",{className:"text-lg text-gray-300 mt-4",children:"Connect with like-minded students, collaborate on projects, and excel in your academic journey through AI-powered peer matching."}),(0,ht.jsxs)("div",{className:"mt-8",children:[(0,ht.jsx)("button",{className:"px-6 py-3 bg-blue-600 rounded-lg text-lg hover:bg-blue-700 transition duration-300 mr-4",onClick:()=>e("/signup"),children:"Get Started Now"}),(0,ht.jsx)("button",{className:"px-6 py-3 bg-gray-700 text-white border border-gray-500 rounded-lg text-lg hover:bg-gray-600 transition duration-300",onClick:()=>e("/login"),children:"Sign In"})]})]})}),(0,ht.jsx)("section",{className:"py-20 bg-gray-800",children:(0,ht.jsxs)("div",{className:"container mx-auto px-6",children:[(0,ht.jsx)("h2",{className:"text-3xl font-bold text-center text-blue-400",children:"Why Choose EduTech?"}),(0,ht.jsx)("p",{className:"text-gray-300 text-center mt-4 mb-10",children:"Discover the features that make our platform unique and effective."}),(0,ht.jsxs)("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-8",children:[(0,ht.jsxs)("div",{className:"bg-gray-900 p-6 rounded-xl shadow-lg text-center hover:scale-105 transition-transform duration-300",children:[(0,ht.jsx)("div",{className:"text-blue-400 text-5xl mb-4",children:"\ud83d\udc65"}),(0,ht.jsx)("h3",{className:"text-xl font-semibold",children:"Smart Matching"}),(0,ht.jsx)("p",{className:"text-gray-300 mt-2",children:"Our AI-powered system connects you with peers who complement your skills and learning style."})]}),(0,ht.jsxs)("div",{className:"bg-gray-900 p-6 rounded-xl shadow-lg text-center hover:scale-105 transition-transform duration-300",children:[(0,ht.jsx)("div",{className:"text-blue-400 text-5xl mb-4",children:"\ud83d\udcda"}),(0,ht.jsx)("h3",{className:"text-xl font-semibold",children:"Study Groups"}),(0,ht.jsx)("p",{className:"text-gray-300 mt-2",children:"Form or join study groups based on your courses and academic interests."})]}),(0,ht.jsxs)("div",{className:"bg-gray-900 p-6 rounded-xl shadow-lg text-center hover:scale-105 transition-transform duration-300",children:[(0,ht.jsx)("div",{className:"text-blue-400 text-5xl mb-4",children:"\ud83d\udee0\ufe0f"}),(0,ht.jsx)("h3",{className:"text-xl font-semibold",children:"Project Collaboration"}),(0,ht.jsx)("p",{className:"text-gray-300 mt-2",children:"Find teammates for academic projects and research initiatives."})]}),(0,ht.jsxs)("div",{className:"bg-gray-900 p-6 rounded-xl shadow-lg text-center hover:scale-105 transition-transform duration-300",children:[(0,ht.jsx)("div",{className:"text-blue-400 text-5xl mb-4",children:"\ud83d\udca1"}),(0,ht.jsx)("h3",{className:"text-xl font-semibold",children:"Skill Enhancement"}),(0,ht.jsx)("p",{className:"text-gray-300 mt-2",children:"Learn from peers and share your knowledge in a collaborative environment."})]})]})]})})]})};function ft(e,t){return function(){return e.apply(t,arguments)}}const{toString:mt}=Object.prototype,{getPrototypeOf:gt}=Object,bt=(yt=Object.create(null),e=>{const t=mt.call(e);return yt[t]||(yt[t]=t.slice(8,-1).toLowerCase())});var yt;const xt=e=>(e=e.toLowerCase(),t=>bt(t)===e),vt=e=>t=>typeof t===e,{isArray:wt}=Array,kt=vt("undefined");const St=xt("ArrayBuffer");const It=vt("string"),Nt=vt("function"),Ct=vt("number"),Tt=e=>null!==e&&"object"===typeof e,Et=e=>{if("object"!==bt(e))return!1;const t=gt(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},$t=xt("Date"),Rt=xt("File"),_t=xt("Blob"),At=xt("FileList"),Ft=xt("URLSearchParams"),[Dt,Ot,Lt,Mt]=["ReadableStream","Request","Response","Headers"].map(xt);function zt(e,t){let n,r,{allOwnKeys:a=!1}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(null!==e&&"undefined"!==typeof e)if("object"!==typeof e&&(e=[e]),wt(e))for(n=0,r=e.length;n<r;n++)t.call(null,e[n],n,e);else{const r=a?Object.getOwnPropertyNames(e):Object.keys(e),s=r.length;let i;for(n=0;n<s;n++)i=r[n],t.call(null,e[i],i,e)}}function Pt(e,t){t=t.toLowerCase();const n=Object.keys(e);let r,a=n.length;for(;a-- >0;)if(r=n[a],t===r.toLowerCase())return r;return null}const Bt="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:global,Wt=e=>!kt(e)&&e!==Bt;const Ut=(jt="undefined"!==typeof Uint8Array&&gt(Uint8Array),e=>jt&&e instanceof jt);var jt;const Vt=xt("HTMLFormElement"),Gt=(e=>{let{hasOwnProperty:t}=e;return(e,n)=>t.call(e,n)})(Object.prototype),Ht=xt("RegExp"),qt=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};zt(n,((n,a)=>{let s;!1!==(s=t(n,a,e))&&(r[a]=s||n)})),Object.defineProperties(e,r)};const Kt=xt("AsyncFunction"),Xt=(Yt="function"===typeof setImmediate,Qt=Nt(Bt.postMessage),Yt?setImmediate:Qt?((e,t)=>(Bt.addEventListener("message",(n=>{let{source:r,data:a}=n;r===Bt&&a===e&&t.length&&t.shift()()}),!1),n=>{t.push(n),Bt.postMessage(e,"*")}))(`axios@${Math.random()}`,[]):e=>setTimeout(e));var Yt,Qt;const Jt="undefined"!==typeof queueMicrotask?queueMicrotask.bind(Bt):"undefined"!==typeof process&&process.nextTick||Xt,Zt={isArray:wt,isArrayBuffer:St,isBuffer:function(e){return null!==e&&!kt(e)&&null!==e.constructor&&!kt(e.constructor)&&Nt(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:e=>{let t;return e&&("function"===typeof FormData&&e instanceof FormData||Nt(e.append)&&("formdata"===(t=bt(e))||"object"===t&&Nt(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){let t;return t="undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&St(e.buffer),t},isString:It,isNumber:Ct,isBoolean:e=>!0===e||!1===e,isObject:Tt,isPlainObject:Et,isReadableStream:Dt,isRequest:Ot,isResponse:Lt,isHeaders:Mt,isUndefined:kt,isDate:$t,isFile:Rt,isBlob:_t,isRegExp:Ht,isFunction:Nt,isStream:e=>Tt(e)&&Nt(e.pipe),isURLSearchParams:Ft,isTypedArray:Ut,isFileList:At,forEach:zt,merge:function e(){const{caseless:t}=Wt(this)&&this||{},n={},r=(r,a)=>{const s=t&&Pt(n,a)||a;Et(n[s])&&Et(r)?n[s]=e(n[s],r):Et(r)?n[s]=e({},r):wt(r)?n[s]=r.slice():n[s]=r};for(let a=0,s=arguments.length;a<s;a++)arguments[a]&&zt(arguments[a],r);return n},extend:function(e,t,n){let{allOwnKeys:r}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return zt(t,((t,r)=>{n&&Nt(t)?e[r]=ft(t,n):e[r]=t}),{allOwnKeys:r}),e},trim:e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),inherits:(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:(e,t,n,r)=>{let a,s,i;const o={};if(t=t||{},null==e)return t;do{for(a=Object.getOwnPropertyNames(e),s=a.length;s-- >0;)i=a[s],r&&!r(i,e,t)||o[i]||(t[i]=e[i],o[i]=!0);e=!1!==n&&gt(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:bt,kindOfTest:xt,endsWith:(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},toArray:e=>{if(!e)return null;if(wt(e))return e;let t=e.length;if(!Ct(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},forEachEntry:(e,t)=>{const n=(e&&e[Symbol.iterator]).call(e);let r;for(;(r=n.next())&&!r.done;){const n=r.value;t.call(e,n[0],n[1])}},matchAll:(e,t)=>{let n;const r=[];for(;null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:Vt,hasOwnProperty:Gt,hasOwnProp:Gt,reduceDescriptors:qt,freezeMethods:e=>{qt(e,((t,n)=>{if(Nt(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];Nt(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return wt(e)?r(e):r(String(e).split(t)),n},toCamelCase:e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(e,t)=>null!=e&&Number.isFinite(e=+e)?e:t,findKey:Pt,global:Bt,isContextDefined:Wt,isSpecCompliantForm:function(e){return!!(e&&Nt(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:e=>{const t=new Array(10),n=(e,r)=>{if(Tt(e)){if(t.indexOf(e)>=0)return;if(!("toJSON"in e)){t[r]=e;const a=wt(e)?[]:{};return zt(e,((e,t)=>{const s=n(e,r+1);!kt(s)&&(a[t]=s)})),t[r]=void 0,a}}return e};return n(e,0)},isAsyncFn:Kt,isThenable:e=>e&&(Tt(e)||Nt(e))&&Nt(e.then)&&Nt(e.catch),setImmediate:Xt,asap:Jt};function en(e,t,n,r,a){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),a&&(this.response=a,this.status=a.status?a.status:null)}Zt.inherits(en,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:Zt.toJSONObject(this.config),code:this.code,status:this.status}}});const tn=en.prototype,nn={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{nn[e]={value:e}})),Object.defineProperties(en,nn),Object.defineProperty(tn,"isAxiosError",{value:!0}),en.from=(e,t,n,r,a,s)=>{const i=Object.create(tn);return Zt.toFlatObject(e,i,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),en.call(i,e.message,t,n,r,a),i.cause=e,i.name=e.name,s&&Object.assign(i,s),i};const rn=en;function an(e){return Zt.isPlainObject(e)||Zt.isArray(e)}function sn(e){return Zt.endsWith(e,"[]")?e.slice(0,-2):e}function on(e,t,n){return e?e.concat(t).map((function(e,t){return e=sn(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}const ln=Zt.toFlatObject(Zt,{},null,(function(e){return/^is[A-Z]/.test(e)}));const un=function(e,t,n){if(!Zt.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;const r=(n=Zt.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!Zt.isUndefined(t[e])}))).metaTokens,a=n.visitor||u,s=n.dots,i=n.indexes,o=(n.Blob||"undefined"!==typeof Blob&&Blob)&&Zt.isSpecCompliantForm(t);if(!Zt.isFunction(a))throw new TypeError("visitor must be a function");function l(e){if(null===e)return"";if(Zt.isDate(e))return e.toISOString();if(!o&&Zt.isBlob(e))throw new rn("Blob is not supported. Use a Buffer instead.");return Zt.isArrayBuffer(e)||Zt.isTypedArray(e)?o&&"function"===typeof Blob?new Blob([e]):Buffer.from(e):e}function u(e,n,a){let o=e;if(e&&!a&&"object"===typeof e)if(Zt.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if(Zt.isArray(e)&&function(e){return Zt.isArray(e)&&!e.some(an)}(e)||(Zt.isFileList(e)||Zt.endsWith(n,"[]"))&&(o=Zt.toArray(e)))return n=sn(n),o.forEach((function(e,r){!Zt.isUndefined(e)&&null!==e&&t.append(!0===i?on([n],r,s):null===i?n:n+"[]",l(e))})),!1;return!!an(e)||(t.append(on(a,n,s),l(e)),!1)}const c=[],d=Object.assign(ln,{defaultVisitor:u,convertValue:l,isVisitable:an});if(!Zt.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!Zt.isUndefined(n)){if(-1!==c.indexOf(n))throw Error("Circular reference detected in "+r.join("."));c.push(n),Zt.forEach(n,(function(n,s){!0===(!(Zt.isUndefined(n)||null===n)&&a.call(t,n,Zt.isString(s)?s.trim():s,r,d))&&e(n,r?r.concat(s):[s])})),c.pop()}}(e),t};function cn(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function dn(e,t){this._pairs=[],e&&un(e,this,t)}const hn=dn.prototype;hn.append=function(e,t){this._pairs.push([e,t])},hn.toString=function(e){const t=e?function(t){return e.call(this,t,cn)}:cn;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};const pn=dn;function fn(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function mn(e,t,n){if(!t)return e;const r=n&&n.encode||fn;Zt.isFunction(n)&&(n={serialize:n});const a=n&&n.serialize;let s;if(s=a?a(t,n):Zt.isURLSearchParams(t)?t.toString():new pn(t,n).toString(r),s){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+s}return e}const gn=class{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){Zt.forEach(this.handlers,(function(t){null!==t&&e(t)}))}},bn={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},yn={isBrowser:!0,classes:{URLSearchParams:"undefined"!==typeof URLSearchParams?URLSearchParams:pn,FormData:"undefined"!==typeof FormData?FormData:null,Blob:"undefined"!==typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},xn="undefined"!==typeof window&&"undefined"!==typeof document,vn="object"===typeof navigator&&navigator||void 0,wn=xn&&(!vn||["ReactNative","NativeScript","NS"].indexOf(vn.product)<0),kn="undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"===typeof self.importScripts,Sn=xn&&window.location.href||"http://localhost",In={...e,...yn};const Nn=function(e){function t(e,n,r,a){let s=e[a++];if("__proto__"===s)return!0;const i=Number.isFinite(+s),o=a>=e.length;if(s=!s&&Zt.isArray(r)?r.length:s,o)return Zt.hasOwnProp(r,s)?r[s]=[r[s],n]:r[s]=n,!i;r[s]&&Zt.isObject(r[s])||(r[s]=[]);return t(e,n,r[s],a)&&Zt.isArray(r[s])&&(r[s]=function(e){const t={},n=Object.keys(e);let r;const a=n.length;let s;for(r=0;r<a;r++)s=n[r],t[s]=e[s];return t}(r[s])),!i}if(Zt.isFormData(e)&&Zt.isFunction(e.entries)){const n={};return Zt.forEachEntry(e,((e,r)=>{t(function(e){return Zt.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}(e),r,n,0)})),n}return null};const Cn={transitional:bn,adapter:["xhr","http","fetch"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,a=Zt.isObject(e);a&&Zt.isHTMLForm(e)&&(e=new FormData(e));if(Zt.isFormData(e))return r?JSON.stringify(Nn(e)):e;if(Zt.isArrayBuffer(e)||Zt.isBuffer(e)||Zt.isStream(e)||Zt.isFile(e)||Zt.isBlob(e)||Zt.isReadableStream(e))return e;if(Zt.isArrayBufferView(e))return e.buffer;if(Zt.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let s;if(a){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return un(e,new In.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return In.isNode&&Zt.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((s=Zt.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return un(s?{"files[]":e}:e,t&&new t,this.formSerializer)}}return a||r?(t.setContentType("application/json",!1),function(e,t,n){if(Zt.isString(e))try{return(t||JSON.parse)(e),Zt.trim(e)}catch(FW){if("SyntaxError"!==FW.name)throw FW}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){const t=this.transitional||Cn.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(Zt.isResponse(e)||Zt.isReadableStream(e))return e;if(e&&Zt.isString(e)&&(n&&!this.responseType||r)){const n=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(FW){if(n){if("SyntaxError"===FW.name)throw rn.from(FW,rn.ERR_BAD_RESPONSE,this,null,this.response);throw FW}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:In.classes.FormData,Blob:In.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};Zt.forEach(["delete","get","head","post","put","patch"],(e=>{Cn.headers[e]={}}));const Tn=Cn,En=Zt.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),$n=Symbol("internals");function Rn(e){return e&&String(e).trim().toLowerCase()}function _n(e){return!1===e||null==e?e:Zt.isArray(e)?e.map(_n):String(e)}function An(e,t,n,r,a){return Zt.isFunction(r)?r.call(this,t,n):(a&&(t=n),Zt.isString(t)?Zt.isString(r)?-1!==t.indexOf(r):Zt.isRegExp(r)?r.test(t):void 0:void 0)}class Fn{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function a(e,t,n){const a=Rn(t);if(!a)throw new Error("header name must be a non-empty string");const s=Zt.findKey(r,a);(!s||void 0===r[s]||!0===n||void 0===n&&!1!==r[s])&&(r[s||t]=_n(e))}const s=(e,t)=>Zt.forEach(e,((e,n)=>a(e,n,t)));if(Zt.isPlainObject(e)||e instanceof this.constructor)s(e,t);else if(Zt.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))s((e=>{const t={};let n,r,a;return e&&e.split("\n").forEach((function(e){a=e.indexOf(":"),n=e.substring(0,a).trim().toLowerCase(),r=e.substring(a+1).trim(),!n||t[n]&&En[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t})(e),t);else if(Zt.isHeaders(e))for(const[i,o]of e.entries())a(o,i,n);else null!=e&&a(t,e,n);return this}get(e,t){if(e=Rn(e)){const n=Zt.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return function(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}(e);if(Zt.isFunction(t))return t.call(this,e,n);if(Zt.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=Rn(e)){const n=Zt.findKey(this,e);return!(!n||void 0===this[n]||t&&!An(0,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function a(e){if(e=Rn(e)){const a=Zt.findKey(n,e);!a||t&&!An(0,n[a],a,t)||(delete n[a],r=!0)}}return Zt.isArray(e)?e.forEach(a):a(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const a=t[n];e&&!An(0,this[a],a,e,!0)||(delete this[a],r=!0)}return r}normalize(e){const t=this,n={};return Zt.forEach(this,((r,a)=>{const s=Zt.findKey(n,a);if(s)return t[s]=_n(r),void delete t[a];const i=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}(a):String(a).trim();i!==a&&delete t[a],t[i]=_n(r),n[i]=!0})),this}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.constructor.concat(this,...t)}toJSON(e){const t=Object.create(null);return Zt.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&Zt.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((e=>{let[t,n]=e;return t+": "+n})).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e){const t=new this(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return r.forEach((e=>t.set(e))),t}static accessor(e){const t=(this[$n]=this[$n]={accessors:{}}).accessors,n=this.prototype;function r(e){const r=Rn(e);t[r]||(!function(e,t){const n=Zt.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,a){return this[r].call(this,t,e,n,a)},configurable:!0})}))}(n,e),t[r]=!0)}return Zt.isArray(e)?e.forEach(r):r(e),this}}Fn.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),Zt.reduceDescriptors(Fn.prototype,((e,t)=>{let{value:n}=e,r=t[0].toUpperCase()+t.slice(1);return{get:()=>n,set(e){this[r]=e}}})),Zt.freezeMethods(Fn);const Dn=Fn;function On(e,t){const n=this||Tn,r=t||n,a=Dn.from(r.headers);let s=r.data;return Zt.forEach(e,(function(e){s=e.call(n,s,a.normalize(),t?t.status:void 0)})),a.normalize(),s}function Ln(e){return!(!e||!e.__CANCEL__)}function Mn(e,t,n){rn.call(this,null==e?"canceled":e,rn.ERR_CANCELED,t,n),this.name="CanceledError"}Zt.inherits(Mn,rn,{__CANCEL__:!0});const zn=Mn;function Pn(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new rn("Request failed with status code "+n.status,[rn.ERR_BAD_REQUEST,rn.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}const Bn=function(e,t){e=e||10;const n=new Array(e),r=new Array(e);let a,s=0,i=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[i];a||(a=l),n[s]=o,r[s]=l;let c=i,d=0;for(;c!==s;)d+=n[c++],c%=e;if(s=(s+1)%e,s===i&&(i=(i+1)%e),l-a<t)return;const h=u&&l-u;return h?Math.round(1e3*d/h):void 0}};const Wn=function(e,t){let n,r,a=0,s=1e3/t;const i=function(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Date.now();a=s,n=null,r&&(clearTimeout(r),r=null),e.apply(null,t)};return[function(){const e=Date.now(),t=e-a;for(var o=arguments.length,l=new Array(o),u=0;u<o;u++)l[u]=arguments[u];t>=s?i(l,e):(n=l,r||(r=setTimeout((()=>{r=null,i(n)}),s-t)))},()=>n&&i(n)]},Un=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3,r=0;const a=Bn(50,250);return Wn((n=>{const s=n.loaded,i=n.lengthComputable?n.total:void 0,o=s-r,l=a(o);r=s;e({loaded:s,total:i,progress:i?s/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&s<=i?(i-s)/l:void 0,event:n,lengthComputable:null!=i,[t?"download":"upload"]:!0})}),n)},jn=(e,t)=>{const n=null!=e;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},Vn=e=>function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return Zt.asap((()=>e(...n)))},Gn=In.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,In.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(In.origin),In.navigator&&/(msie|trident)/i.test(In.navigator.userAgent)):()=>!0,Hn=In.hasStandardBrowserEnv?{write(e,t,n,r,a,s){const i=[e+"="+encodeURIComponent(t)];Zt.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),Zt.isString(r)&&i.push("path="+r),Zt.isString(a)&&i.push("domain="+a),!0===s&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function qn(e,t,n){let r=!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);return e&&(r||0==n)?function(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}const Kn=e=>e instanceof Dn?{...e}:e;function Xn(e,t){t=t||{};const n={};function r(e,t,n,r){return Zt.isPlainObject(e)&&Zt.isPlainObject(t)?Zt.merge.call({caseless:r},e,t):Zt.isPlainObject(t)?Zt.merge({},t):Zt.isArray(t)?t.slice():t}function a(e,t,n,a){return Zt.isUndefined(t)?Zt.isUndefined(e)?void 0:r(void 0,e,0,a):r(e,t,0,a)}function s(e,t){if(!Zt.isUndefined(t))return r(void 0,t)}function i(e,t){return Zt.isUndefined(t)?Zt.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,a,s){return s in t?r(n,a):s in e?r(void 0,n):void 0}const l={url:s,method:s,data:s,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(e,t,n)=>a(Kn(e),Kn(t),0,!0)};return Zt.forEach(Object.keys(Object.assign({},e,t)),(function(r){const s=l[r]||a,i=s(e[r],t[r],r);Zt.isUndefined(i)&&s!==o||(n[r]=i)})),n}const Yn=e=>{const t=Xn({},e);let n,{data:r,withXSRFToken:a,xsrfHeaderName:s,xsrfCookieName:i,headers:o,auth:l}=t;if(t.headers=o=Dn.from(o),t.url=mn(qn(t.baseURL,t.url,t.allowAbsoluteUrls),e.params,e.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),Zt.isFormData(r))if(In.hasStandardBrowserEnv||In.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[e,...t]=n?n.split(";").map((e=>e.trim())).filter(Boolean):[];o.setContentType([e||"multipart/form-data",...t].join("; "))}if(In.hasStandardBrowserEnv&&(a&&Zt.isFunction(a)&&(a=a(t)),a||!1!==a&&Gn(t.url))){const e=s&&i&&Hn.read(i);e&&o.set(s,e)}return t},Qn="undefined"!==typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){const r=Yn(e);let a=r.data;const s=Dn.from(r.headers).normalize();let i,o,l,u,c,{responseType:d,onUploadProgress:h,onDownloadProgress:p}=r;function f(){u&&u(),c&&c(),r.cancelToken&&r.cancelToken.unsubscribe(i),r.signal&&r.signal.removeEventListener("abort",i)}let m=new XMLHttpRequest;function g(){if(!m)return;const r=Dn.from("getAllResponseHeaders"in m&&m.getAllResponseHeaders());Pn((function(e){t(e),f()}),(function(e){n(e),f()}),{data:d&&"text"!==d&&"json"!==d?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:r,config:e,request:m}),m=null}m.open(r.method.toUpperCase(),r.url,!0),m.timeout=r.timeout,"onloadend"in m?m.onloadend=g:m.onreadystatechange=function(){m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))&&setTimeout(g)},m.onabort=function(){m&&(n(new rn("Request aborted",rn.ECONNABORTED,e,m)),m=null)},m.onerror=function(){n(new rn("Network Error",rn.ERR_NETWORK,e,m)),m=null},m.ontimeout=function(){let t=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const a=r.transitional||bn;r.timeoutErrorMessage&&(t=r.timeoutErrorMessage),n(new rn(t,a.clarifyTimeoutError?rn.ETIMEDOUT:rn.ECONNABORTED,e,m)),m=null},void 0===a&&s.setContentType(null),"setRequestHeader"in m&&Zt.forEach(s.toJSON(),(function(e,t){m.setRequestHeader(t,e)})),Zt.isUndefined(r.withCredentials)||(m.withCredentials=!!r.withCredentials),d&&"json"!==d&&(m.responseType=r.responseType),p&&([l,c]=Un(p,!0),m.addEventListener("progress",l)),h&&m.upload&&([o,u]=Un(h),m.upload.addEventListener("progress",o),m.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(i=t=>{m&&(n(!t||t.type?new zn(null,e,m):t),m.abort(),m=null)},r.cancelToken&&r.cancelToken.subscribe(i),r.signal&&(r.signal.aborted?i():r.signal.addEventListener("abort",i)));const b=function(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}(r.url);b&&-1===In.protocols.indexOf(b)?n(new rn("Unsupported protocol "+b+":",rn.ERR_BAD_REQUEST,e)):m.send(a||null)}))},Jn=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let n,r=new AbortController;const a=function(e){if(!n){n=!0,i();const t=e instanceof Error?e:this.reason;r.abort(t instanceof rn?t:new zn(t instanceof Error?t.message:t))}};let s=t&&setTimeout((()=>{s=null,a(new rn(`timeout ${t} of ms exceeded`,rn.ETIMEDOUT))}),t);const i=()=>{e&&(s&&clearTimeout(s),s=null,e.forEach((e=>{e.unsubscribe?e.unsubscribe(a):e.removeEventListener("abort",a)})),e=null)};e.forEach((e=>e.addEventListener("abort",a)));const{signal:o}=r;return o.unsubscribe=()=>Zt.asap(i),o}},Zn=function*(e,t){let n=e.byteLength;if(!t||n<t)return void(yield e);let r,a=0;for(;a<n;)r=a+t,yield e.slice(a,r),a=r},er=async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}},tr=(e,t,n,r)=>{const a=async function*(e,t){for await(const n of er(e))yield*Zn(n,t)}(e,t);let s,i=0,o=e=>{s||(s=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:r}=await a.next();if(t)return o(),void e.close();let s=r.byteLength;if(n){let e=i+=s;n(e)}e.enqueue(new Uint8Array(r))}catch(t){throw o(t),t}},cancel:e=>(o(e),a.return())},{highWaterMark:2})},nr="function"===typeof fetch&&"function"===typeof Request&&"function"===typeof Response,rr=nr&&"function"===typeof ReadableStream,ar=nr&&("function"===typeof TextEncoder?(e=>t=>e.encode(t))(new TextEncoder):async e=>new Uint8Array(await new Response(e).arrayBuffer())),sr=function(e){try{for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return!!e(...n)}catch(FW){return!1}},ir=rr&&sr((()=>{let e=!1;const t=new Request(In.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})),or=rr&&sr((()=>Zt.isReadableStream(new Response("").body))),lr={stream:or&&(e=>e.body)};var ur;nr&&(ur=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((e=>{!lr[e]&&(lr[e]=Zt.isFunction(ur[e])?t=>t[e]():(t,n)=>{throw new rn(`Response type '${e}' is not supported`,rn.ERR_NOT_SUPPORT,n)})})));const cr=async(e,t)=>{const n=Zt.toFiniteNumber(e.getContentLength());return null==n?(async e=>{if(null==e)return 0;if(Zt.isBlob(e))return e.size;if(Zt.isSpecCompliantForm(e)){const t=new Request(In.origin,{method:"POST",body:e});return(await t.arrayBuffer()).byteLength}return Zt.isArrayBufferView(e)||Zt.isArrayBuffer(e)?e.byteLength:(Zt.isURLSearchParams(e)&&(e+=""),Zt.isString(e)?(await ar(e)).byteLength:void 0)})(t):n},dr=nr&&(async e=>{let{url:t,method:n,data:r,signal:a,cancelToken:s,timeout:i,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:c,withCredentials:d="same-origin",fetchOptions:h}=Yn(e);u=u?(u+"").toLowerCase():"text";let p,f=Jn([a,s&&s.toAbortSignal()],i);const m=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let g;try{if(l&&ir&&"get"!==n&&"head"!==n&&0!==(g=await cr(c,r))){let e,n=new Request(t,{method:"POST",body:r,duplex:"half"});if(Zt.isFormData(r)&&(e=n.headers.get("content-type"))&&c.setContentType(e),n.body){const[e,t]=jn(g,Un(Vn(l)));r=tr(n.body,65536,e,t)}}Zt.isString(d)||(d=d?"include":"omit");const a="credentials"in Request.prototype;p=new Request(t,{...h,signal:f,method:n.toUpperCase(),headers:c.normalize().toJSON(),body:r,duplex:"half",credentials:a?d:void 0});let s=await fetch(p);const i=or&&("stream"===u||"response"===u);if(or&&(o||i&&m)){const e={};["status","statusText","headers"].forEach((t=>{e[t]=s[t]}));const t=Zt.toFiniteNumber(s.headers.get("content-length")),[n,r]=o&&jn(t,Un(Vn(o),!0))||[];s=new Response(tr(s.body,65536,n,(()=>{r&&r(),m&&m()})),e)}u=u||"text";let b=await lr[Zt.findKey(lr,u)||"text"](s,e);return!i&&m&&m(),await new Promise(((t,n)=>{Pn(t,n,{data:b,headers:Dn.from(s.headers),status:s.status,statusText:s.statusText,config:e,request:p})}))}catch(b){if(m&&m(),b&&"TypeError"===b.name&&/fetch/i.test(b.message))throw Object.assign(new rn("Network Error",rn.ERR_NETWORK,e,p),{cause:b.cause||b});throw rn.from(b,b&&b.code,e,p)}}),hr={http:null,xhr:Qn,fetch:dr};Zt.forEach(hr,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(FW){}Object.defineProperty(e,"adapterName",{value:t})}}));const pr=e=>`- ${e}`,fr=e=>Zt.isFunction(e)||null===e||!1===e,mr=e=>{e=Zt.isArray(e)?e:[e];const{length:t}=e;let n,r;const a={};for(let s=0;s<t;s++){let t;if(n=e[s],r=n,!fr(n)&&(r=hr[(t=String(n)).toLowerCase()],void 0===r))throw new rn(`Unknown adapter '${t}'`);if(r)break;a[t||"#"+s]=r}if(!r){const e=Object.entries(a).map((e=>{let[t,n]=e;return`adapter ${t} `+(!1===n?"is not supported by the environment":"is not available in the build")}));let n=t?e.length>1?"since :\n"+e.map(pr).join("\n"):" "+pr(e[0]):"as no adapter specified";throw new rn("There is no suitable adapter to dispatch the request "+n,"ERR_NOT_SUPPORT")}return r};function gr(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new zn(null,e)}function br(e){gr(e),e.headers=Dn.from(e.headers),e.data=On.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1);return mr(e.adapter||Tn.adapter)(e).then((function(t){return gr(e),t.data=On.call(e,e.transformResponse,t),t.headers=Dn.from(t.headers),t}),(function(t){return Ln(t)||(gr(e),t&&t.response&&(t.response.data=On.call(e,e.transformResponse,t.response),t.response.headers=Dn.from(t.response.headers))),Promise.reject(t)}))}const yr="1.8.4",xr={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{xr[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const vr={};xr.transitional=function(e,t,n){function r(e,t){return"[Axios v1.8.4] Transitional option '"+e+"'"+t+(n?". "+n:"")}return(n,a,s)=>{if(!1===e)throw new rn(r(a," has been removed"+(t?" in "+t:"")),rn.ERR_DEPRECATED);return t&&!vr[a]&&(vr[a]=!0,console.warn(r(a," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,a,s)}},xr.spelling=function(e){return(t,n)=>(console.warn(`${n} is likely a misspelling of ${e}`),!0)};const wr={assertOptions:function(e,t,n){if("object"!==typeof e)throw new rn("options must be an object",rn.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let a=r.length;for(;a-- >0;){const s=r[a],i=t[s];if(i){const t=e[s],n=void 0===t||i(t,s,e);if(!0!==n)throw new rn("option "+s+" must be "+n,rn.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new rn("Unknown option "+s,rn.ERR_BAD_OPTION)}},validators:xr},kr=wr.validators;class Sr{constructor(e){this.defaults=e,this.interceptors={request:new gn,response:new gn}}async request(e,t){try{return await this._request(e,t)}catch(n){if(n instanceof Error){let e={};Error.captureStackTrace?Error.captureStackTrace(e):e=new Error;const t=e.stack?e.stack.replace(/^.+\n/,""):"";try{n.stack?t&&!String(n.stack).endsWith(t.replace(/^.+\n.+\n/,""))&&(n.stack+="\n"+t):n.stack=t}catch(FW){}}throw n}}_request(e,t){"string"===typeof e?(t=t||{}).url=e:t=e||{},t=Xn(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:a}=t;void 0!==n&&wr.assertOptions(n,{silentJSONParsing:kr.transitional(kr.boolean),forcedJSONParsing:kr.transitional(kr.boolean),clarifyTimeoutError:kr.transitional(kr.boolean)},!1),null!=r&&(Zt.isFunction(r)?t.paramsSerializer={serialize:r}:wr.assertOptions(r,{encode:kr.function,serialize:kr.function},!0)),void 0!==t.allowAbsoluteUrls||(void 0!==this.defaults.allowAbsoluteUrls?t.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:t.allowAbsoluteUrls=!0),wr.assertOptions(t,{baseUrl:kr.spelling("baseURL"),withXsrfToken:kr.spelling("withXSRFToken")},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();let s=a&&Zt.merge(a.common,a[t.method]);a&&Zt.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete a[e]})),t.headers=Dn.concat(s,a);const i=[];let o=!0;this.interceptors.request.forEach((function(e){"function"===typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,i.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let c,d=0;if(!o){const e=[br.bind(this),void 0];for(e.unshift.apply(e,i),e.push.apply(e,l),c=e.length,u=Promise.resolve(t);d<c;)u=u.then(e[d++],e[d++]);return u}c=i.length;let h=t;for(d=0;d<c;){const e=i[d++],t=i[d++];try{h=e(h)}catch(p){t.call(this,p);break}}try{u=br.call(this,h)}catch(p){return Promise.reject(p)}for(d=0,c=l.length;d<c;)u=u.then(l[d++],l[d++]);return u}getUri(e){return mn(qn((e=Xn(this.defaults,e)).baseURL,e.url,e.allowAbsoluteUrls),e.params,e.paramsSerializer)}}Zt.forEach(["delete","get","head","options"],(function(e){Sr.prototype[e]=function(t,n){return this.request(Xn(n||{},{method:e,url:t,data:(n||{}).data}))}})),Zt.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,a){return this.request(Xn(a||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Sr.prototype[e]=t(),Sr.prototype[e+"Form"]=t(!0)}));const Ir=Sr;class Nr{constructor(e){if("function"!==typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;for(;t-- >0;)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,a){n.reason||(n.reason=new zn(e,r,a),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}toAbortSignal(){const e=new AbortController,t=t=>{e.abort(t)};return this.subscribe(t),e.signal.unsubscribe=()=>this.unsubscribe(t),e.signal}static source(){let e;return{token:new Nr((function(t){e=t})),cancel:e}}}const Cr=Nr;const Tr={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Tr).forEach((e=>{let[t,n]=e;Tr[n]=t}));const Er=Tr;const $r=function e(t){const n=new Ir(t),r=ft(Ir.prototype.request,n);return Zt.extend(r,Ir.prototype,n,{allOwnKeys:!0}),Zt.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(Xn(t,n))},r}(Tn);$r.Axios=Ir,$r.CanceledError=zn,$r.CancelToken=Cr,$r.isCancel=Ln,$r.VERSION=yr,$r.toFormData=un,$r.AxiosError=rn,$r.Cancel=$r.CanceledError,$r.all=function(e){return Promise.all(e)},$r.spread=function(e){return function(t){return e.apply(null,t)}},$r.isAxiosError=function(e){return Zt.isObject(e)&&!0===e.isAxiosError},$r.mergeConfig=Xn,$r.AxiosHeaders=Dn,$r.formToJSON=e=>Nn(Zt.isHTMLForm(e)?new FormData(e):e),$r.getAdapter=mr,$r.HttpStatusCode=Er,$r.default=$r;const Rr=$r,_r=()=>{const e=ae(),[t,n]=(0,i.useState)(""),[r,a]=(0,i.useState)(""),[s,o]=(0,i.useState)("");return(0,ht.jsx)("div",{className:"min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white",children:(0,ht.jsxs)("div",{className:"bg-gray-900 p-8 rounded-2xl shadow-xl w-96 backdrop-blur-md",children:[(0,ht.jsx)("h2",{className:"text-3xl font-extrabold text-center text-blue-400",children:"Login"}),s&&(0,ht.jsx)("p",{className:"text-red-500 text-center mt-2",children:s}),(0,ht.jsxs)("form",{onSubmit:async n=>{n.preventDefault(),o("");try{const{data:n}=await Rr.get("http://localhost:5000/api/users"),r=n.find((e=>e.email===t));if(!r)return void o("User not found. Please sign up.");localStorage.setItem("currentUser",JSON.stringify({id:r._id||r.id,name:r.name,email:r.email})),e("/dashboard")}catch(r){o("Login failed. Try again.")}},className:"space-y-4 mt-4",children:[(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{className:"block text-gray-300 font-semibold",children:"Email"}),(0,ht.jsx)("input",{type:"email",value:t,onChange:e=>n(e.target.value),required:!0,className:"w-full p-3 bg-gray-800 border border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 text-white placeholder-gray-400",placeholder:"Enter your email"})]}),(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{className:"block text-gray-300 font-semibold",children:"Password"}),(0,ht.jsx)("input",{type:"password",value:r,onChange:e=>a(e.target.value),required:!0,className:"w-full p-3 bg-gray-800 border border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 text-white placeholder-gray-400",placeholder:"Enter your password"})]}),(0,ht.jsx)("button",{type:"submit",className:"w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 transition-transform transform hover:scale-105",children:"Login"})]})]})})},Ar=()=>{const[e,t]=(0,i.useState)({name:"",email:"",password:""}),n=ae(),r=e=>{const{name:n,value:r}=e.currentTarget||e.target;t((e=>({...e,[n]:r})))};return(0,ht.jsxs)("div",{className:"signup-container",children:[(0,ht.jsx)("h2",{children:"Sign Up"}),(0,ht.jsxs)("form",{onSubmit:async t=>{if(t.preventDefault(),""!==e.name.trim()&&""!==e.email.trim()&&""!==e.password.trim())try{const t={name:e.name.trim(),email:e.email.trim(),password:e.password.trim(),displayName:e.name.trim()},r=[`http://${"undefined"!==typeof window?window.location.hostname:"localhost"}:5000`,"http://localhost:5000","http://127.0.0.1:5000"];let a,s;for(const e of r)try{({data:a}=await Rr.post(`${e}/api/signup`,t,{headers:{"Content-Type":"application/json"},timeout:8e3}));break}catch(i){s=i}if(!a)throw s||new Error("Network Error");localStorage.setItem("currentUser",JSON.stringify({id:a.user.id,name:a.user.name,email:a.user.email})),alert("Signup successful! \ud83d\udccc"),n("/dashboard")}catch(o){var r,a,s;const e=null===o||void 0===o||null===(r=o.response)||void 0===r?void 0:r.status,t=(null===o||void 0===o||null===(a=o.response)||void 0===a||null===(s=a.data)||void 0===s?void 0:s.error)||(409===e?"Email already registered":(null===o||void 0===o?void 0:o.message)||"Something went wrong. Please try again.");alert(t)}else alert("Please fill in all fields.")},children:[(0,ht.jsx)("input",{type:"text",name:"name",placeholder:"Name",value:e.name,onChange:r}),(0,ht.jsx)("input",{type:"email",name:"email",placeholder:"Email",value:e.email,onChange:r}),(0,ht.jsx)("input",{type:"password",name:"password",placeholder:"Password",value:e.password,onChange:r,onInput:r,autoComplete:"new-password",required:!0}),(0,ht.jsx)("button",{type:"submit",children:"Sign Up"})]})]})},Fr=()=>{const[e,t]=(0,i.useState)([{id:1,from:"Alex Johnson",project:"Data Structures Project",status:"pending",timestamp:"2 hours ago"},{id:2,from:"Sarah Wilson",project:"Machine Learning Study Group",status:"pending",timestamp:"1 day ago"}]),n=e=>{switch(e){case"pending":return"bg-gradient-to-r from-yellow-500 to-yellow-400 text-white text-xs px-3 py-1 rounded-full font-medium";case"accepted":return"bg-gradient-to-r from-green-500 to-green-400 text-white text-xs px-3 py-1 rounded-full font-medium";case"declined":return"bg-gradient-to-r from-red-500 to-red-400 text-white text-xs px-3 py-1 rounded-full font-medium";default:return"bg-gray-500 text-white text-xs px-3 py-1 rounded-full font-medium"}},r=e=>{switch(e){case"pending":return"Pending";case"accepted":return"Accepted";case"declined":return"Declined";default:return"Unknown"}};return(0,ht.jsx)("div",{className:"bg-gray-900 bg-opacity-90 p-4 rounded-2xl shadow-lg backdrop-blur-md flex-1 w-full max-w-md overflow-y-auto",children:(0,ht.jsx)("div",{className:"space-y-2",children:e.map((e=>(0,ht.jsxs)("div",{className:"flex items-center gap-4 p-3 bg-gray-800 rounded-lg shadow-sm hover:bg-gray-700 transition duration-300",children:[(0,ht.jsx)("span",{className:"text-2xl",children:"\ud83d\udc65"}),(0,ht.jsxs)("div",{className:"flex-1",children:[(0,ht.jsx)("p",{className:"font-semibold text-gray-200",children:"Collaboration request"}),(0,ht.jsxs)("p",{className:"text-sm text-gray-400",children:["From ",e.from]}),(0,ht.jsx)("p",{className:"text-xs text-gray-500",children:e.project}),(0,ht.jsx)("p",{className:"text-xs text-gray-500",children:e.timestamp})]}),(0,ht.jsxs)("div",{className:"flex flex-col items-end gap-2",children:[(0,ht.jsx)("span",{className:n(e.status),children:r(e.status)}),"pending"===e.status&&(0,ht.jsxs)("div",{className:"flex gap-1",children:[(0,ht.jsx)("button",{onClick:()=>{return n=e.id,void t((e=>e.map((e=>e.id===n?{...e,status:"accepted"}:e))));var n},className:"bg-green-600 hover:bg-green-700 text-white text-xs px-2 py-1 rounded transition-colors",children:"Accept"}),(0,ht.jsx)("button",{onClick:()=>{return n=e.id,void t((e=>e.map((e=>e.id===n?{...e,status:"declined"}:e))));var n},className:"bg-red-600 hover:bg-red-700 text-white text-xs px-2 py-1 rounded transition-colors",children:"Decline"})]})]})]},e.id)))})})};class Dr{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Or{refCount(e){return Lr("refCount")}incRef(e){return Lr("incRef")}timerAvailable(){return!0}time(e){return Lr("time")}read(e){return Lr("read")}readSync(e){return Lr("readSync")}readToGPU(e,t){return Lr("readToGPU")}numDataIds(){return Lr("numDataIds")}disposeData(e,t){return Lr("disposeData")}write(e,t,n){return Lr("write")}move(e,t,n,r,a){return Lr("move")}createTensorFromGPUData(e,t,n){return Lr("createTensorFromGPUData")}memory(){return Lr("memory")}floatPrecision(){return Lr("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Lr("dispose")}}function Lr(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Mr(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Br(e,t,n)}function zr(e,t,n){return Math.max(e,Math.min(t,n))}function Pr(e){return e%2===0?e:e+1}function Br(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Wr(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Ur(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Wr(Gr(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function jr(e){Wr(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Vr(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Gr(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Hr(e){return e%1===0}function qr(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Kr(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Xr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0;const o=()=>{if(e())return void a();i++;const l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function Yr(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function Qr(e,t){const n=t.length;return Wr((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Wr(e.every((e=>Hr(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Jr(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:Qr(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Zr(e,t){return ea(e,t)}function ea(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function ta(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function na(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function ra(e){return"string"===typeof e||e instanceof String}function aa(e){return"number"===typeof e}function sa(e){return Array.isArray(e)?sa(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":aa(e)?"float32":ra(e)?"string":"boolean"===typeof e?"bool":"float32"}function ia(e){return!!(e&&e.constructor&&e.call&&e.apply)}function oa(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function la(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function ua(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=ua(e+t*o,i,n,r)}return a}function ca(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return ua(0,e,t,n)}function da(e,t){const n=ha(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function ha(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function pa(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return ca(e,new Float32Array(n));if("int32"===t)return ca(e,new Int32Array(n));if("bool"===t)return ca(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function fa(e){e.forEach((t=>{Wr(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function ma(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function ga(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function ba(e){return e&&e.then&&"function"===typeof e.then}const ya="tfjsflags";class xa{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=va,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(wa().getBool("IS_TEST")||wa().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];wa().getBool("IS_TEST")||wa().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ba(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(ya in e){e[ya].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function va(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function wa(){return Sa}let ka,Sa=null;function Ia(){if(null==ka){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}ka=e}return ka}function Na(e,t){const n=function(){const e=Ia();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Ca="Abs",Ta="Acos",Ea="Acosh",$a="Add",Ra="AddN",_a="All",Aa="Any",Fa="ArgMax",Da="ArgMin",Oa="Asin",La="Asinh",Ma="Atan",za="Atanh",Pa="Atan2",Ba="AvgPool",Wa="AvgPoolGrad",Ua="AvgPool3D",ja="AvgPool3DGrad",Va="BatchMatMul",Ga="BatchToSpaceND",Ha="Bincount",qa="BitwiseAnd",Ka="BroadcastArgs",Xa="Cast",Ya="Ceil",Qa="ClipByValue",Ja="Complex",Za="ComplexAbs",es="Concat",ts="Conv2D",ns="Conv2DBackpropFilter",rs="Conv2DBackpropInput",as="Conv3D",ss="Conv3DBackpropFilterV2",is="Conv3DBackpropInputV2",os="Cos",ls="Cosh",us="Cumprod",cs="Cumsum",ds="CropAndResize",hs="DenseBincount",ps="DepthToSpace",fs="DepthwiseConv2dNative",ms="DepthwiseConv2dNativeBackpropFilter",gs="DepthwiseConv2dNativeBackpropInput",bs="Diag",ys="Dilation2D",xs="Dilation2DBackpropInput",vs="Dilation2DBackpropFilter",ws="Draw",ks="RealDiv",Ss="Einsum",Is="Elu",Ns="EluGrad",Cs="Erf",Ts="Equal",Es="Exp",$s="ExpandDims",Rs="Expm1",_s="FFT",As="Fill",Fs="FlipLeftRight",Ds="Floor",Os="FloorDiv",Ls="FusedBatchNorm",Ms="GatherV2",zs="GatherNd",Ps="Greater",Bs="GreaterEqual",Ws="Identity",Us="IFFT",js="Imag",Vs="IsFinite",Gs="IsInf",Hs="IsNan",qs="LeakyRelu",Ks="Less",Xs="LessEqual",Ys="LinSpace",Qs="Log",Js="Log1p",Zs="LogicalAnd",ei="LogicalNot",ti="LogicalOr",ni="LRN",ri="LRNGrad",ai="Max",si="Maximum",ii="MaxPool",oi="MaxPoolGrad",li="MaxPool3D",ui="MaxPool3DGrad",ci="MaxPoolWithArgmax",di="Mean",hi="Min",pi="Minimum",fi="MirrorPad",mi="Mod",gi="Multinomial",bi="Multiply",yi="Neg",xi="NotEqual",vi="NonMaxSuppressionV3",wi="NonMaxSuppressionV4",ki="NonMaxSuppressionV5",Si="OnesLike",Ii="OneHot",Ni="Pack",Ci="PadV2",Ti="Pow",Ei="Prelu",$i="Prod",Ri="RaggedGather",_i="RaggedRange",Ai="RaggedTensorToTensor",Fi="Range",Di="Real",Oi="Reciprocal",Li="Relu",Mi="Reshape",zi="ResizeNearestNeighbor",Pi="ResizeNearestNeighborGrad",Bi="ResizeBilinear",Wi="ResizeBilinearGrad",Ui="Relu6",ji="Reverse",Vi="Round",Gi="Rsqrt",Hi="ScatterNd",qi="TensorScatterUpdate",Ki="SearchSorted",Xi="Select",Yi="Selu",Qi="Slice",Ji="Sin",Zi="Sinh",eo="Sign",to="Sigmoid",no="Softplus",ro="Sqrt",ao="Sum",so="SpaceToBatchND",io="SplitV",oo="Softmax",lo="SparseFillEmptyRows",uo="SparseReshape",co="SparseSegmentMean",ho="SparseSegmentSum",po="SparseToDense",fo="SquaredDifference",mo="Square",go="StaticRegexReplace",bo="StridedSlice",yo="StringNGrams",xo="StringSplit",vo="StringToHashBucketFast",wo="Sub",ko="Tan",So="Tanh",Io="Tile",No="TopK",Co="Transform",To="Transpose",Eo="Unique",$o="Unpack",Ro="UnsortedSegmentSum",_o="ZerosLike",Ao="Step",Fo="FromPixels",Do="RotateWithOffset",Oo="_FusedMatMul",Lo="FusedConv2D",Mo="FusedDepthwiseConv2D";function zo(){wa().getBool("IS_TEST")||wa().getBool("PROD")||console.warn(...arguments)}function Po(){wa().getBool("IS_TEST")||wa().getBool("PROD")||console.log(...arguments)}const Bo=Na("kernelRegistry",(()=>new Map)),Wo=Na("gradRegistry",(()=>new Map));function Uo(e,t){const n=qo(e,t);return Bo.get(n)}function jo(e){return Wo.get(e)}function Vo(e){const t=Bo.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function Go(e){const{kernelName:t,backendName:n}=e,r=qo(t,n);Bo.has(r)&&zo(`The kernel '${t}' for backend '${n}' is already registered`),Bo.set(r,e)}function Ho(e){const{kernelName:t}=e;Wo.has(t)&&wa().getBool("DEBUG")&&zo(`Overriding the gradient for '${t}'`),Wo.set(t,e)}function qo(e,t){return`${t}_${e}`}function Ko(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Xo=n(353);const Yo=n.n(Xo)()||Xo;function Qo(e){return Yo.fromString(e,!0,16)}const Jo=Qo("c3a5c85c97cb3127"),Zo=Qo("b492b66fbe98f273"),el=Qo("9ae16a3b2f90404f");function tl(e){return e.xor(e.shru(47))}function nl(e,t,n){const r=e.slice(t,t+n);return Yo.fromBytes(Array.from(r),!0,!0)}function rl(e,t){return nl(e,t,8)}function al(e,t){return nl(e,t,4)}function sl(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function il(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Qo("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function ol(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=sl(s.add(a).add(r),21);const i=a;return a=(a=a.add(t)).add(n),s=s.add(sl(a,44)),[a.add(r),s.add(i)]}(rl(e,t),rl(e,t+8),rl(e,t+16),rl(e,t+24),n,r)}function ll(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Yo.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=el.add(2*t),r=rl(e,0).add(el),a=rl(e,t-8);return il(sl(a,37).mul(n).add(r),sl(r,25).add(a).mul(n),n)}if(t>=4){const n=el.add(2*t);return il(al(e,0).shl(3).add(t),al(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return tl(el.mul(n).xor(Jo.mul(r))).mul(el)}return el}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=el.add(2*t),r=rl(e,0).mul(Zo),a=rl(e,8),s=rl(e,t-8).mul(n),i=rl(e,t-16).mul(el);return il(sl(r.add(a),43).add(sl(s,30)).add(i),r.add(sl(a.add(el),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=el.add(2*t),r=rl(e,0).mul(el),a=rl(e,8),s=rl(e,t-8).mul(n),i=rl(e,t-16).mul(el),o=sl(r.add(a),43).add(sl(s,30)).add(i),l=il(o,r.add(sl(a.add(el),18)).add(s),n),u=rl(e,16).mul(n),c=rl(e,24),d=o.add(rl(e,t-32)).mul(n),h=l.add(rl(e,t-24)).mul(n);return il(sl(u.add(c),43).add(sl(d,30)).add(h),u.add(sl(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(Zo).add(113),s=tl(a.mul(el).add(113)).mul(el),i=[Yo.UZERO,Yo.UZERO],o=[Yo.UZERO,Yo.UZERO];r=r.mul(el).add(rl(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=sl(r.add(a).add(i[0]).add(rl(e,l+8)),37).mul(Zo),a=sl(a.add(i[1]).add(rl(e,l+48)),42).mul(Zo),r=r.xor(o[1]),a=a.add(i[0]).add(rl(e,l+40)),s=sl(s.add(o[0]),33).mul(Zo),i=ol(e,l,i[1].mul(Zo),r.add(o[0])),o=ol(e,l+32,s.add(o[1]),a.add(rl(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);const d=Zo.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=sl(r.add(a).add(i[0]).add(rl(e,l+8)),37).mul(d),a=sl(a.add(i[1]).add(rl(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(rl(e,l+40))),s=sl(s.add(o[0]),33).mul(d),i=ol(e,l,i[1].mul(d),r.add(o[0])),o=ol(e,l+32,s.add(o[1]),a.add(rl(e,l+16))),[s,r]=[r,s],il(il(i[0],o[0],d).add(tl(a).mul(Jo)).add(s),il(i[1],o[1],d).add(r),d)}function ul(e,t){return"string"===t?hl(e):cl([e],t)}function cl(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ml(e)),wa().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function dl(){return wa().platform.now()}function hl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",wa().platform.encode(e,t)}function pl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",wa().platform.decode(e,t)}function fl(e){return null!=wa().platform.isTypedArray?wa().platform.isTypedArray(e):Ko(e)}function ml(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||ba(e)||null==e||fl(e)&&n)t.push(e);else if(Array.isArray(e)||fl(e))for(let r=0;r<e.length;++r)ml(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)ml(e[a],t,n)}return t}class gl{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new yl)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let s;const i=dl();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();s=Promise.resolve({kernelMs:dl()-i})}if(wa().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{bl(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function bl(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class yl{logKernelProfile(e,t,n,r,a,s){const i="number"===typeof r?Kr(`${r}ms`,9):r.error,o=Kr(e,25),l=t.rank,u=t.size,c=Kr(t.shape.toString(),14);let d="";for(const h in a){const e=a[h];if(null!=e){const n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function xl(e,t,n,r){const a=la(t),s=function(e,t,n,r){const a=Vr(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?Sl(e):e;if(o>1)for(let u=0;u<a/s;u++){const e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],vl(l[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,o=kl(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function vl(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:ra(e)?`'${e}'`:"bool"===n?wl(e):parseFloat(e.toFixed(7)).toString(),Kr(r,t)}function wl(e){return 0===e?"false":"true"}function kl(e,t,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[vl(Sl(e)[0],0,n)]}return"bool"===n?[wl(e[0])]:[e[0].toString()]}if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=Sl(r),s=Sl(s)),["["+r.map(((e,t)=>vl(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>vl(e,a[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Sl(e):Array.from(e)).map(((e,t)=>vl(e,a[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>20){for(let t=0;t<3;t++){const r=t*d,s=r+d;h.push(...kl(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=o-3;t<o;t++){const r=t*d,s=r+d;h.push(...kl(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){const t=m*d,r=t+d;h.push(...kl(e.slice(t,r),u,n,c,a,m===o-1))}const p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function Sl(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Il{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Vr(e),null!=n){const e=n.length;Wr(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ea(t,this.size),this.strides=la(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Wr(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const s of t){if(s<0||s>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Nl().makeTensor(this.values,this.shape,this.dtype)}}let Nl=null,Cl=null,Tl=null;class El{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Vr(e),this.strides=la(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Cl.buffer(this.shape,this.dtype,e)}bufferSync(){return Cl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ca(this.shape,e,"complex64"===this.dtype)}arraySync(){return ca(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Nl().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>pl(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Nl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Nl().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>pl(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Nl().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Nl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Cl.print(this,e)}clone(){return this.throwIfDisposed(),Cl.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return xl(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Cl.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Nl().makeVariable(this,e,t,n)}}function $l(){return Na("Tensor",(()=>El))}Object.defineProperty(El,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),$l();class Rl extends El{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Gr(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Nl().disposeTensor(this),this.dataId=e.dataId,Nl().incRef(this,null)}dispose(){Nl().disposeVariable(this),this.isDisposedInternal=!0}}var _l,Al,Fl,Dl,Ol;Object.defineProperty(Rl,Symbol.hasInstance,{value:e=>e instanceof El&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(_l||(_l={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Al||(Al={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Fl||(Fl={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Dl||(Dl={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ol||(Ol={}));const Ll={float32:Dl,int32:Al,bool:Fl,complex64:Ol};function Ml(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Ll[e][t]}function zl(e){return Ml(e,"int32")}function Pl(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Bl(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Wl(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ml(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ul(e,t){return t.some((t=>t.id===e.id))}function jl(e){const t=[];return Vl(e,t,new Set),t}function Vl(e,t,n){if(null==e)return;if(e instanceof El)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=e;for(const s in a){const e=a[s];n.has(e)||(n.add(e),Vl(e,t,n))}}function Gl(e){return null!=e.kernelName}class Hl{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ql{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Hl}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(zo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new gl(this.backendInstance),!0}setupRegisteredKernels(){Vo(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Vo(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Or||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,zo(`Initialization of backend ${e} failed`),zo(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return zo(`Initialization of backend ${e} failed`),zo(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return ql.nextTensorId++}nextVariableId(){return ql.nextVariableId++}clone(e){const t=Xl.runKernel(Ws,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Xl.runKernel(Xa,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Uo(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Gl(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Gl(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const l=Uo(t,this.backendName);Wr(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=Gl(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()})),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=jo(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(Wr(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const i=n.filter(((e,t)=>a[t]));return s.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&ra(e[0])&&(a=e.map((e=>hl(e))));const s=r.write(a,t,n),i=new El(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,s=new El(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new Rl(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*na(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Rl||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*na(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=jo(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=ha(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=jl(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Wr(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Wr(a instanceof El,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],s=n.inputs;for(const e in s){const i=s[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(a[t.id]&&i[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=da(Vr(e),"float32");return Xl.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],i=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(i);for(const t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const i=s.inputs[t];if(!Gr(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{const t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),Yl);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return Wr(ia(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;Wr(r.every((e=>e instanceof El)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),Wr(s.value instanceof El,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Wr(ia(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];Wr(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Wr(a.every((e=>e instanceof El)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=dl(),n=await this.backend.time(e);return n.wallMs=dl()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Hl;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Kl(){const e=Ia();if(null==e._tfengine){const t=new xa(e);e._tfengine=new ql(t)}var t;return t=e._tfengine.ENV,Sa=t,Nl=()=>e._tfengine,e._tfengine}ql.nextTensorId=0,ql.nextVariableId=0;const Xl=Kl();function Yl(e,t){const n={a:e,b:t};return Xl.runKernel($a,n)}let Ql;function Jl(e){if(void 0!==Ql)return Ql;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Zl(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const eu=wa();function tu(e,t){let n=e;if(fl(e))return"string"===t?[]:[e.length];if(Pl(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Bl(e))return[e.buffer.size/(null==t?4:na(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||fl(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&wa().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&nu(e,r,[]),r}function nu(e,t,n){if(n=n||[],!Array.isArray(e)&&!fl(e))return void Wr(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Wr(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Wr(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let a=0;a<e.length;++a)nu(e[a],r,n.concat(a))}function ru(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function au(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof $l())return ru(r,e.dtype,t,n),e;let a=sa(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),ru(r,a,t,n),null==e||!fl(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=tu(e,a);fl(e)||Array.isArray(e)||(e=[e]);const i="string"!==a?cl(e,a):ml(e,[],!0);return Xl.makeTensor(i,s,a)}function su(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>au(e,`${t}[${a}]`,n,r)))}eu.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),eu.registerFlag("IS_BROWSER",(()=>Zl())),eu.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),eu.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),eu.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),eu.registerFlag("PROD",(()=>!1)),eu.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>eu.getBool("DEBUG"))),eu.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),eu.registerFlag("IS_TEST",(()=>!1)),eu.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>eu.getBool("DEBUG"))),eu.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),eu.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),eu.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function iu(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){Xl.startScope(n);try{const e=r(...arguments);return ba(e)&&console.error("Cannot return a Promise inside of tidy."),Xl.endScope(e),e}catch(e){throw Xl.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const ou=iu({complex_:function(e,t){const n=au(e,"real","complex"),r=au(t,"imag","complex");Ur(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:n,imag:r};return Xl.runKernel(Ja,a)}});function lu(e,t,n,r){if(null==r)r=sa(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Bl(e)||Pl(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Xl.backend.createTensorFromGPUData(e,t||n,r)}if(!fl(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){fa(t);const e=Vr(t),r=Vr(n);Wr(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){const e=n[a],r=a!==n.length-1||e!==Vr(t.slice(a));Wr(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return fl(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?cl(e,r):ml(e,[],!0),Xl.makeTensor(e,t,r)}function uu(e,t,n){return lu(e,t,tu(e,n),n)}class cu{static join(e){return new cu(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>fl(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),a=new Uint8Array(r);let s=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function du(){return Xl}function hu(){return Xl.memory()}function pu(e,t){return Xl.tidy(e,t)}function fu(e){jl(e).forEach((e=>e.dispose()))}function mu(e){return Xl.keep(e)}function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Xl.registerBackend(e,t,n)}function bu(){return Xl.backend}Tl=function(e){wa().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};async function yu(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){const i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let a=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=4,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:xu(await Promise.all(r)),specs:n}}function xu(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}const vu="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function wu(e){return vu?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function ku(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function Su(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}(e,n,r)}function Iu(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:wu(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:wu(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new cu(e.weightData).byteLength}}function Nu(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Cu{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Cu.instance&&(Cu.instance=new Cu),Cu.instance}static registerSaveRouter(e){Cu.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Cu.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Cu.getHandlers(e,"save")}static getLoadHandlers(e,t){return Cu.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Cu.getInstance().loadRouters:Cu.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const Tu="tensorflowjs",Eu="models_store",$u="model_info_store";function Ru(){if(!wa().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function _u(e){const t=e.result;t.createObjectStore(Eu,{keyPath:"modelPath"}),t.createObjectStore($u,{keyPath:"modelPath"})}class Au{constructor(e){if(this.indexedDB=Ru(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(Tu,1);r.onupgradeneeded=()=>_u(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(Eu,"readonly"),r=t.objectStore(Eu).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=cu.join(t.weightData);const r=Iu(t),i=a.transaction($u,"readwrite");let o,l,u=i.objectStore($u);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}o.onsuccess=()=>{l=a.transaction(Eu,"readwrite");const o=l.objectStore(Eu);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(s){return n(s)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore($u);const t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(c.error)),t.onerror=e=>(a.close(),n(c.error))}},o.onerror=e=>(a.close(),n(o.error)),i.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}Au.URL_SCHEME="indexeddb://";const Fu=e=>{return wa().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Au.URL_SCHEME)?(t=e.slice(Au.URL_SCHEME.length),new Au(t)):null;var t};Cu.registerSaveRouter(Fu),Cu.registerLoadRouter(Fu);class Du{constructor(){this.indexedDB=Ru()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Tu,1);n.onupgradeneeded=()=>_u(n),n.onsuccess=()=>{const r=n.result,a=r.transaction($u,"readonly"),s=a.objectStore($u).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Au.URL_SCHEME)?t.slice(Au.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(Tu,1);r.onupgradeneeded=()=>_u(r),r.onsuccess=()=>{const a=r.result,s=a.transaction($u,"readwrite"),i=s.objectStore($u),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),s=()=>{l=a.transaction(Eu,"readwrite");const r=l.objectStore(Eu).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(o.error))}},o.onerror=e=>(a.close(),n(o.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}const Ou="/",Lu="tensorflowjs_models",Mu="info",zu="model_topology",Pu="weight_specs",Bu="weight_data",Wu="model_metadata";function Uu(e){return{info:[Lu,e,Mu].join(Ou),topology:[Lu,e,zu].join(Ou),weightSpecs:[Lu,e,Pu].join(Ou),weightData:[Lu,e,Bu].join(Ou),modelMetadata:[Lu,e,Wu].join(Ou)}}function ju(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Vu(e){const t=e.split(Ou);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ou)}class Gu{constructor(e){if(!wa().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Uu(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=Iu(e),s=cu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(vu)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw ju(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(vu){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(s),t}}Gu.URL_SCHEME="localstorage://";const Hu=e=>{return wa().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Gu.URL_SCHEME)?(t=e.slice(Gu.URL_SCHEME.length),new Gu(t)):null;var t};Cu.registerSaveRouter(Hu),Cu.registerLoadRouter(Hu);class qu{constructor(){Wr(wa().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Wr("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Lu+Ou,n=Ou+Mu;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){e[Vu(a)]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;const n=Uu(e=(t=e).startsWith(Gu.URL_SCHEME)?t.slice(Gu.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return ju(n),r}}const Ku="://";class Xu{constructor(){this.managers={}}static getInstance(){return null==Xu.instance&&(Xu.instance=new Xu),Xu.instance}static registerManager(e,t){Wr(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Ku)&&(e=e.slice(0,e.indexOf(Ku))),Wr(e.length>0,(()=>"scheme must not be an empty string."));const n=Xu.getInstance();Wr(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Xu.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Xu.getInstance().managers)}}class Yu{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&wa().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Ko(e)}}if(wa().get("IS_BROWSER")){wa().setPlatform("browser",new Yu);try{Xu.registerManager(Gu.URL_SCHEME,new qu)}catch(DW){}try{Xu.registerManager(Au.URL_SCHEME,new Du)}catch(DW){}}const Qu=()=>n(817);let Ju;class Zu{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=wa().global.fetch?wa().global.fetch(e,t):(null==Ju&&(Ju=Qu()),Ju(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function ec(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",fa(e),new Il(e,t,n)}wa().get("IS_NODE")&&!wa().get("IS_BROWSER")&&wa().setPlatform("node",new Zu);const tc=iu({cast_:function(e,t){const n=au(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return Xl.runKernel(Xa,r,a)}});const nc=iu({clone_:function(e){const t={x:au(e,"x","clone","string_or_numeric")};return Xl.runKernel(Ws,t)}});Kl();Cl={buffer:ec,cast:tc,clone:nc,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const rc=iu({add_:function(e,t){let n=au(e,"a","add"),r=au(t,"b","add");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel($a,a)}});const ac=iu({floorDiv_:function(e,t){let n=au(e,"a","floorDiv"),r=au(t,"b","floorDiv");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel(Os,a)}});const sc=iu({div_:function(e,t){let n=au(e,"a","div"),r=au(t,"b","div");if([n,r]=Wl(n,r),"int32"===n.dtype&&"int32"===r.dtype)return ac(n,r);const a={a:n,b:r};return Xl.runKernel(ks,a,{})}});const ic=iu({mul_:function(e,t){let n=au(e,"a","mul"),r=au(t,"b","mul");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel(bi,a)}});const oc=iu({sqrt_:function(e){const t={x:au(e,"x","sqrt","float32")};return Xl.runKernel(ro,t)}});const lc=iu({square_:function(e){const t=au(e,"x","square");return Xl.runKernel("Square",{x:t},{})}});const uc=iu({zerosLike_:function(e){const t={x:au(e,"x","zerosLike")};return Xl.runKernel(_o,t)}});function cc(e){return Xl.customGrad(e)}function dc(e,t){if((fl(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&fl(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return lu(e,[],[],t)}const hc=new Map,pc=new Map;class fc{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class mc{constructor(){this.classNameMap={}}static getMap(){return null==mc.instance&&(mc.instance=new mc),mc.instance}static register(e){mc.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function gc(e,t,n){Wr(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Wr("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Wr(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return mc.register(e),hc.set(r,e),pc.set(e,r),e}class bc extends fc{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return fu(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Wr(ia(e),(()=>"The f passed in variableGrads(f) must be a function")),Wr(null==t||Array.isArray(t)&&t.every((e=>e instanceof Rl)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Xl.registeredVariables)t.push(Xl.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Wr(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));const{value:s,grads:i}=Xl.gradients(e,t,null,!0);Wr(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Wr(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}(e,t)}dispose(){null!=this.iterations_&&fu(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:dc(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(bc,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class yc extends bc{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Xl.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Xl.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:pu((()=>uc(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:pu((()=>uc(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;pu((()=>{const e=rc(ic(i,this.rho),ic(lc(s),1-this.rho)),t=ic(sc(oc(rc(o,this.epsilon)),oc(rc(i,this.epsilon))),s),n=rc(ic(o,this.rho),ic(lc(t),1-this.rho));i.assign(e),o.assign(n);const a=rc(ic(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(fu(this.accumulatedGrads.map((e=>e.variable))),fu(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function xc(e,t,n){fa(e);const r={shape:e,value:t,dtype:n=n||sa(t)};return Xl.runKernel(As,{},r)}class vc extends bc{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Xl.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:pu((()=>xc(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable;pu((()=>{const e=rc(s,lc(a));s.assign(e);const t=rc(ic(sc(a,oc(rc(e,Xl.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&fu(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const wc=iu({pow_:function(e,t){let n=au(e,"base","pow"),r=au(t,"exp","pow");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel(Ti,a)}});const kc=iu({sub_:function(e,t){let n=au(e,"a","sub"),r=au(t,"b","sub");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel(wo,a)}});class Sc extends bc{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],pu((()=>{this.accBeta1=dc(t).variable(),this.accBeta2=dc(n).variable()})),null==r&&(this.epsilon=Xl.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);pu((()=>{const n=kc(1,this.accBeta1),r=kc(1,this.accBeta2);t.forEach(((t,a)=>{const s=Xl.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:pu((()=>uc(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:pu((()=>uc(s).variable(i)))});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=rc(ic(l,this.beta1),ic(o,1-this.beta1)),d=rc(ic(u,this.beta2),ic(lc(o),1-this.beta2)),h=sc(c,n),p=sc(d,r);l.assign(c),u.assign(d);const f=rc(ic(sc(h,rc(oc(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(ic(this.accBeta1,this.beta1)),this.accBeta2.assign(ic(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&fu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&fu(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),pu((()=>{this.accBeta1.assign(wc(this.beta1,this.iterations_+1)),this.accBeta2.assign(wc(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Ic=iu({abs_:function(e){const t=au(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Xl.runKernel(Za,e)}{const e={x:t};return Xl.runKernel(Ca,e)}}});function Nc(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function Cc(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function Tc(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}const Ec=iu({maximum_:function(e,t){let n=au(e,"a","maximum"),r=au(t,"b","maximum");[n,r]=Wl(n,r),"bool"===n.dtype&&(n=tc(n,"int32"),r=tc(r,"int32")),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(si,a)}});class $c extends bc{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],pu((()=>{this.iteration=dc(0).variable(),this.accBeta1=dc(t).variable()})),null==r&&(this.epsilon=Xl.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);pu((()=>{const n=kc(1,this.accBeta1),r=sc(-this.learningRate,rc(ic(this.iteration,this.decay),1));t.forEach(((t,a)=>{const s=Xl.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:uc(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:uc(s).variable(i)});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=rc(ic(l,this.beta1),ic(o,1-this.beta1)),d=ic(u,this.beta2),h=Ic(o),p=Ec(d,h);l.assign(c),u.assign(p);const f=rc(ic(sc(r,n),sc(c,rc(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(rc(this.iteration,1)),this.accBeta1.assign(ic(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&fu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&fu(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Rc extends bc{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=Xl.registeredVariables[t];pu((()=>{const e=rc(ic(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=mu(dc(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class _c extends Rc{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=dc(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Xl.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:pu((()=>uc(r).variable(e)))}}const a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&pu((()=>{let e;const t=rc(ic(this.m,a),s);e=this.useNesterov?rc(ic(this.c,rc(s,ic(t,this.m))),r):rc(ic(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&fu(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Ac extends bc{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Xl.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Xl.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:pu((()=>uc(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:pu((()=>uc(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:pu((()=>uc(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;pu((()=>{const e=rc(ic(i,this.decay),ic(lc(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=rc(ic(t,this.decay),ic(s,1-this.decay)),l=sc(ic(s,this.learningRate),oc(kc(e,rc(lc(a),this.epsilon)))),u=rc(ic(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);const c=kc(r,u);r.assign(c)}else{const e=rc(ic(i,this.decay),ic(lc(s),1-this.decay)),t=rc(ic(o,this.momentum),sc(ic(s,this.learningRate),oc(rc(e,this.epsilon))));i.assign(e),o.assign(t);const n=kc(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&fu(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&fu(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&fu(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Fc=[yc,vc,Sc,$c,_c,Ac,Rc];function Dc(e){return new Promise((e=>setTimeout(e))).then(e)}class Oc{constructor(e){if(!wa().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Oc.URL_SCHEME)&&(e=e.slice(Oc.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=cu.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=ku(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await Dc((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Dc((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Iu(e)}}}}Oc.URL_SCHEME="downloads://";function Lc(e,t,n,r){!function(e){Wr(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Wr(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Wr(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Wr(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((s=>(s.then((s=>{const i=n+ ++a/e.length*(r-n);return t(i),s})),s))))}async function Mc(e,t){null==t&&(t={});const n=null==t.fetchFunc?wa().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await Lc(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await Lc(a,t.onProgress,.5,1)}Cu.registerSaveRouter((e=>wa().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Oc.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Oc(e)}(e.slice(Oc.URL_SCHEME.length)):null));class zc{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Wr("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=wa().platform.fetch,Wr(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Wr(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=ku(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=cu.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Iu(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(FW){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return Su(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Nu(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?wa().platform.fetch:t.fetchFunc;let a,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){if(!a){const n=(await r(e[s],t.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:o,value:l}=await a.read();if(!o)return void n.enqueue(l);s++,a=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){const t=await this.getWeightUrls(e);return[Nu(e),await Mc(t,this.loadOptions)]}}function Pc(e){return null!=e.match(zc.URL_SCHEME_REGEX)}zc.URL_SCHEME_REGEX=/^https?:\/\//;const Bc=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Pc(e))):Pc(e),n)return Wc(e,t)}return null};function Wc(e,t){return new zc(e,t)}Cu.registerSaveRouter(Bc),Cu.registerLoadRouter(Bc);const Uc=-2,jc=-1;function Vc(e,t,n){const r=e.shape.length;Wr(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Wr(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)Wr(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function Gc(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Hc(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function qc(e,t,n,r){const a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function Kc(e,t,n){return n<=e?n:n-(t-1)}function Xc(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Yc(e,t,n,r,a,s,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=Qc(i,l,u,r,e),d=Jc(o,l,u,a,e),h=qc(s,l,u,e)}else for(let p=0;p<u;p++)c[p]=ed(i,r,s,e,p,l),d[p]=td(o,a,s,e,p,l),h[p]=Zc(s,p,l);return{begin:c,end:d,strides:h}}function Qc(e,t,n,r,a){const s=[...a],i=Xc(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const a=Kc(t,n,o);let i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function Jc(e,t,n,r,a){const s=[...a],i=Xc(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const a=Kc(t,n,o);let i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){const e=a[o];s[o]<0&&(s[o]+=e),s[o]=zr(0,s[o],a[o])}return s}function Zc(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function ed(e,t,n,r,a,s){let i=t[a];const o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return i<0&&(i+=l),i=zr(0,i,l-1),i}function td(e,t,n,r,a,s){let i=t[a];const o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return i<0&&(i+=l),i=o>0?zr(0,i,l):zr(-1,i,l-1),i}function nd(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function rd(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function ad(e,t,n){let r;const a=e.shape.length;let s;return r="number"===typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{Wr(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(Wr(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,s]}function sd(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let y=0;y<d.dims;y++)c&&0!==(1<<y&o)&&d.numAddAxisAfterEllipsis++,1<<y&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Uc),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(jc),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],b=[];for(let y=0;y<e.length;++y){if(0===h.strides[y])throw Error(`strides[${y}] must be non-zero`);const t=!!(h.shrinkAxisMask&1<<y),n=e[y];if(-1===n){g.push(t?1:-1);continue}const r=[h.beginMask&1<<y,h.endMask&1<<y],a=[h.strides[y]>0?0:-1,h.strides[y]>0?n:n-1];if(t&&h.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[y];const s=!!(h.beginMask&1<<y&&h.endMask&1<<y);if(h.beginValid&&h.endValid){if(t){const e=h.begin[y]<0?n+h.begin[y]:h.begin[y];if(h.begin[y]=e,h.end[y]=h.begin[y]+1,e<0||e>=n)throw Error(`slice index ${h.begin[y]} of dimension ${y} out of bounds.`)}else h.begin[y]=id(h.begin[y],0,h.strides[y],n,r,a),h.end[y]=id(h.end[y],1,h.strides[y],n,r,a);const e=1===h.strides[y]&&0===h.begin[y]&&h.end[y]===n;p=p&&e,f=f&&(0===y&&1===h.strides[y]||e)}else p=p&&1===h.strides[y]&&s,f=f&&(0===y&&1===h.strides[y]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[y]-h.begin[y],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[y]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==h.strides[y]<0?0:Math.trunc(i/h.strides[y])+(i%h.strides[y]!==0?1:0),g.push(e)}else g.push(-1)}for(let y=0;y<h.finalShapeGatherIndices.length;++y){const e=h.finalShapeGatherIndices[y];e>=0?b.push(g[e]):e===Uc&&b.push(1)}return{finalShapeSparse:b.filter(((e,t)=>h.finalShapeGatherIndices[t]!==Uc)),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function id(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}const od=iu({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:au(e,"x","all","bool")},a={axis:t,keepDims:n};return Xl.runKernel(_a,r,a)}});const ld=iu({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:au(e,"x","any","bool")},a={axis:t,keepDims:n};return Xl.runKernel(Aa,r,a)}});const ud=iu({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:au(e,"x","argMax")},r={axis:t};return Xl.runKernel(Fa,n,r)}});function cd(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return pd(e,[...t,e[3]],n,s,r,null,null,Sd(a))}function dd(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=gd(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return pd(e,u,n,r,a,s,!1,i)}function hd(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=bd(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[o,l,u,e[1],e[1]]}return fd(e,c,n,r,a,!1,d,s)}function pd(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,g]=gd(n),[b,y]=gd(r),x=yd(h,b),v=yd(p,y),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,a,s,i,o,l){let u,c,d;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=md(e,t,n));const s=e[0],i=e[1],o=xd((s-t+2*r)/n+1,a),l=xd((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);const e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=xd((t-s+h+p)/r+1,o),d=xd((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,m,g,x,v,s,o),I=i?f*d:f;let N;return"channelsFirst"===o?N=[l,I,k,S]:"channelsLast"===o&&(N=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function fd(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[p,f,m,,g]=t,[b,y,x]=bd(n),[v,w,k]=bd(r),S=yd(p,v),I=yd(f,w),N=yd(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:$}=function(e,t,n,r,a,s,i,o,l,u,c){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,a,s){null==a&&(a=md(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=xd((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);const e=(h-1)*a+o-t,c=(p-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),b=e-g,y=Math.floor(c/2),x=c-y,v=Math.floor(m/2);d={top:y,bottom:x,left:v,right:m-v,front:g,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,b,y,x,S,I,N,o),R=s?g*h:g;let _;return"channelsFirst"===i?_=[l,R,T,E,$]:"channelsLast"===i&&(_=[l,T,E,$,R]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:$,outChannels:R,padInfo:C,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:_,filterShape:t}}function md(e,t,n){const r=yd(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function gd(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function bd(e){return"number"===typeof e?[e,e,e]:e}function yd(e,t){return t<=1?e:e+(e-1)*(t-1)}function xd(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function vd(e){const[t,n,r]=gd(e);return 1===t&&1===n&&1===r}function wd(e,t){return vd(e)||vd(t)}function kd(e){return gd(e).every((e=>e>0))}function Sd(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Id(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)Wr(Hr(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Wr(Hr(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Nd=iu({reshape_:function(e,t){const n={x:au(e,"x","reshape","string_or_numeric")},r={shape:t};return Xl.runKernel(Mi,n,r)}});const Cd=iu({avgPool_:function(e,t,n,r,a){const s=au(e,"x","avgPool","float32");Wr(wd(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=Nd(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wr(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Id("avgPool",r,a);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a};let c=Xl.runKernel(Ba,l,u);return c=tc(c,s.dtype),o?Nd(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Td=iu({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=au(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=Nd(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Wr(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Wr("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Wr("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Id("avgPool3d",r,a);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let d=Xl.runKernel(Ua,u,c);return d=tc(d,o.dtype),l?Nd(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ed=iu({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);const i=au(e,"x","batchNorm"),o=au(t,"mean","batchNorm"),l=au(n,"variance","batchNorm");let u,c;null!=a&&(u=au(a,"scale","batchNorm")),null!=r&&(c=au(r,"offset","batchNorm")),Wr(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Wr(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Wr(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?Nd(e,[1,1,1,e.size]):2===e.rank?Nd(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Nd(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:s},p=Xl.runKernel(Ls,d,h);return Nd(p,i.shape)}});const $d=iu({batchNorm2d_:function(e,t,n,r,a,s){const i=au(e,"x","batchNorm"),o=au(t,"mean","batchNorm"),l=au(n,"variance","batchNorm");let u,c;return null!=a&&(u=au(a,"scale","batchNorm")),null!=r&&(c=au(r,"offset","batchNorm")),Wr(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Wr(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Wr(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Wr(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Wr(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),Ed(i,o,l,c,u,s)}});const Rd=iu({batchNorm3d_:function(e,t,n,r,a,s){const i=au(e,"x","batchNorm"),o=au(t,"mean","batchNorm"),l=au(n,"variance","batchNorm");let u,c;return null!=a&&(u=au(a,"scale","batchNorm")),null!=r&&(c=au(r,"offset","batchNorm")),Wr(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Wr(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Wr(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Wr(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Wr(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),Ed(i,o,l,c,u,s)}});const _d=iu({batchNorm4d_:function(e,t,n,r,a,s){const i=au(e,"x","batchNorm"),o=au(t,"mean","batchNorm"),l=au(n,"variance","batchNorm");let u,c;return null!=a&&(u=au(a,"scale","batchNorm")),null!=r&&(c=au(r,"offset","batchNorm")),Wr(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Wr(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Wr(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Wr(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Wr(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),Ed(i,o,l,c,u,s)}});const Ad=iu({broadcastTo_:function(e,t){let n=au(e,"broadcastTo","x");const r=n.shape;if(fa(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Nd(n,e)}const a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return nc(n);const i={x:n},o={reps:s};return Xl.runKernel(Io,i,o)}});const Fd=iu({clipByValue_:function(e,t,n){const r=au(e,"x","clipByValue");if(Wr(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return xc(r.shape,t,r.dtype);const a={x:r},s={clipValueMin:t,clipValueMax:n};return Xl.runKernel(Qa,a,s)}});const Dd=iu({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Wr(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=su(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return nc(n[0]);const r=n,a={axis:t};return Xl.runKernel(es,r,a)}});const Od=iu({concat1d_:function(e){return Dd(e,0)}});const Ld=iu({concat2d_:function(e,t){return Dd(e,t)}});const Md=iu({concat3d_:function(e,t){return Dd(e,t)}});const zd=iu({concat4d_:function(e,t){return Dd(e,t)}});const Pd=iu({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=au(e,"x","conv2d","float32"),l=au(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Nd(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Wr(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Wr(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Id("conv2d",r,i);const d="NHWC"===a?u.shape[3]:u.shape[1];Wr(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),Wr(wd(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Wr(kd(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Wr(kd(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Xl.runKernel(ts,h,p);return c?Nd(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Bd=iu({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=au(e,"x","conv1d"),l=au(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Nd(o,[1,o.shape[0],o.shape[1]])),Wr(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Wr(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Id("conv1d",r,i),Wr(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Wr(wd(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),Wr(kd(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Wr(kd(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Wr("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));const d=Nd(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=Nd(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Pd(h,d,[1,n],r,"NHWC",[1,s],i);return Nd(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Wd=iu({conv2DBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Wr(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Nd(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Wr(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Wr(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Wr(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];Wr(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Wr(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),Id("conv2dDerInput",a,i);const h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=Xl.runKernel(rs,h,p);return u?Nd(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Ud=iu({conv2dTranspose_:function(e,t,n,r,a,s){const i=au(e,"x","conv2dTranspose"),o=au(t,"filter","conv2dTranspose");return Wd(n,i,o,r,a,"NHWC",s)}});const jd=iu({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=au(e,"x","conv3d"),o=au(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=Nd(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Wr(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Wr(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Wr(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Wr(wd(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Wr("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),Wr(kd(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Wr(kd(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=Xl.runKernel(as,c,d);return u?Nd(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Vd=iu({conv3DBackpropInput_:function(e,t,n,r,a){Wr(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=Nd(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const l=s[4],u=i.shape[4];Wr(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),Wr(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Wr(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Wr(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Wr(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=Xl.runKernel(is,c,d);return o?Nd(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Gd=iu({conv3dTranspose_:function(e,t,n,r,a){const s=au(e,"x","conv3dTranspose"),i=au(t,"filter","conv3dTranspose");return Vd(n,s,i,r,a)}});const Hd=iu({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=au(e,"x","denseBincount"),s=au(t,"weights","denseBincount");Wr("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),Wr(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),Wr(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Wr(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));const i={x:a,weights:s},o={size:n,binaryOutput:r};return Xl.runKernel(hs,i,o)}});const qd=iu({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=au(e,"x","depthwiseConv2d","float32"),l=au(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Nd(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Wr(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Wr(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===a?u.shape[3]:u.shape[1];Wr(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Id("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Xl.runKernel(fs,h,p);return c?Nd(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Kd=iu({elu_:function(e){const t={x:au(e,"x","elu","float32")};return Xl.runKernel(Is,t)}});const Xd=iu({equal_:function(e,t){let n=au(e,"a","equal","string_or_numeric"),r=au(t,"b","equal","string_or_numeric");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(Ts,a)}});const Yd=iu({erf_:function(e){let t=au(e,"x","erf");Wr("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=tc(t,"float32"));const n={x:t};return Xl.runKernel(Cs,n)}});const Qd=iu({exp_:function(e){const t={x:au(e,"x","exp")};return Xl.runKernel(Es,t)}});const Jd=iu({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=au(e,"x","expandDims","string_or_numeric");Wr(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return Xl.runKernel($s,r,a)}});const Zd=iu({tile_:function(e,t){const n=au(e,"x","tile","string_or_numeric");Wr(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},a={reps:t};return Xl.runKernel(Io,r,a)}});const eh=iu({eye_:function(e,t,n){null==t&&(t=e);const r=ec([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const s=Nd(r.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return Zd(Jd(s,0),[n[0],1,1]);if(2===n.length)return Zd(Jd(Jd(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Zd(Jd(Jd(Jd(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const th=iu({floor_:function(e){const t={x:au(e,"x","floor","float32")};return Xl.runKernel(Ds,t)}});const nh=iu({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:au(e,"x","gather"),indices:au(t,"indices","gather","int32")},s={axis:n,batchDims:r};return Xl.runKernel(Ms,a,s)}});const rh=iu({greater_:function(e,t){let n=au(e,"a","greater","string_or_numeric"),r=au(t,"b","greater","string_or_numeric");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(Ps,a)}});const ah=iu({greaterEqual_:function(e,t){let n=au(e,"a","greaterEqual","string_or_numeric"),r=au(t,"b","greaterEqual","string_or_numeric");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(Bs,a)}});const sh=iu({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:au(e,"x","leakyRelu")},r={alpha:t};return Xl.runKernel(qs,n,r)}});const ih=iu({log_:function(e){const t={x:au(e,"x","log","float32")};return Xl.runKernel(Qs,t)}});const oh=iu({log1p_:function(e){const t={x:au(e,"x","log1p")};return Xl.runKernel(Js,t)}});const lh=iu({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:au(e,"x","max")},a={reductionIndices:t,keepDims:n};return Xl.runKernel(ai,r,a)}});const uh=iu({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=au(e,"x","sum");"bool"===r.dtype&&(r=tc(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return Xl.runKernel(ao,a,s)}});const ch=iu({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=au(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=cc(((e,n)=>{const r=lh(e,t,!0),a=kc(e,r),s=kc(tc(a,"float32"),ih(uh(Qd(a),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[r]=n,a=Qd(r);return kc(e,ic(uh(e,t,!0),a))}}}));return r(n)}});function dh(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function hh(e,t,n){const r=e.length+t.length,a=[];let s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function ph(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function fh(e,t){return hh(e,t.map((e=>1)),t)}function mh(e,t,n){Wr(dh(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function gh(e,t){if(dh(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function bh(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function yh(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const xh=iu({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=au(e,"x","logSumExp"),a=Qr(t,r.shape),s=lh(r,a,!0),i=kc(r,s),o=Qd(i),l=uh(o,a),u=ih(l),c=rc(Nd(s,u.shape),u);if(n){const e=fh(c.shape,a);return Nd(c,e)}return c}});const vh=iu({logicalAnd_:function(e,t){const n=au(e,"a","logicalAnd","bool"),r=au(t,"b","logicalAnd","bool");Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(Zs,a)}});const wh=iu({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=au(e,"a","matMul"),s=au(t,"b","matMul");[a,s]=Wl(a,s);const i={a:a,b:s},o={transposeA:n,transposeB:r};return Xl.runKernel(Va,i,o)}});const kh=iu({maxPool_:function(e,t,n,r,a){const s=au(e,"x","maxPool");let i=s,o=!1;3===s.rank&&(o=!0,i=Nd(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wr(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Wr(wd(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Id("maxPool",r,a);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=Xl.runKernel(ii,l,u);return o?Nd(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Sh=iu({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=au(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=Nd(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Wr(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Wr("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Id("maxPool3d",r,a);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Xl.runKernel(li,u,c);return l?Nd(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ih=iu({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:au(e,"x","mean")},a={axis:t,keepDims:n};return Xl.runKernel(di,r,a)}});const Nh=iu({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:au(e,"x","min")},a={axis:t,keepDims:n};return Xl.runKernel(hi,r,a)}});const Ch=iu({minimum_:function(e,t){let n=au(e,"a","minimum"),r=au(t,"b","minimum");[n,r]=Wl(n,r),"bool"===n.dtype&&(n=tc(n,"int32"),r=tc(r,"int32")),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(pi,a)}});const Th=iu({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Qr(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=au(e,"x","moments")).shape),r=Ih(e,n,t);let a=r.shape;t||(a=fh(r.shape,n));const s=lc(kc(tc(e,"float32"),Nd(r,a)));return{mean:r,variance:Ih(s,n,t)}}});const Eh=iu({neg_:function(e){const t={x:au(e,"x","neg")};return Xl.runKernel(yi,t)}});const $h=iu({notEqual_:function(e,t){let n=au(e,"a","notEqual","string_or_numeric"),r=au(t,"b","notEqual","string_or_numeric");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(xi,a)}});const Rh=iu({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s={indices:au(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return Xl.runKernel(Ii,s,i)}});function _h(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(fa(e),"complex64"===t){const t=_h(e,"float32"),n=_h(e,"float32");return ou(t,n)}const n=ha(Vr(e),t);return Xl.makeTensor(n,e,t)}function Ah(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(fa(e),"complex64"===t){const t=Ah(e,"float32"),n=_h(e,"float32");return ou(t,n)}const n=da(Vr(e),t);return Xl.makeTensor(n,e,t)}const Fh=iu({onesLike_:function(e){const t={x:au(e,"x","onesLike")};return Xl.runKernel(Si,t)}});const Dh=iu({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=au(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:n},s={x:r};return Xl.runKernel(Ci,s,a)}});const Oh=iu({prelu_:function(e,t){const n={x:au(e,"x","prelu"),alpha:au(t,"alpha","prelu")};return Xl.runKernel(Ei,n)}});var Lh=n(334);class Mh{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=Lh.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class zh{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Lh.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ph=iu({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(fa(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new Mh(t,n,r,!1,a),i=ec(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const Bh=iu({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;fa(e);const s=ec(e,r),i=new zh(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return Xl.runKernel(Fi,{},a)}const Uh=iu({relu_:function(e){const t={x:au(e,"x","relu")};return Xl.runKernel(Li,t)}});const jh=iu({reverse_:function(e,t){const n={x:au(e,"x","reverse")},r={dims:t};return Xl.runKernel(ji,n,r)}});const Vh=iu({selu_:function(e){const t={x:au(e,"x","selu")};return Xl.runKernel(Yi,t)}});const Gh=iu({separableConv2d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=au(e,"x","separableConv2d"),l=au(t,"depthwiseFilter","separableConv2d"),u=au(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(3===o.rank&&(d=!0,c=Nd(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Wr(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Wr(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Wr(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Wr(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Wr(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const h=l.shape[2],p=l.shape[3];Wr(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));const f=qd(c,l,r,a,i,s),m=Pd(f,u,1,"valid",i);return d?Nd(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Hh=iu({sigmoid_:function(e){const t={x:au(e,"x","sigmoid","float32")};return Xl.runKernel(to,t)}});const qh=iu({slice_:function(e,t,n){const r=au(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:t,size:n};return Xl.runKernel(Qi,a,s)}});const Kh=iu({slice1d_:function(e,t,n){const r=au(e,"x","slice1d");return Wr(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),qh(r,[t],[n])}});const Xh=iu({slice2d_:function(e,t,n){const r=au(e,"x","slice2d");return Wr(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),qh(r,t,n)}});const Yh=iu({slice3d_:function(e,t,n){const r=au(e,"x","slice3d");return Wr(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),qh(r,t,n)}});const Qh=iu({slice4d_:function(e,t,n){const r=au(e,"x","slice4d");return Wr(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),qh(r,t,n)}});const Jh=iu({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=au(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},a={dim:t};return Xl.runKernel(oo,r,a)}});const Zh=iu({softplus_:function(e){const t={x:au(e,"x","softplus")};return Xl.runKernel(no,t)}});const ep=iu({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:au(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Xl.runKernel(io,r,a)}});const tp=iu({squeeze_:function(e,t){const n=au(e,"x","squeeze","string_or_numeric");return Nd(n,Jr(n.shape,t).newShape)}});const np=iu({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=su(e,"tensors","stack","string_or_numeric");Wr(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Wr(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return Xl.runKernel(Ni,r,a)}});const rp=iu({tanh_:function(e){const t={x:au(e,"x","tanh","float32")};return Xl.runKernel(So,t)}});function ap(e,t){jr(e);const n=tu(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return lu(e,null,n,t)}function sp(e,t,n){if(jr(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=tu(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return lu(e,t,r,n)}const ip=iu({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(fa(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new Mh(t,n,r,!0,a),i=ec(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const op=iu({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=au(e,"x","unstack","string_or_numeric");Wr(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},a={axis:t};return Xl.runKernel($o,r,a)}});const lp=iu({where_:function(e,t,n){const r=au(t,"a","where"),a=au(n,"b","where"),s=au(e,"condition","where","bool"),i=Tc(Tc(s.shape,r.shape),a.shape),o={condition:Ad(s,i),t:Ad(r,i),e:Ad(a,i)};return Xl.runKernel(Xi,o)}});const up=iu({imag_:function(e){const t={input:au(e,"input","imag")};return Xl.runKernel(js,t)}});const cp=iu({real_:function(e){const t={input:au(e,"input","real")};return Xl.runKernel(Di,t)}});const dp=iu({transpose_:function(e,t,n){const r=au(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Wr(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Wr(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const a={x:r},s={perm:t};return"complex64"===r.dtype?pu((()=>{let e=cp(r),t=up(r);return e=Xl.runKernel(To,{x:e},s),t=Xl.runKernel(To,{x:t},s),n&&(t=Eh(t)),ou(e,t)})):Xl.runKernel(To,a,s)}});function hp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Ic(e);if(1!==e.rank&&null===n)return hp(Nd(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return uh(Ic(e),n);if(t===1/0)return lh(Ic(e),n);if(t===-1/0)return Nh(Ic(e),n);if("euclidean"===t||2===t)return oc(uh(wc(Ic(e),dc(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return lh(uh(Ic(e),n[0]),n[1]-1);if(t===1/0)return lh(uh(Ic(e),n[1]),n[0]);if(t===-1/0)return Nh(uh(Ic(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return oc(uh(lc(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const pp=iu({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=hp(e=au(e,"x","norm"),t,n);let s=a.shape;if(r){const t=Qr(n,e.shape);s=fh(a.shape,t)}return Nd(a,s)}});const fp=iu({dropout_:function(e,t,n,r){const a=au(e,"x","dropout");if(Wr("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),Wr(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof El?a.clone():a;const s=function(e,t){if(null==t)return e.shape.slice();if(Gr(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=sc(th(rc(Bh(s,0,1,"float32",r),i)),i);return ic(a,o)}});const mp=iu({fft_:function(e){Wr("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Xl.runKernel(_s,t)}});const gp=iu({rfft_:function(e,t){Wr("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,a=qh(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=Dd([e,_h(r)],e.shape.length-1),n=t}else a=e;const s=uc(a),i=Nd(ou(a,s),[r,n]),o=mp(i),l=Math.floor(n/2)+1,u=cp(o),c=up(o),d=ep(u,[l,n-l],u.shape.length-1),h=ep(c,[l,n-l],c.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,Nd(ou(d[0],h[0]),p)}});const bp=iu({ifft_:function(e){Wr("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Xl.runKernel(Us,t)}});const yp=iu({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=Nd(e,[n,t]);r=bp(a)}else{const a=[n,2*(t-1)],s=Nd(cp(e),[n,t]),i=Nd(up(e),[n,t]),o=jh(qh(s,[0,1],[n,t-2]),1),l=ic(jh(qh(i,[0,1],[n,t-2]),1),dc(-1)),u=Dd([s,o],1),c=Dd([i,l],1),d=Nd(ou(u,c),[a[0],a[1]]);r=bp(d)}if(r=cp(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Nd(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const xp=iu({conv2DBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Nd(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Nd(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Wr(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Wr(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Wr(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];Wr(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Wr(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Id("conv2dDerFilter",a,i);const d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return Xl.runKernel(ns,d,h)}});const vp=iu({relu6_:function(e){const t={x:au(e,"x","relu6")};return Xl.runKernel(Ui,t)}});const wp=iu({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:au(e,"x","step")},r={alpha:t};return Xl.runKernel(Ao,n,r)}});function kp(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ic(e,wp(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Sp(e,t){let n=t;const r=Cc(e.shape,t.shape);return r.length>0&&(n=uh(n,r)),Nd(n,e.shape)}function Ip(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Uh(e);if("elu"===t)return Kd(e);if("relu6"===t)return vp(e);if("prelu"===t)return Oh(e,n);if("leakyrelu"===t)return sh(e,r);if("sigmoid"===t)return Hh(e);throw new Error(`Unknown fused activation ${t}.`)}const Np=(e,t)=>!(e>0)||"linear"===t;const Cp=iu({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===Np(Xl.state.gradientDepth,u)){Wr("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=Pd(t,n,r,a,s,i,o);return null!=l&&(e=rc(e,l)),Ip(e,u,c,d)}const h=au(t,"x","conv2d","float32"),p=au(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=Nd(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Wr(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),Wr(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),Id("fused conv2d",a,o);const g="NHWC"===s?f.shape[3]:f.shape[1];Wr(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),Wr(wd(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const b=pd(f.shape,p.shape,r,i,a,o);let y,x;if(null!=l&&(y=au(l,"bias","fused conv2d"),[y]=Wl(y,h),"NHWC"===s?Tc(b.outShape,y.shape):(Wr(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),Wr(0===y.shape.length||y.shape[0]===b.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${b.outChannels})`)))),null!=c){const e=c.shape;if(Wr(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Wr(1===e[0]||e[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${b.outChannels}).`));else if(3===e.length)try{Tc(e,b.outShape)}catch(FW){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(n)}x=au(c,"prelu weights","fused conv2d")}const v=(e,t)=>{Wr("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[n,o,l,c]=t,d=kp(e,l,u);Wr(vd(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const h=[Wd(o.shape,d,n,r,a),xp(o,d,n.shape,r,a)];if(null!=c){const e=Sp(c,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:x},k={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=cc(((e,t,n)=>{let r=Xl.runKernel(Lo,w,k);return n([t,e,r]),m&&(r=Nd(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p)}{const e=cc(((e,t,n,r)=>{let a=Xl.runKernel(Lo,w,k);return r([t,e,a,n]),m&&(a=Nd(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p,y)}}});const Tp=iu({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Nd(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Nd(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return Xl.runKernel(ms,u,c)}});const Ep=iu({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=Nd(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=Xl.runKernel(gs,u,c);return l?Nd(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const $p=iu({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===Np(Xl.state.gradientDepth,i)){let e=wh(t,n,r,a);return null!=s&&(e=rc(e,s)),Ip(e,i,o,l)}let u=au(t,"a","fused matMul"),c=au(n,"b","fused matMul");[u,c]=Wl(u,c);const d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),b=Vr(m),y=Vr(g);Wr(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${a} must match.`));const x=Tc(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),v=Nd(u,r?[b,d,p]:[b,p,d]),w=Nd(c,a?[y,f,h]:[y,h,f]);let k,S;null!=s&&(k=au(s,"bias","fused matMul"),[k]=Wl(k,u),Tc(x,k.shape)),null!=o&&(S=au(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,o,l,u]=t,c=kp(Nd(e,l.shape),l,i);let d,h;if(r||a?!r&&a?(d=wh(c,o,!1,!1),h=wh(c,n,!0,!1)):r&&!a?(d=wh(o,c,!1,!0),h=wh(n,c,!1,!1)):(d=wh(o,c,!0,!0),h=wh(c,n,!0,!0)):(d=wh(c,o,!1,!0),h=wh(n,c,!0,!1)),null!=s){return[d,h,Sp(u,c)]}return[d,h]},N={a:v,b:w,bias:k,preluActivationWeights:S},C={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:l};if(null==s){const e=cc(((e,t,n)=>{const r=Xl.runKernel(Oo,N,C);return n([e,t,r]),{value:Nd(r,x),gradFunc:I}}));return e(v,w)}{const e=cc(((e,t,n,r)=>{const a=Xl.runKernel(Oo,N,C);return r([e,t,a,n]),{value:Nd(a,x),gradFunc:I}}));return e(v,w,k)}}});const Rp=iu({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=au(e,"image","cropAndResize"),o=au(t,"boxes","cropAndResize","float32"),l=au(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Wr(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Wr(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Wr(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Wr(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Wr(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Wr("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const c={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return Xl.runKernel(ds,c,d)}});const _p=iu({flipLeftRight_:function(e){const t=au(e,"image","flipLeftRight","float32");Wr(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Xl.runKernel(Fs,n,{})}});const Ap=iu({grayscaleToRGB_:function(e){const t=au(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Wr(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Wr(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Zd(t,a)}});const Fp=iu({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(((e,t)=>au(e,`tensors${t}`,"einsum"))),s={equation:e};return Xl.runKernel(Ss,a,s)}});const Dp=iu({rgbToGrayscale_:function(e){const t=au(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Wr(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Wr(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const a=t.dtype,s=tc(t,"float32"),i=ap([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Fp("ij,j->i",s,i);break;case 3:o=Fp("ijk,k->ij",s,i);break;case 4:o=Fp("ijkl,l->ijk",s,i);break;case 5:o=Fp("ijklm,m->ijkl",s,i);break;case 6:o=Fp("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Jd(o,-1),tc(o,a)}});const Op=iu({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=au(e,"image","rotateWithOffset","float32");Wr(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},i={radians:t,fillValue:n,center:r};return Xl.runKernel(Do,s,i)}});function Lp(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const i=e.shape[0];return n=Math.min(n,i),Wr(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Wr(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Wr(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Wr(1===t.rank,(()=>"scores must be a 1D tensor")),Wr(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Wr(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const Mp=iu({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=au(e,"boxes","nonMaxSuppression","float32"),i=au(t,"scores","nonMaxSuppression","float32"),o=Lp(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Xl.runKernel(vi,{boxes:s,scores:i},l)}});function zp(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);const o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||Pp)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Pp(e,t){return e>t?1:e<t?-1:0}function Bp(e,t,n,r,a){return jp(e,t,n,r,a,0)}function Wp(e,t,n,r,a,s){return jp(e,t,n,r,a,0,!1,s,!0)}function Up(e,t,n,r,a,s){return jp(e,t,n,r,a,s,!0)}function jp(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(Hp);const c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){const n=Vp(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*Gp(r,c,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&zp(u,t,Hp))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function Vp(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(s,u),g=Math.max(i,c),b=Math.min(o,d),y=Math.min(l,h),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function Gp(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Hp(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const qp=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=au(e,"boxes","nonMaxSuppressionAsync"),i=au(t,"scores","nonMaxSuppressionAsync"),o=Lp(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=Bp(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),ap(d,"int32")};const Kp=iu({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=au(e,"boxes","nonMaxSuppression"),o=au(t,"scores","nonMaxSuppression"),l=Lp(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=Xl.runKernel(ki,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});const Xp=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=au(e,"boxes","nonMaxSuppressionAsync"),o=au(t,"scores","nonMaxSuppressionAsync"),l=Lp(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=Up(c,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ap(h,"int32"),selectedScores:ap(p)}};const Yp=iu({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=au(e,"boxes","nonMaxSuppression"),o=au(t,"scores","nonMaxSuppression"),l=Lp(i,o,n,r,a,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=Xl.runKernel(wi,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});const Qp=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=au(e,"boxes","nonMaxSuppressionAsync"),o=au(t,"scores","nonMaxSuppressionAsync"),l=Lp(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Wp(h,p,u,c,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ap(f,"int32"),validOutputs:dc(m,"int32")}};const Jp=iu({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=au(e,"images","resizeBilinear");Wr(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),Wr(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Wr(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Nd(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Xl.runKernel(Bi,o,l);return i?Nd(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Zp=iu({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=au(e,"images","resizeNearestNeighbor");Wr(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),Wr(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Wr("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Wr(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Nd(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Xl.runKernel(zi,o,l);return i?Nd(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const ef=iu({bincount_:function(e,t,n){const r=au(e,"x","bincount"),a=au(t,"weights","bincount");Wr("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Wr(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Wr(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},i={size:n};return Xl.runKernel(Ha,s,i)}});const tf=iu({lessEqual_:function(e,t){let n=au(e,"a","lessEqual","string_or_numeric"),r=au(t,"b","lessEqual","string_or_numeric");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(Xs,a)}});const nf=iu({round_:function(e){const t={x:au(e,"x","round")};return Xl.runKernel(Vi,t)}});const rf=iu({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=au(e,"image","threshold"),s=a.shape[0]*a.shape[1];let i,o,l,u,c=ic(ap([r]),255);if(Wr(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),Wr(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),Wr("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),Wr("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[i,o,l]=ep(a,[1,1,1],-1);const e=ic(i,.2989),t=ic(o,.587),n=ic(l,.114);u=rc(rc(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,a,s,i,o,l=ap([-1]),u=ap([0]),c=ap([0]);for(let d=0;d<e.size-1;d++){n=qh(e,0,d+1),r=qh(e,d+1),i=sc(uh(n),t),o=sc(uh(r),t);const h=uh(ic(n,Wh(0,n.size)));a=sc(h,uh(n));const p=xc(r.shape,n.size),f=rc(Wh(0,r.size),p),m=ic(r,f);s=sc(uh(m),uh(r));const g=kc(a,s),b=kc(a,s),y=ic(i,o);c=ic(ic(y,g),b);const x=rh(c,u);u=lp(x,c,u),l=lp(x,ap([d]),l)}return l}(ef(tc(nf(u),"int32"),uu([]),256),s)}const d=n?tf(u,c):rh(u,c);return tc(ic(d,255),"int32")}});const af=iu({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const i=au(e,"image","transform","float32"),o=au(t,"transforms","transform","float32");Wr(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Wr(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Wr(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Xl.runKernel(Co,l,u)}});const sf=iu({less_:function(e,t){let n=au(e,"a","less","string_or_numeric"),r=au(t,"b","less","string_or_numeric");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(Ks,a)}});const of=iu({bandPart_:function(e,t,n){const r=au(e,"a","bandPart");Wr(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,i]=r.shape.slice(-2);let o,l;"number"===typeof t?(Wr(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Wr(t<=s,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`)),o=au(t<0?s:t,"numLower","bandPart")):(Wr("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=lp(sf(t,0),s,Ch(t,s))),"number"===typeof n?(Wr(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Wr(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=au(n<0?i:n,"numUpper","bandPart")):(Wr("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=lp(sf(n,0),i,Ch(n,i)));const u=Nd(Wh(0,s,1,"int32"),[-1,1]),c=Wh(0,i,1,"int32"),d=kc(u,c),h=vh(tf(d,o),ah(d,Eh(l))),p=_h([s,i],r.dtype);return Nd(np(op(Nd(r,[-1,s,i])).map((e=>lp(h,e,p)))),a)}});const lf=iu({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Wr(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Wr(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=ep(e,e.shape[0],0).map((e=>tp(e,[0])));Wr(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let a=0;a<e.length;++a)n.push(Xl.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=ic(uh(ic(n[t],e)),n[t]);e=kc(e,r)}return sc(e,pp(e,"euclidean"))})));return t?np(n,0):n}});function uf(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Xl.tidy((()=>{Wr(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let a=eh(n),s=nc(e);const i=sp([[1]],[1,1]);let o=nc(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=s,l=o,u=a;[o,s,a]=Xl.tidy((()=>{const t=qh(s,[e,e],[n-e,1]),l=pp(t),u=qh(s,[e,e],[1,1]),c=lp(rh(u,0),sp([[-1]]),sp([[1]])),d=kc(u,ic(c,l)),h=sc(t,d);o=1===h.shape[0]?nc(i):Dd([i,qh(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=Eh(sc(wh(c,d),l)),f=qh(s,[e,0],[n-e,r]),m=ic(p,o),g=dp(o);if(0===e)s=kc(f,wh(m,wh(g,f)));else{const t=kc(f,wh(m,wh(g,f)));s=Dd([qh(s,[0,0],[e,r]),t],0)}const b=dp(m),y=qh(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=kc(y,wh(wh(y,o),b));else{const t=kc(y,wh(wh(y,o),b));a=Dd([qh(a,[0,0],[n,e]),t],1)}return[o,s,a]})),fu([t,l,u])}return!t&&n>r&&(a=qh(a,[0,0],[n,r]),s=qh(s,[0,0],[r,r])),[a,s]}))}const cf=iu({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Wr(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return uf(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=op(Nd(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{const[n,r]=uf(e,t);a.push(n),s.push(r)}));return[Nd(np(a,0),e.shape),Nd(np(s,0),e.shape)]}}});var df;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(df||(df={}));const hf=iu({squaredDifference_:function(e,t){let n=au(e,"a","squaredDifference"),r=au(t,"b","squaredDifference");[n,r]=Wl(n,r),Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(fo,a,{})}});const pf={flipLeftRight:_p,grayscaleToRGB:Ap,resizeNearestNeighbor:Zp,resizeBilinear:Jp,rgbToGrayscale:Dp,rotateWithOffset:Op,cropAndResize:Rp,nonMaxSuppression:Mp,nonMaxSuppressionAsync:qp,nonMaxSuppressionWithScore:Kp,nonMaxSuppressionWithScoreAsync:Xp,nonMaxSuppressionPadded:Yp,nonMaxSuppressionPaddedAsync:Qp,threshold:rf,transform:af},ff={bandPart:of,gramSchmidt:lf,qr:cf};const mf=class{static sgd(e){return new Rc(e)}static momentum(e,t){return new _c(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Ac(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Sc(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new yc(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new $c(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new vc(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},gf="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function bf(){return new Promise((e=>gf((()=>e()))))}function yf(e,t){const n=e[0].length;e.forEach(((e,t)=>{Wr(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Wr(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)Wr(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function xf(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var vf;function wf(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){const s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function kf(e){const t={FIRST_DIM_SIZE:vf.FIRST_DIM_SIZE,VALUE_ROWIDS:vf.VALUE_ROWIDS,ROW_LENGTHS:vf.ROW_LENGTHS,ROW_SPLITS:vf.ROW_SPLITS,ROW_LIMITS:vf.ROW_LIMITS,ROW_STARTS:vf.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Sf(e){return 0===e.length?0:e[0]===vf.FIRST_DIM_SIZE?e.length-1:e.length}function If(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(vf||(vf={}));const Nf=30;function Cf(e){return e<=Nf?e:oa(e,Math.floor(Math.sqrt(e)))}function Tf(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Ef(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function $f(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function Rf(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function _f(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Af(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}function Ff(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Vr(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let i=1;for(let d=0;d<a.length-1;++d)i*=a[d];const o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);const c=[...la(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}function Df(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Of(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Df(n,t,e)}function Lf(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length;let i=1;for(let l=a;l<s;++l)i*=n[l];const o=a<1?1:a;return{sliceRank:a,numUpdates:Vr(t.shape)/o,sliceSize:i,strides:[...la(n.slice(0,a)),1],outputSize:Vr(n)}}const Mf=1.7580993408473768,zf=1.0507009873554805,Pf=.3275911,Bf=.254829592,Wf=-.284496736,Uf=1.421413741,jf=-1.453152027,Vf=1.061405429;function Gf(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Hf(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function qf(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Kf(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Xf(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Yf(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Qf(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function Jf(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Zf="->",em=/->/g,tm=",",nm="...";function rm(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(em,"").length)/Zf.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Zf}").`);const[r,a]=e.split(Zf);Wr(-1===r.indexOf(nm),(()=>`The ellipsis notation ("${nm}") is not supported yet.`));const s=r.split(tm),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<a.length;++d){const e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){const e=r[d];-1===o.indexOf(e)&&e!==tm&&o.push(e)}const l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}const u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function am(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function sm(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Wr(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function im(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);const s=[];for(let i=0;i<n.length;++i){const e=lm(t,n[i]);for(const t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function om(e){return e.every(((e,t)=>e===t))}function lm(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function um(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)Wr(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Wr(a<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}Wr(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function cm(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function dm(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function hm(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function pm(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function fm(e,t){return`size ${e} must be non-negative, not ${t}`}function mm(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function gm(e,t){return`Input to reshape is a SparseTensor with ${Vr(e)}\n  dense values, but the requested shape requires a multiple of ${Vr(t)}. inputShape=${e} outputShape= ${t}`}function bm(e,t){return`Input to reshape is a tensor with ${Vr(e)} dense values, but the requested shape has ${Vr(t)}. inputShape=${e} outputShape=${t}`}function ym(){return"segment ids must be >= 0"}function xm(){return"segment ids are not increasing"}function vm(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function wm(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function km(e,t){let n,r=!1;for(e<=Nf?(n=e,r=!0):n=oa(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=oa(e,n+1);return n}function Sm(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function Im(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function Nm(e){try{return e.map((e=>pl(e)))}catch(DW){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${DW}`)}}function Cm(e){return e.map((e=>hl(e)))}function Tm(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const r=ec(e,"int32"),a=ec([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}!function(){for(const e of Fc)gc(e)}();const Em={kernelName:Ca,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,wp(tc(n,"float32"),-1))}}},$m={kernelName:Ta,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=lc(tc(n,"float32")),r=oc(kc(dc(1),t));return Eh(sc(e,r))}}}},Rm={kernelName:Ea,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=oc(kc(lc(tc(n,"float32")),1));return sc(e,t)}}}},_m={kernelName:$a,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{let t=e;const r=Cc(n.shape,a);return r.length>0&&(t=uh(t,r)),Nd(t,n.shape)},b:()=>{let t=e;const n=Cc(r.shape,a);return n.length>0&&(t=uh(t,n)),Nd(t,r.shape)}}}},Am={kernelName:Ra,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},Fm={kernelName:Fa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>uc(n)}}},Dm={kernelName:Da,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>uc(n)}}},Om={kernelName:Oa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,oc(kc(dc(1),lc(tc(n,"float32")))))}}},Lm={kernelName:La,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=oc(rc(dc(1),lc(tc(n,"float32"))));return sc(e,t)}}}},Mm={kernelName:Pa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{const t=rc(lc(n),lc(r));let s=ic(e,sc(r,t));const i=Cc(n.shape,a);return i.length>0&&(s=uh(s,i)),Nd(s,n.shape)},b:()=>{const t=rc(lc(n),lc(r));let s=Eh(ic(e,sc(n,t)));const i=Cc(r.shape,a);return i.length>0&&(s=uh(s,i)),Nd(s,r.shape)}}}},zm={kernelName:Ma,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,rc(lc(tc(n,"float32")),1))}}},Pm={kernelName:za,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,kc(dc(1),lc(tc(n,"float32"))))}}};const Bm=iu({avgPool3dGrad_:function(e,t,n,r,a,s){const i=au(e,"dy","avgPool3dGrad"),o=au(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Nd(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Nd(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Wr(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Wr(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Id("avgPool3dGrad",a,s);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=Xl.runKernel(ja,d,h);return c?Nd(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Wm={kernelName:Ua,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Bm(e,r,a,s,i,o)}}};const Um=iu({avgPoolGrad_:function(e,t,n,r,a){const s=au(e,"dy","avgPoolGrad"),i=au(t,"input","avgPoolGrad");Wr(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=Nd(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Nd(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wr(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Wr(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=Xl.runKernel(Wa,c,d);return u?Nd(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),jm={kernelName:Ba,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>Um(e,r,a,s,i)}}},Vm={kernelName:Va,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>wh(e,a,!1,!1),b:()=>wh(e,r,!0,!1)}:s&&!i?{a:()=>wh(a,e,!1,!0),b:()=>wh(r,e,!1,!1)}:{a:()=>wh(a,e,!0,!0),b:()=>wh(e,r,!0,!0)}:{a:()=>wh(e,a,!1,!0),b:()=>wh(r,e,!0,!1)}}};const Gm=iu({spaceToBatchND_:function(e,t,n){const r=au(e,"x","spaceToBatchND");Wr(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Wr(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Wr(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const a={x:r},s={blockShape:t,paddings:n};return Xl.runKernel(so,a,s)}}),Hm={kernelName:Ga,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>Gm(e,r,a)}}},qm={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>uh(e,o,!0)}}},Km={kernelName:Xa,gradFunc:e=>({x:()=>e.clone()})},Xm={kernelName:Ya,gradFunc:e=>({x:()=>uc(e)})},Ym={kernelName:Qa,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>lp(vh(ah(r,a),tf(r,s)),e,uc(e))}}},Qm={kernelName:Za,inputsToSave:["x"],gradFunc:Em.gradFunc},Jm={kernelName:es,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,s=Qr(a,t[0].shape)[0],i=r.map((e=>e[s]));return ep(e,i,s).map((e=>()=>e))}},Zm={kernelName:ts,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return Wr(vd(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Wd(r.shape,e,a,i,o,l),filter:()=>xp(r,e,a.shape,i,o,l)}}},eg={kernelName:rs,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Pd(e,a,s,i,o,1,l),filter:()=>xp(e,r,a.shape,s,i,o,l)}}};const tg=iu({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=Nd(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Nd(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Wr(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),Wr(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Wr(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Wr(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),Wr(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return Xl.runKernel(ss,o,l)}}),ng={kernelName:as,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s}=n;Wr(vd(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>Vd(i.shape,e,o,a,s),filter:()=>tg(i,e,o.shape,a,s)}}};const rg=iu({sin_:function(e){const t={x:au(e,"x","sin","float32")};return Xl.runKernel(Ji,t)}}),ag={kernelName:os,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(Eh(rg(tc(n,"float32"))),e)}}};const sg=iu({sinh_:function(e){const t={x:au(e,"x","sinh")};return Xl.runKernel(Zi,t)}}),ig={kernelName:ls,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(sg(tc(n,"float32")),e)}}};const og=iu({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:au(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return Xl.runKernel(cs,a,s)}}),lg={kernelName:cs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{const t=gh([a],r.rank);let n=og(e,a,s,!i);return null!=t&&(n=dp(n,t)),n}}}},ug={kernelName:fs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Wr(vd(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Wr(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Wr(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Wr(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Wr(wd(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Id("depthwiseConv2d",s,i),{x:()=>Ep(l.shape,e,u,a,s,o,i),filter:()=>Tp(l,e,u.shape,a,s,o,i)}}},cg={kernelName:ys,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Xl.runKernel(xs,s,n),filter:()=>Xl.runKernel(vs,i,n)}}},dg={kernelName:Is,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Xl.runKernel(Ns,r)}}},hg={kernelName:Cs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ic(Qd(Eh(lc(n))),2/Math.sqrt(Math.PI));return{x:()=>ic(e,r)}}},pg={kernelName:Es,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,n)}}},fg={kernelName:$s,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Nd(e,n.shape)}}},mg={kernelName:Rs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,Qd(n))}}},gg={kernelName:Ds,gradFunc:e=>({x:()=>uc(e)})},bg={kernelName:Os,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{const t=sc(e,tc(r,"float32")),s=Cc(n.shape,a);return s.length>0?Nd(uh(t,s),n.shape):t},b:()=>{let t=ic(e,tc(n,"float32"));const s=Cc(r.shape,a);s.length>0&&(t=Nd(uh(t,s),r.shape));const i=lc(r);return Eh(sc(t,tc(i,"float32")))}}}};const yg=iu({rsqrt_:function(e){const t={x:au(e,"x","rsqrt","float32")};return Xl.runKernel(Gi,t)}}),xg={kernelName:Ls,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?dc(1):o,u=Cc(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}const d=kc(a,s),h=ic(e,l),p=yg(rc(i,dc(r))),f=ic(ic(ic(p,p),p),dc(-.5));return{x:()=>1===s.rank?Nd(ic(ic(e,Zd(Nd(p,[1,1,1,s.shape[0]]),c)),l),a.shape):Nd(ic(ic(e,p),l),a.shape),mean:()=>{let e=ic(ic(p,dc(-1)),h);return 1===s.rank&&(e=uh(e,u)),Nd(e,s.shape)},variance:()=>{let e=ic(ic(f,d),h);return 1===s.rank&&(e=uh(e,u)),Nd(e,s.shape)},scale:()=>{const t=ic(d,p);let n=ic(e,t);return 1===s.rank&&(n=uh(n,u)),Nd(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=uh(t,u)),Nd(t,s.shape)}}}};const vg=iu({unsortedSegmentSum_:function(e,t,n){const r=au(e,"x","unsortedSegmentSum"),a=au(t,"segmentIds","unsortedSegmentSum","int32");Wr(Hr(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},i={numSegments:n};return Xl.runKernel(Ro,s,i)}}),wg={kernelName:Ms,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:s,batchDims:i}=n,o=Qr(s,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=kg(0,l),h=kg(l+1,l+1+c),p=Sg([i,[a],u]),f=Nd(n,p),m=Nd(t,[a]),g=Sg([[l],d,h]),b=dp(f,g);let y=vg(b,m,e.shape[o]);const x=bh(g);return y=dp(y,x),y};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=np(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function kg(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Sg(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const Ig={kernelName:Bs,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>uc(n),b:()=>uc(r)}}},Ng={kernelName:Ws,gradFunc:e=>({x:()=>tc(e,"float32")})},Cg={kernelName:Vs,gradFunc:e=>({x:()=>uc(e)})},Tg={kernelName:Gs,gradFunc:e=>({x:()=>uc(e)})},Eg={kernelName:Hs,gradFunc:e=>({x:()=>uc(e)})},$g={kernelName:qs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,s=rh(r,0);return{x:()=>lp(s,e,ic(e,a))}}},Rg={kernelName:Js,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,rc(n,1))}}},_g={kernelName:Qs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,tc(n,"float32"))}}},Ag={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=Qd(r);return kc(e,ic(uh(e,a,!0),t))}}}};const Fg=iu({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Xl.runKernel(ri,r,a)}}),Dg={kernelName:ni,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>Fg(r,a,e,s,i,o,l)}}};function Og(e,t,n,r){return t.rank<n.rank&&(t=Nd(t,fh(t.shape,r))),e.rank<n.rank&&(e=Nd(e,fh(e.shape,r))),{x:()=>ic(e,tc(Xd(n,t),e.dtype))}}const Lg={kernelName:ai,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,s=t[0],i=Og(e,t[1],s,Qr(a,s.shape));return{x:()=>i.x()}}},Mg={kernelName:si,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ic(e,tc(ah(n,r),"float32")),b:()=>ic(e,tc(sf(n,r),"float32"))}}};const zg=iu({maxPool3dGrad_:function(e,t,n,r,a,s,i){const o=au(e,"dy","maxPool3dGrad"),l=au(t,"input","maxPool3dGrad"),u=au(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=Nd(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Nd(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=Nd(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Wr(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Wr(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Wr(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),Id("maxPool3dGrad",s,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=Xl.runKernel(ui,f,m);return p?Nd(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),Pg={kernelName:li,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>zg(e,r,a,s,i,o,l)}}};const Bg=iu({maxPoolGrad_:function(e,t,n,r,a,s,i){const o=au(e,"dy","maxPoolGrad"),l=au(t,"input","maxPoolGrad"),u=au(n,"output","maxPoolGrad");Wr(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Wr(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Wr(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Id("maxPoolGrad",s,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return Xl.runKernel(oi,c,d)}}),Wg={kernelName:ii,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>Bg(e,r,a,s,i,o)}}},Ug={kernelName:di,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,s=Qr(a,r.shape),i=Vr(ph(r.shape,s)[1]);return{x:()=>{const t=r.shape.slice();s.forEach((e=>{t[e]=1}));const n=Nd(e,t);return sc(ic(n,Ah(r.shape,"float32")),i)}}}},jg={kernelName:hi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[s,i]=t,o=Og(e,i,s,Qr(a,s.shape));return{x:()=>o.x()}}},Vg={kernelName:pi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ic(e,tc(tf(n,r),"float32")),b:()=>ic(e,tc(rh(n,r),"float32"))}}},Gg={kernelName:fi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>qh(e,s,r.shape)}}},Hg={kernelName:mi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{const t=Cc(n.shape,a);return t.length>0?Nd(uh(e,t),n.shape):e},b:()=>{const t=ic(e,Eh(th(sc(n,r)))),s=Cc(r.shape,a);return s.length>0?Nd(uh(t,s),r.shape):t}}}},qg={kernelName:bi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{const t=ic(e,tc(r,"float32")),s=Cc(n.shape,a);return s.length>0?Nd(uh(t,s),n.shape):t},b:()=>{const t=ic(e,tc(n,"float32")),s=Cc(r.shape,a);return s.length>0?Nd(uh(t,s),r.shape):t}}}},Kg={kernelName:yi,gradFunc:e=>({x:()=>Eh(e)})},Xg={kernelName:Ii,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>_h(n.shape,"float32")}}},Yg={kernelName:Si,gradFunc:e=>({x:()=>uc(e)})},Qg={kernelName:Ni,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return op(e,r).map((e=>()=>e))}},Jg={kernelName:Ci,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>qh(e,s,r.shape)}}},Zg={kernelName:Ti,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,s=n,i=r,o=Tc(s.shape,i.shape);return{a:()=>{const t=tc(i,"float32");let n=ic(e,ic(t,wc(s,kc(t,dc(1)))));const r=Cc(s.shape,o);return r.length>0&&(n=uh(n,r)),Nd(n,s.shape)},b:()=>{const t=rh(s,0),n=lp(t,ih(s),uc(s));let r=ic(e,ic(a,n));const l=Cc(i.shape,o);return l.length>0&&(r=uh(r,l)),Nd(r,i.shape)}}}},eb={kernelName:Ei,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=rh(n,0);return{x:()=>lp(a,e,ic(e,r)),alpha:()=>{let t=lp(a,uc(e),ic(e,n));const s=Cc(r.shape,e.shape);return s.length>0&&(t=uh(t,s)),Nd(t,r.shape)}}}};const tb=iu({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:au(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return Xl.runKernel(us,a,s)}});function nb(e,t,n){const r=e.shape.length,a=r-n.length,s=gh(n,r);let i=e;null!=s&&(i=dp(e,s));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=Nd(t,r),s=tb(e,n,!0,!1),i=tb(e,n,!0,!0),o=ic(s,i);return ic(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){const e=bh(s);u=dp(u,e)}return u}const rb={kernelName:$i,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((e,t)=>t)):"number"===typeof a?[a]:a,{x:()=>nb(r,e,s)}}},ab={kernelName:ks,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{const t=sc(e,tc(r,"float32")),s=Cc(n.shape,a);return s.length>0?Nd(uh(t,s),n.shape):t},b:()=>{let t=ic(e,tc(n,"float32"));const s=Cc(r.shape,a);s.length>0&&(t=Nd(uh(t,s),r.shape));const i=lc(r);return Eh(sc(t,tc(i,"float32")))}}}},sb={kernelName:Oi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,Eh(lc(n)))}}},ib={kernelName:Ui,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ic(tf(n,6),wp(n));return{x:()=>ic(e,tc(r,"float32"))}}},ob={kernelName:Li,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,tc(wp(n),"float32"))}}},lb={kernelName:Mi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Nd(e,n.shape)}}},ub={kernelName:Bi,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Xl.runKernel(Wi,a,n)}}},cb={kernelName:zi,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Xl.runKernel(Pi,a,n)}}},db={kernelName:ji,gradFunc:(e,t,n)=>{const{dims:r}=n,a=Qr(r,e.shape);return{x:()=>jh(e,a)}}},hb={kernelName:Vi,gradFunc:e=>({x:()=>uc(e)})},pb={kernelName:Gi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Eh(sc(e,ic(wc(n,1.5),2)))}}};const fb=iu({logicalNot_:function(e){const t={x:au(e,"x","logicalNot","bool")};return Xl.runKernel(ei,t)}}),mb={kernelName:Xi,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>tc(uc(n),"float32"),t:()=>ic(e,tc(n,e.dtype)),e:()=>ic(e,tc(fb(n),e.dtype))}}},gb={kernelName:Yi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=rh(n,dc(0)),r=dc(Mf),a=dc(zf),s=ic(e,a),i=ic(ic(e,r),Qd(tc(n,"float32")));return lp(t,s,i)}}}},bb={kernelName:to,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,ic(n,kc(dc(1),n)))}}},yb={kernelName:eo,gradFunc:e=>({x:()=>uc(e)})};const xb=iu({cos_:function(e){const t={x:au(e,"x","cos","float32")};return Xl.runKernel(os,t)}}),vb={kernelName:Ji,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(xb(tc(n,"float32")),e)}}};const wb=iu({cosh_:function(e){const t={x:au(e,"x","cosh","float32")};return Xl.runKernel(ls,t)}}),kb={kernelName:Zi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(wb(tc(n,"float32")),e)}}},Sb={kernelName:Qi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=ad(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Dh(e,u)}}},Ib={kernelName:oo,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,s=ic(e,r);return{logits:()=>kc(s,ic(uh(s,[a],true),r))}}},Nb={kernelName:no,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,Hh(n))}}};const Cb=iu({batchToSpaceND_:function(e,t,n){const r=au(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Wr(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Wr(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Wr(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));const s={x:r},i={blockShape:t,crops:n};return Xl.runKernel(Ga,s,i)}}),Tb={kernelName:so,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>Cb(e,r,a)}}},Eb={kernelName:io,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Dd(e,r)}}},$b={kernelName:wo,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n.shape,r.shape);return{a:()=>{let t=e;const r=Cc(n.shape,a);return r.length>0&&(t=uh(t,r)),Nd(t,n.shape)},b:()=>{let t=e;const n=Cc(r.shape,a);return n.length>0&&(t=uh(t,n)),Nd(Eh(t),r.shape)}}}},Rb={kernelName:So,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(kc(dc(1),lc(n)),e)}}};const _b=[Em,$m,Rm,_m,Am,Fm,Dm,Om,Lm,Mm,zm,Pm,Wm,jm,Vm,Hm,qm,Km,Xm,Ym,Qm,Jm,eg,Zm,ng,ag,ig,lg,ug,cg,ab,dg,hg,pg,fg,mg,bg,gg,xg,wg,Ig,Ng,Cg,Tg,Eg,$g,Rg,_g,Ag,Dg,Lg,Lg,Mg,Pg,Wg,Ug,jg,Vg,Gg,Hg,qg,Kg,Xg,Yg,Qg,Jg,Jg,Zg,eb,rb,sb,ib,ob,lb,ub,cb,db,hb,pb,mb,gb,bb,yb,vb,kb,Sb,Ib,Nb,Tb,Tb,Eb,Eb,{kernelName:ro,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,ic(oc(tc(n,"float32")),2))}}},{kernelName:fo,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=dc(2);return{a:()=>ic(e,ic(a,kc(n,r))),b:()=>ic(e,ic(a,kc(r,n)))}}},{kernelName:mo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ic(e,ic(tc(n,"float32"),2))}}},{kernelName:Ao,gradFunc:e=>({x:()=>uc(e)})},$b,{kernelName:ao,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:s}=n;Qr(s,r.shape).forEach((e=>{a[e]=1}));const i=Nd(e,a),o=ic(i,Ah(r.shape,"float32"));return{x:()=>o}}},{kernelName:ko,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,lc(xb(n)))}}},Rb,{kernelName:Io,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=uc(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=rc(t,qh(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=rc(t,qh(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=rc(t,qh(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=rc(t,qh(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:To,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,s=bh(a);return{x:()=>dp(e,s)}}},{kernelName:$o,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>np(e,a)}}},{kernelName:Ro,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Ec(t,uc(t)),r=nh(e,n);let a=ah(t,dc(0,"int32"));const s=r.rank-a.rank;for(let o=0;o<s;++o)a=Jd(a,o+1);a=vh(a,Ah(r.shape,"bool"));const i=uc(r);return lp(a,r,i)}(e,n)}}},{kernelName:_o,gradFunc:e=>({x:()=>uc(e)})}];for(const n of _b)Ho(n);$l().prototype.abs=function(){return this.throwIfDisposed(),Ic(this)};const Ab=iu({acos_:function(e){const t={x:au(e,"x","acos")};return Xl.runKernel(Ta,t)}});$l().prototype.acos=function(){return this.throwIfDisposed(),Ab(this)};const Fb=iu({acosh_:function(e){const t={x:au(e,"x","acosh")};return Xl.runKernel(Ea,t)}});$l().prototype.acosh=function(){return this.throwIfDisposed(),Fb(this)},$l().prototype.add=function(e){return this.throwIfDisposed(),rc(this,e)},$l().prototype.all=function(e,t){return this.throwIfDisposed(),od(this,e,t)},$l().prototype.any=function(e,t){return this.throwIfDisposed(),ld(this,e,t)},$l().prototype.argMax=function(e){return this.throwIfDisposed(),ud(this,e)};const Db=iu({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:au(e,"x","argMin")},r={axis:t};return Xl.runKernel(Da,n,r)}});$l().prototype.argMin=function(e){return this.throwIfDisposed(),Db(this,e)},$l().prototype.asScalar=function(){return this.throwIfDisposed(),Wr(1===this.size,(()=>"The array must have only 1 element.")),Nd(this,[])},$l().prototype.asType=function(e){return this.throwIfDisposed(),tc(this,e)},$l().prototype.as1D=function(){return this.throwIfDisposed(),Nd(this,[this.size])},$l().prototype.as2D=function(e,t){return this.throwIfDisposed(),Nd(this,[e,t])},$l().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Nd(this,[e,t,n])},$l().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Nd(this,[e,t,n,r])},$l().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),Nd(this,[e,t,n,r,a])};const Ob=iu({asin_:function(e){const t={x:au(e,"x","asin")};return Xl.runKernel(Oa,t)}});$l().prototype.asin=function(){return this.throwIfDisposed(),Ob(this)};const Lb=iu({asinh_:function(e){const t={x:au(e,"x","asinh")};return Xl.runKernel(La,t)}});$l().prototype.asinh=function(){return this.throwIfDisposed(),Lb(this)};const Mb=iu({atan_:function(e){const t={x:au(e,"x","atan")};return Xl.runKernel(Ma,t)}});$l().prototype.atan=function(){return this.throwIfDisposed(),Mb(this)};const zb=iu({atan2_:function(e,t){let n=au(e,"a","atan2"),r=au(t,"b","atan2");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel(Pa,a)}});$l().prototype.atan2=function(e){return this.throwIfDisposed(),zb(this,e)};const Pb=iu({atanh_:function(e){const t={x:au(e,"x","atanh")};return Xl.runKernel(za,t)}});$l().prototype.atanh=function(){return this.throwIfDisposed(),Pb(this)},$l().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Cd(this,e,t,n,r)},$l().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Cb(this,e,t)},$l().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),Ed(this,e,t,n,r,a)},$l().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ad(this,e)},$l().prototype.cast=function(e){return this.throwIfDisposed(),tc(this,e)};const Bb=iu({ceil_:function(e){const t={x:au(e,"x","ceil","float32")};return Xl.runKernel(Ya,t)}});$l().prototype.ceil=function(){return this.throwIfDisposed(),Bb(this)},$l().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Fd(this,e,t)},$l().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof El&&(e=[e]),Dd([this,...e],t)},$l().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Bd(this,e,t,n,r,a,s)},$l().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Ud(this,e,t,n,r,a)},$l().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Pd(this,e,t,n,r,a,s)},$l().prototype.cos=function(){return this.throwIfDisposed(),xb(this)},$l().prototype.cosh=function(){return this.throwIfDisposed(),wb(this)},$l().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),tb(this,e,t,n)},$l().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),og(this,e,t,n)};const Wb=iu({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=au(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Wr(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Wr(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Wr(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Wr(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return Xl.runKernel(ps,o,l)}});$l().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Wb(this,e,t)},$l().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),qd(this,e,t,n,r,a,s)};const Ub=iu({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=au(e,"x","dilation2d"),o=au(t,"filter","dilation2d");Wr(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Wr(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Wr("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=Nd(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Wr(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=Xl.runKernel(ys,c,d);return u?Nd(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});$l().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),Ub(this,e,t,n,r,a)};const jb=iu({divNoNan_:function(e,t){let n=au(e,"a","div"),r=au(t,"b","div");[n,r]=Wl(n,r);const a=sc(n,r),s=uc(a),i=Xd(r,s);return lp(i,s,a)}});$l().prototype.divNoNan=function(e){return this.throwIfDisposed(),jb(this,e)},$l().prototype.div=function(e){return this.throwIfDisposed(),sc(this,e)};const Vb=iu({dot_:function(e,t){const n=au(e,"t1","dot"),r=au(t,"t2","dot");Wr((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Wr(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){const e=Nd(n,[1,-1]),t=Nd(r,[-1,1]),a=wh(e,t);return Nd(a,[])}if(1===n.rank&&2===r.rank){const e=Nd(n,[1,-1]),t=Nd(r,[r.shape[0],r.shape[1]]),a=wh(e,t);return Nd(a,[a.size])}if(2===n.rank&&1===r.rank){const e=Nd(r,[-1,1]),t=wh(n,e);return Nd(t,[t.size])}{const e=Nd(r,[r.shape[0],r.shape[1]]);return wh(n,e)}}});$l().prototype.dot=function(e){return this.throwIfDisposed(),Vb(this,e)},$l().prototype.elu=function(){return this.throwIfDisposed(),Kd(this)},$l().prototype.equal=function(e){return this.throwIfDisposed(),Xd(this,e)},$l().prototype.erf=function(){return this.throwIfDisposed(),Yd(this)};const Gb=iu({euclideanNorm_:function(e){return pp(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});$l().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Gb(this,e,t)},$l().prototype.exp=function(){return this.throwIfDisposed(),Qd(this)},$l().prototype.expandDims=function(e){return this.throwIfDisposed(),Jd(this,e)};const Hb=iu({expm1_:function(e){const t={x:au(e,"x","expm1")};return Xl.runKernel(Rs,t)}});$l().prototype.expm1=function(){return this.throwIfDisposed(),Hb(this)},$l().prototype.fft=function(){return this.throwIfDisposed(),mp(this)},$l().prototype.flatten=function(){return this.throwIfDisposed(),Nd(this,[this.size])},$l().prototype.floor=function(){return this.throwIfDisposed(),th(this)},$l().prototype.floorDiv=function(e){return this.throwIfDisposed(),ac(this,e)},$l().prototype.gather=function(e,t,n){return this.throwIfDisposed(),nh(this,e,t,n)},$l().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ah(this,e)},$l().prototype.greater=function(e){return this.throwIfDisposed(),rh(this,e)},$l().prototype.ifft=function(){return this.throwIfDisposed(),bp(this)},$l().prototype.irfft=function(){return this.throwIfDisposed(),yp(this)};const qb=iu({isFinite_:function(e){const t={x:au(e,"x","isFinite")};return Xl.runKernel(Vs,t)}});$l().prototype.isFinite=function(){return this.throwIfDisposed(),qb(this)};const Kb=iu({isInf_:function(e){const t={x:au(e,"x","isInf")};return Xl.runKernel(Gs,t)}});$l().prototype.isInf=function(){return this.throwIfDisposed(),Kb(this)};const Xb=iu({isNaN_:function(e){const t={x:au(e,"x","isNaN")};return Xl.runKernel(Hs,t)}});$l().prototype.isNaN=function(){return this.throwIfDisposed(),Xb(this)},$l().prototype.leakyRelu=function(e){return this.throwIfDisposed(),sh(this,e)},$l().prototype.lessEqual=function(e){return this.throwIfDisposed(),tf(this,e)},$l().prototype.less=function(e){return this.throwIfDisposed(),sf(this,e)};const Yb=iu({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=au(e,"x","localResponseNormalization");Wr(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),Wr(Hr(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=Nd(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=Xl.runKernel(ni,l,u);return o?Nd(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});$l().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Yb(this,e,t,n,r)};const Qb=iu({logSigmoid_:function(e){const t=au(e,"x","logSigmoid");return cc((e=>({value:Eh(Zh(Eh(e))),gradFunc:t=>ic(t,Hh(Eh(e)))})))(t)}});$l().prototype.logSigmoid=function(){return this.throwIfDisposed(),Qb(this)},$l().prototype.logSoftmax=function(e){return this.throwIfDisposed(),ch(this,e)},$l().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),xh(this,e,t)},$l().prototype.log=function(){return this.throwIfDisposed(),ih(this)},$l().prototype.log1p=function(){return this.throwIfDisposed(),oh(this)},$l().prototype.logicalAnd=function(e){return this.throwIfDisposed(),vh(this,e)},$l().prototype.logicalNot=function(){return this.throwIfDisposed(),fb(this)};const Jb=iu({logicalOr_:function(e,t){const n=au(e,"a","logicalOr","bool"),r=au(t,"b","logicalOr","bool");Tc(n.shape,r.shape);const a={a:n,b:r};return Xl.runKernel(ti,a)}});$l().prototype.logicalOr=function(e){return this.throwIfDisposed(),Jb(this,e)};const Zb=iu({logicalXor_:function(e,t){const n=au(e,"a","logicalXor","bool"),r=au(t,"b","logicalXor","bool");return Tc(n.shape,r.shape),vh(Jb(e,t),fb(vh(e,t)))}});$l().prototype.logicalXor=function(e){return this.throwIfDisposed(),Zb(this,e)},$l().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),wh(this,e,t,n)},$l().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),kh(this,e,t,n,r)},$l().prototype.max=function(e,t){return this.throwIfDisposed(),lh(this,e,t)},$l().prototype.maximum=function(e){return this.throwIfDisposed(),Ec(this,e)},$l().prototype.mean=function(e,t){return this.throwIfDisposed(),Ih(this,e,t)},$l().prototype.min=function(e,t){return this.throwIfDisposed(),Nh(this,e,t)},$l().prototype.minimum=function(e){return this.throwIfDisposed(),Ch(this,e)};const ey=iu({mirrorPad_:function(e,t,n){Wr("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=au(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Wr(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Wr(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Wr(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));const s={paddings:t,mode:n},i={x:r};return Xl.runKernel(fi,i,s)}});$l().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),ey(this,e,t)};const ty=iu({mod_:function(e,t){let n=au(e,"a","mod"),r=au(t,"b","mod");[n,r]=Wl(n,r);const a={a:n,b:r};return Xl.runKernel(mi,a)}});$l().prototype.mod=function(e){return this.throwIfDisposed(),ty(this,e)},$l().prototype.mul=function(e){return this.throwIfDisposed(),ic(this,e)},$l().prototype.neg=function(){return this.throwIfDisposed(),Eh(this)},$l().prototype.norm=function(e,t,n){return this.throwIfDisposed(),pp(this,e,t,n)},$l().prototype.notEqual=function(e){return this.throwIfDisposed(),$h(this,e)},$l().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Rh(this,e,t,n)},$l().prototype.onesLike=function(){return this.throwIfDisposed(),Fh(this)},$l().prototype.pad=function(e,t){return this.throwIfDisposed(),Dh(this,e,t)};const ny=iu({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=au(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Nd(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Wr(wd(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));const c=dd(l.shape,t,s,a,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),a=r.map((e=>Math.floor(e/2))),s=r.map(((e,t)=>e-a[t]));return r.map(((e,t)=>[a[t],s[t]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",b=p?l:Gm(l,d,f),y=("avg"===n?()=>Cd(b,t,s,g,i):()=>kh(b,t,s,g,i))(),x=p?y:Cb(y,d,m);return u?Nd(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});$l().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),ny(this,e,t,n,r,a,s)},$l().prototype.pow=function(e){return this.throwIfDisposed(),wc(this,e)},$l().prototype.prelu=function(e){return this.throwIfDisposed(),Oh(this,e)};const ry=iu({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=au(e,"x","prod");"bool"===r.dtype&&(r=tc(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return Xl.runKernel($i,a,s)}});$l().prototype.prod=function(e,t){return this.throwIfDisposed(),ry(this,e,t)};const ay=iu({reciprocal_:function(e){const t={x:au(e,"x","reciprocal")};return Xl.runKernel(Oi,t)}});$l().prototype.reciprocal=function(){return this.throwIfDisposed(),ay(this)},$l().prototype.relu=function(){return this.throwIfDisposed(),Uh(this)},$l().prototype.relu6=function(){return this.throwIfDisposed(),vp(this)},$l().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Nd(this,e.shape)},$l().prototype.reshape=function(e){return this.throwIfDisposed(),Nd(this,e)},$l().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Jp(this,e,t,n)},$l().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Zp(this,e,t,n)},$l().prototype.reverse=function(e){return this.throwIfDisposed(),jh(this,e)},$l().prototype.rfft=function(){return this.throwIfDisposed(),gp(this)},$l().prototype.round=function(){return this.throwIfDisposed(),nf(this)},$l().prototype.rsqrt=function(){return this.throwIfDisposed(),yg(this)},$l().prototype.selu=function(){return this.throwIfDisposed(),Vh(this)},$l().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Gh(this,e,t,n,r,a,s)},$l().prototype.sigmoid=function(){return this.throwIfDisposed(),Hh(this)};const sy=iu({sign_:function(e){const t={x:au(e,"x","sign")};return Xl.runKernel(eo,t)}});$l().prototype.sign=function(){return this.throwIfDisposed(),sy(this)},$l().prototype.sin=function(){return this.throwIfDisposed(),rg(this)},$l().prototype.sinh=function(){return this.throwIfDisposed(),sg(this)},$l().prototype.slice=function(e,t){return this.throwIfDisposed(),qh(this,e,t)},$l().prototype.softmax=function(e){return this.throwIfDisposed(),Jh(this,e)},$l().prototype.softplus=function(){return this.throwIfDisposed(),Zh(this)},$l().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Gm(this,e,t)},$l().prototype.split=function(e,t){return this.throwIfDisposed(),ep(this,e,t)},$l().prototype.sqrt=function(){return this.throwIfDisposed(),oc(this)},$l().prototype.square=function(){return this.throwIfDisposed(),lc(this)},$l().prototype.squaredDifference=function(e){return this.throwIfDisposed(),hf(this,e)},$l().prototype.squeeze=function(e){return this.throwIfDisposed(),tp(this,e)},$l().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof El?[this,e]:[this,...e];return np(n,t)},$l().prototype.step=function(e){return this.throwIfDisposed(),wp(this,e)};const iy=iu({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:au(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Xl.runKernel(bo,u,c)}});$l().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),iy(this,e,t,n,r,a,s,i,o)},$l().prototype.sub=function(e){return this.throwIfDisposed(),kc(this,e)},$l().prototype.sum=function(e,t){return this.throwIfDisposed(),uh(this,e,t)};const oy=iu({tan_:function(e){const t={x:au(e,"x","tan","float32")};return Xl.runKernel(ko,t)}});$l().prototype.tan=function(){return this.throwIfDisposed(),oy(this)},$l().prototype.tanh=function(){return this.throwIfDisposed(),rp(this)},$l().prototype.tile=function(e){return this.throwIfDisposed(),Zd(this,e)},$l().prototype.toBool=function(){return this.throwIfDisposed(),tc(this,"bool")},$l().prototype.toFloat=function(){return this.throwIfDisposed(),tc(this,"float32")},$l().prototype.toInt=function(){return this.throwIfDisposed(),tc(this,"int32")};const ly=iu({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=au(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);const s={x:r},i={k:t,sorted:n},[o,l]=Xl.runKernel(No,s,i);return{values:o,indices:l}}});$l().prototype.topk=function(e,t){return this.throwIfDisposed(),ly(this,e,t)},$l().prototype.transpose=function(e){return this.throwIfDisposed(),dp(this,e)};const uy=iu({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=au(e,"x","unique","string_or_numeric");Wr(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:t},[s,i]=Xl.runKernel(Eo,r,a);return{values:s,indices:i}}});$l().prototype.unique=function(e){return this.throwIfDisposed(),uy(this,e)},$l().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),vg(this,e,t)},$l().prototype.unstack=function(e){return this.throwIfDisposed(),op(this,e)},$l().prototype.where=function(e,t){return this.throwIfDisposed(),lp(e,this,t)},$l().prototype.zerosLike=function(){return this.throwIfDisposed(),uc(this)};class cy extends Error{constructor(e){super(e),Object.setPrototypeOf(this,cy.prototype)}}class dy extends Error{constructor(e){super(e),Object.setPrototypeOf(this,dy.prototype)}}class hy extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hy.prototype)}}class py extends Error{constructor(e){super(e),Object.setPrototypeOf(this,py.prototype)}}class fy extends Error{constructor(e){super(e),Object.setPrototypeOf(this,fy.prototype)}}Error;class my{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function gy(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function by(e,t){if(!e)throw new fy(t)}function yy(e,t){let n=0;for(const r of e)r===t&&n++;return n}function xy(e){return 1===e.length?e[0]:e}function vy(e){return Array.isArray(e)?e:[e]}function wy(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function ky(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let Sy={};function Iy(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Ny(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Ny(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Ny(t):e[n]=t.value)}}}function Cy(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const a=e;let s;if(a in n)s=n[a];else if(a in Sy)s=Sy[a];else if(s=t[a],null==s)throw new hy(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new hy(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const i=s.className;let o,l;if(i in n?[o,l]=n[i]:i in Sy?[o,l]=Sy.className:i in t&&([o,l]=t[i]),null==o)throw new hy(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(Sy))e[n]=Sy[n];for(const a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;const t=Object.assign({},Sy);for(const a of Object.keys(n))Sy[a]=n[a];Ny(s.config);const r=l(o,s.config,n,a);return Sy=Object.assign({},t),r}{const e=Object.assign({},Sy);for(const r of Object.keys(n))Sy[r]=n[r];const t=new o(s.config);return Sy=Object.assign({},e),t}}}function Ty(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Ey(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function $y(e){if(null==e)throw new hy(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ry(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new hy(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function _y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return by(n>=0),by(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function Ay(e,t){Array.isArray(e)?(Wr(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>Ay(e,`element ${n+1} of ${t}`)))):Wr(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${Fy(e)}.`))}function Fy(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>Fy(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function Dy(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Oy=0;function Ly(){return Oy++}const My={};function zy(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in My||(My[e]=0),My[e]+=1,e+My[e].toString()}const Py=["channelsFirst","channelsLast"],By=["nearest","bilinear"],Wy=["valid","same","causal"],Uy=["max","avg"],jy=["sum","mul","concat","ave"],Vy=new Map;function Gy(e){Ry(Py,"DataFormat",e)}function Hy(e){Ry(Wy,"PaddingMode",e)}function qy(e){Ry(Uy,"PoolMode",e)}const Ky=[];function Xy(e,t){Ky.push(e);try{const e=t();return Ky.pop(),e}catch(FW){throw Ky.pop(),FW}}function Yy(e){if(!Zy(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Ky.length?"":Ky.join("/")+"/")+e}function Qy(e){if(!Zy(e))throw new Error("Not a valid tensor name: '"+e+"'");Vy.has(e)||Vy.set(e,0);const t=Vy.get(e);if(Vy.set(e,Vy.get(e)+1),t>0){const n=`${e}_${t}`;return Vy.set(n,1),n}return e}const Jy=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Zy(e){return!!e.match(Jy)}function ex(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function tx(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function nx(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function rx(e,t){if(t<e)throw new hy(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let ax;function sx(){return null==ax&&(ax=bu().epsilon()),ax}function ix(e,t){return tc(e,t)}function ox(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Nd(e,n)}function lx(e,t,n){return pu((()=>{switch(e.rank){case 1:return Kh(e,t,n);case 2:return Xh(e,[t,0],[n,e.shape[1]]);case 3:return Yh(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Qh(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return qh(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return qh(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new hy(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function ux(e,t,n){return pu((()=>{switch(e.rank){case 1:return Kh(e,t,n);case 2:return Xh(e,[0,t],[e.shape[0],n]);case 3:return Yh(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Qh(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new hy(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function cx(e,t,n,r){return pu((()=>{switch(e.rank){case 1:return Kh(e,t,n);case 2:switch(r){case 1:return lx(e,t,n);case 2:return ux(e,t,n);default:throw new hy(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return lx(e,t,n);case 2:return Yh(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return ux(e,t,n);default:throw new hy(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return lx(e,t,n);case 2:return Qh(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Qh(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return ux(e,t,n);default:throw new hy(`The axis is not within the rank of the tensor ${r}`)}default:throw new hy(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function dx(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Dd(e,n)}function hx(e,t){switch(e.rank){case 1:return Od([e,t]);case 2:return Ld([e,t],0);case 3:return Md([e,t],0);case 4:return zd([e,t],0);default:throw new hy(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function px(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new hy(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Zd(e,t)}function fx(e){return Ph(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function mx(e,t,n,r){if(e.rank<2||t.rank<2)throw new py(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new py(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return $p({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?yx(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),s=a.pop();e=Nd(e,[-1,s]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Nd(dp(t,c),[l,-1]);const d=[...a,...u];return Nd($p({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?yx(e.rank,r,"channelsLast"):null,activation:n}),d)}}function gx(e,t,n){return pu((()=>(t=Array.isArray(t)?ap(t,"int32"):tc(t,"int32"),nh(e,t,n))))}function bx(e){return ic(e,e)}function yx(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new hy(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Nd(t,[1,r[0],1,1,1]):Nd(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Nd(t,[1,1,1,1,r[0]]):Nd(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Nd(t,[1,r[0],1,1]):Nd(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Nd(t,[1,1,1,r[0]]):Nd(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Nd(t,[1,r[0],1]):Nd(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Nd(t,[1,1,r[0]]):Nd(t,[1].concat(r))}else if(e<3)return t;throw new hy(`Unsupported input rank by biasAdd: ${t.rank}`)}function xx(e,t,n){return pu((()=>(null==n&&(n="channelsLast"),Gy(n),rc(e,yx(e.rank,t,n)))))}function vx(e,t,n,r){return pu((()=>fp(e,t,n,r)))}function wx(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const kx=["fanIn","fanOut","fanAvg"],Sx=["normal","uniform","truncatedNormal"];class Ix extends fc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Nx extends Ix{apply(e,t){return _h(e,t)}}Nx.className="Zeros",gc(Nx);class Cx extends Ix{apply(e,t){return Ah(e,t)}}Cx.className="Ones",gc(Cx);class Tx extends Ix{constructor(e){if(super(),"object"!==typeof e)throw new hy(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new hy(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return pu((()=>ic(dc(this.value),Ah(e,t))))}getConfig(){return{value:this.value}}}Tx.className="Constant",gc(Tx);class Ex extends Ix{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Bh(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Ex.className="RandomUniform",gc(Ex);class $x extends Ix{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new py(`randomNormal does not support dType ${t}.`);return fx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}$x.className="RandomNormal",gc($x);class Rx extends Ix{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new py(`truncatedNormal does not support dType ${t}.`);return ip(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Rx.className="TruncatedNormal",gc(Rx);class _x extends Ix{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return pu((()=>{if(2!==e.length||e[0]!==e[1])throw new hy("Identity matrix initializer can only be used for 2D square matrices.");return ic(this.gain,eh(e[0]))}))}getConfig(){return{gain:this.gain}}}_x.className="Identity",gc(_x);class Ax extends Ix{constructor(e){if(super(),e.scale<0)throw new hy(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Ry(kx,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Ry(Sx,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Gy(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=ex(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=ex(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=ex(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new py(`${this.getClassName()} does not support dType ${t}.`);return ip(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return Bh(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ax.className="VarianceScaling",gc(Ax);class Fx extends Ax{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Ax.className}}Fx.className="GlorotUniform",gc(Fx);class Dx extends Ax{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Ax.className}}Dx.className="GlorotNormal",gc(Dx);class Ox extends Ax{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Ax.className}}Ox.className="HeNormal",gc(Ox);class Lx extends Ax{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Ax.className}}Lx.className="HeUniform",gc(Lx);class Mx extends Ax{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Ax.className}}Mx.className="LeCunNormal",gc(Mx);class zx extends Ax{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Ax.className}}zx.className="LeCunUniform",gc(zx);class Px extends Ix{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return pu((()=>{if(e.length<2)throw new py("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Vr(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const s=fx([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=ff.qr(s,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=ic(o,l.sign()),n<r&&(o=o.transpose()),ic(dc(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Px.className="Orthogonal",gc(Px);const Bx={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Wx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cy(e,mc.getMap().classNameMap,t,"initializer")}function Ux(e){return Iy(e)}function jx(e){if("string"===typeof e){const t=e in Bx?Bx[e]:e;if("GlorotNormal"===t)return new Dx;if("GlorotUniform"===t)return new Fx;if("HeNormal"===t)return new Ox;if("HeUniform"===t)return new Lx;if("LeCunNormal"===t)return new Mx;if("LeCunUniform"===t)return new zx;{const e={};return e.className=t,e.config={},Wx(e)}}return e instanceof Ix?e:Wx(e)}function Vx(e){return Array.isArray(e)&&Array.isArray(e[0])}function Gx(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Hx(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new hy(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function qx(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new hy(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Kx(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const Xx="Variable";class Yx{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Xx,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Ly(),n=null==n?Xx:n,this.originalName=Yy(n),this.name=Qy(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Xl.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Qx(e){return e.map((e=>e.read()))}function Jx(e){e.forEach((e=>{e[0].write(e[1])}))}class Zx{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ev{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=Ly(),null!=s&&(this.originalName=Yy(s),this.name=Qy(this.originalName)),this.rank=t.length}}let tv=0;class nv{constructor(e,t){this.callArgs=t,this.id=tv++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let rv=0;class av extends fc{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=rv++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=wy(e)+"_"+zy(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new dy(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new hy(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return xy(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return xy(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new cy(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new cy(`Layer ${this.name} is not connected, no input to return.`);return xy(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new cy(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new cy(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return xy(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=vy(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=vy(this.inputSpec);if(t.length!==n.length)throw new hy(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],a=n[r];if(null==a)continue;const s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new hy(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new hy(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new hy(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new hy(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){const t=e.shape;for(const e in a.axes){const n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new hy(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new hy(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=vy(e),r=function(e){let t=!0;for(const n of vy(e))if(!(n instanceof ev)){t=!1;break}return t}(e),a=function(e){let t=!0;for(const n of vy(e))if(n instanceof ev){t=!1;break}return t}(e);if(r===a)throw new hy("Arguments to apply() must be all SymbolicTensors or all Tensors");return Xy(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of vy(e))t.push(n.shape);this.build(xy(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const a=vy(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=xy(s),null!=this.activityRegularizer)throw new py("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=vy(e);const t=[];for(const n of e)t.push(n.shape);return xy(t)}(e),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new ev(s,n,this,vy(e),t,this.name,r))):new ev(s,r,this,vy(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new py("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new cy(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new cy(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new dy(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Kx(this.weights)}build(e){this.built=!0}getWeights(){return Qx(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){pu((()=>{const t=this.weights;if(t.length!==e.length)throw new hy(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=Qx(t);for(let a=0;a<r.length;++a){const s=r[a],i=t[a],o=e[a];if(!Gr(s.shape,o.shape))throw new hy(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Jx(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new hy(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():jx("zeros"));const l=r.apply(t,n),u=new Yx(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=vy(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),a=vy(t),s=vy(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=vy(e);t=vy(t),n=vy(n),r=vy(r),a=Gx(a),s=Gx(s);const l=[],u=[],c=[];for(const d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new nv({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function sv(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=sv(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class iv extends av{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:zy("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new hy("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new hy("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new hy("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new ev(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new hy(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}iv.className="InputLayer",gc(iv);class ov{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ov)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new hy(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return tc(t,e.dtype)}catch(DW){throw new hy(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ev){if(null==this.id2Value[e.id])throw new hy(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new hy(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ev){if(null==this.id2Value[e.id])throw new hy(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new hy(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&fu(this.id2Mask)}}const lv=new my,uv=new my;function cv(e,t,n,r){const a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=lv.get(c);if(null==h){const e=function(e,t){Wr(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=hv(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of e){const{sorted:e,recipientMap:i}=hv(s,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:dv(r)}}(i,t);h=e.sorted,d=e.recipientCounts,lv.put(c,h),uv.put(c,d)}d={},a||Object.assign(d,uv.get(c));const p=new ov(t);for(let f=0;f<h.length;++f){if(null!=r){const e=hu().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],s=e.sourceLayer;if(s instanceof iv)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=vy(s.apply(i,n));let b=null;s.supportsMasking&&(b=s.computeMask(i,u));const y=pv(e),x=Array.isArray(y)?y:[y];for(let t=0;t<x.length;++t){p.hasKey(x[t])||p.add(x[t],g[t],Array.isArray(b)?b[0]:b);const e=o.indexOf(x[t].name);-1!==e&&(l[e]=g[t])}a||fu(c)}return p.disposeMasks(),s?l:l[0]}function dv(e){const t={};for(const n in e)t[n]=e[n].size;return t}function hv(e,t){const n=new Set,r=[],a={};for(const o of t.names())n.add(o);const s=[],i=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:r,recipientMap:a}}function pv(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function fv(e,t){return pu((()=>oc(uh(ic(e,e),t,!0))))}wa().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=lv&&lv.setMaxEntries(e),null!=uv&&uv.setMaxEntries(e)}));class mv extends fc{getConfig(){return{}}}class gv extends mv{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return pu((()=>{const t=fv(e,this.axis),n=Fd(t,0,this.maxValue);return ic(e,sc(n,rc(sx(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}gv.className="MaxNorm",gc(gv);class bv extends mv{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return pu((()=>sc(e,rc(sx(),fv(e,this.axis)))))}getConfig(){return{axis:this.axis}}}bv.className="UnitNorm",gc(bv);class yv extends mv{apply(e){return Uh(e)}}yv.className="NonNeg",gc(yv);class xv extends mv{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return pu((()=>{const t=fv(e,this.axis),n=rc(ic(this.rate,Fd(t,this.minValue,this.maxValue)),ic(1-this.rate,t));return ic(e,sc(n,rc(sx(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}xv.className="MinMaxNorm",gc(xv);const vv={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function wv(e){return Iy(e)}function kv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cy(e,mc.getMap().classNameMap,t,"constraint")}function Sv(e){if(null==e)return null;if("string"===typeof e){return kv({className:e in vv?vv[e]:e,config:{}})}return e instanceof mv?e:kv(e)}async function Iv(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const s=e[a];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];fu(r)}}function Nv(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var Cv;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Cv||(Cv={}));class Tv{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Ev{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class $v extends Tv{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const a=pu((()=>rc(this.totals[r],ic(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:pu((()=>{const e=ic(sc(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),mu(t[n])})))}}class Rv extends Tv{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const i=r[s];e.push(i.data()),t.push(a),n.push(s)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a){this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}}class _v extends Tv{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||bf,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");aa(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():dl();return function(){const s=null!=n?n():dl();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await Iv(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Iv(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Iv(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Iv(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Iv(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):aa(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Iv(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Iv(e),await this.trainEnd(e))}}function Av(e,t){if(null==e&&(e={}),e instanceof Tv)return[e];if(Array.isArray(e)&&e[0]instanceof Tv)return e;return vy(e).map((e=>new _v(e,t)))}class Fv{constructor(){}static registerCallbackConstructor(e,t){Wr(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),Fv.checkForDuplicate(t),null==Fv.constructors[e]&&(Fv.constructors[e]=[]),Fv.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Fv.constructors){Fv.constructors[+t].forEach((t=>{if(t===e)throw new hy("Duplicate callback constructor.")}))}}static clear(){Fv.constructors={}}static createCallbacks(e){const t=[];for(const n in Fv.constructors){const r=+n;e>=r&&t.push(...Fv.constructors[r])}return t.map((e=>new e))}}function Dv(e,t,n,r,a,s,i,o,l){const u=new Rv,c=[new $v,...Fv.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new Ev(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function Ov(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Cy(e,mc.getMap().classNameMap,t,"layer",n)}function Lv(e,t){return pu((()=>{"float32"!==e.dtype&&(e=tc(e,"float32"));const n=uh(bx(e),t,!0),r=xc(n.shape,sx()),a=oc(Ec(n,r));return sc(e,a)}))}function Mv(e,t){return pu((()=>Ih(bx(kc(t,e)),-1)))}function zv(e,t){return pu((()=>Ih(Ic(kc(t,e)),-1)))}function Pv(e,t){return pu((()=>{const n=kc(e,t),r=Fd(Ic(e),sx(),Number.MAX_VALUE),a=Ic(sc(n,r));return ic(100,Ih(a,-1))}))}function Bv(e,t){return pu((()=>{const n=Fd(t,sx(),Number.MAX_VALUE),r=ih(rc(1,n)),a=Fd(e,sx(),Number.MAX_VALUE),s=ih(rc(1,a));return Ih(bx(kc(r,s)),-1)}))}function Wv(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return pu((()=>{if(n)t=Jh(t);else{const e=uh(t,t.shape.length-1,!0);t=sc(t,e)}return t=Fd(t,sx(),1-sx()),Eh(uh(ic(tc(e,"float32"),ih(t)),t.shape.length-1))}))}function Uv(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return pu((()=>{const r=tc(th(function(e){const t=[ex(e.shape)];return Nd(e,t)}(e)),"int32"),a=(t=Fd(t,sx(),1-sx())).shape;return Wv(Nd(Rh(r,a[a.length-1]),a),t,n)}))}function jv(e,t){return pu((()=>{let n;return n=Fd(t,sx(),1-sx()),n=ih(sc(n,kc(1,n))),Ih(function(e,t){if(!Gr(e.shape,t.shape))throw new hy(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return pu((()=>{const n=Uh(t),r=Eh(Ic(t));return rc(kc(n,ic(t,e)),oh(Qd(r)))}))}(e,n),-1)}))}function Vv(e,t){return pu((()=>{const n=Fd(e,sx(),1),r=Fd(t,sx(),1);return uh(ic(e,ih(sc(n,r))),-1)}))}function Gv(e,t){return pu((()=>{const n=Lv(e,-1),r=Lv(t,-1),a=ic(n,r);return Eh(uh(a,-1))}))}Fv.constructors={};const Hv={meanSquaredError:Mv,meanAbsoluteError:zv,meanAbsolutePercentageError:Pv,meanSquaredLogarithmicError:Bv,squaredHinge:function(e,t){return pu((()=>{const n=Ec(0,kc(1,ic(e,t)));return Ih(bx(n),-1)}))},hinge:function(e,t){return pu((()=>{const n=Ec(0,kc(1,ic(e,t)));return Ih(n,-1)}))},categoricalHinge:function(e,t){return pu((()=>{const n=uh(ic(e,t),-1),r=lh(ic(kc(1,e),t),-1);return Ec(0,rc(1,kc(r,n)))}))},logcosh:function(e,t){return pu((()=>{const n=Math.log(2),r=kc(t,e),a=kc(rc(r,Zh(ic(-2,r))),n);return Ih(a,-1)}))},categoricalCrossentropy:Wv,sparseCategoricalCrossentropy:Uv,binaryCrossentropy:jv,kullbackLeiblerDivergence:Vv,poisson:function(e,t){return pu((()=>{const n=ih(rc(sx(),t));return Ih(kc(t,ic(e,n)),-1)}))},cosineProximity:Gv};function qv(e){if("string"===typeof e){if(e in Hv)return Hv[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new hy(t)}return e}function Kv(e,t){return pu((()=>{const n=ic(.5,Fh(t)),r=ix(rh(t,n),e.dtype);return Ih(Xd(e,r),-1)}))}function Xv(e,t){return pu((()=>ix(Xd(ud(e,-1),ud(t,-1)),"float32")))}function Yv(e,t){return pu((()=>tc(uh(vh(Xd(e,1),Xd(t,1))),"float32")))}function Qv(e,t){return jv(e,t)}function Jv(e,t){return e.rank===t.rank&&(e=tp(e,[e.rank-1])),(t=ud(t,-1)).dtype!==e.dtype&&(t=tc(t,e.dtype)),tc(Xd(e,t),"float32")}const Zv=Wv,ew=Uv,tw={binaryAccuracy:Kv,categoricalAccuracy:Xv,precision:function(e,t){return pu((()=>{const n=Yv(e,t),r=function(e,t){return pu((()=>tc(uh(vh(Xd(e,0),Xd(t,1))),"float32")))}(e,t),a=rc(n,r);return tc(lp(rh(a,0),sc(n,a),0),"float32")}))},categoricalCrossentropy:Zv,sparseCategoricalCrossentropy:ew,mse:Mv,MSE:Mv,mae:zv,MAE:zv,mape:Pv,MAPE:Pv,cosine:Gv};function nw(e){if("string"===typeof e&&e in tw)return tw[e];if("string"!==typeof e&&null!=e)return e;throw new hy(`Unknown metric ${e}`)}function rw(e){if(by(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(Hv))if(Hv[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(tw))if(tw[n]===e){t=n;break}return void 0!==t?t:e.name}}const aw=1048576;function sw(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!iw(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>aw&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function iw(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!iw(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!iw(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function ow(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(e){let t=!0;const n=[],r=[];for(const a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of e.layers){let e=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){s.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),lw(s,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)a?uw(o[c],n,r):cw(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?Kx(e.collectedTrainableWeights):Kx(e.trainableWeights);return t}(e),u=Kx(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function lw(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function uw(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(DW){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(DW){r="multiple"}lw([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function cw(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(DW){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(DW){a="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];lw([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)lw(["","","","",i[c]],t,r)}function dw(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function hw(e,t){if(null===e)return null;if("string"===typeof e)return ky(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];dw(t,a,r)?n.push(r):n.push(hw(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=ky(n);t[e]=hw(r,e)}}return t}}function pw(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return wy(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];dw(t,a,r)?n.push(r):n.push(pw(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=wy(n);t[a]="name"!==n&&"className"!==n||"string"!==typeof r?pw(r,n):r}return t}}const fw="4.22.0";class mw extends av{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=zy(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ey(this.inputs).length!==this.inputs.length)throw new hy(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);Ey(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;by(0===t,"input layer has >1 nodes"),by(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof iv))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new dy(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(mw.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let s=0;s<c;s++){const e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const b of this.outputs)o(b,l,u);const c=i.slice().reverse();for(const b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const s=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];e=Math.max(e,s),r[b.outboundLayer.id]=e,a[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let r=0;r<b.inboundLayers.length;r++){const a=b.inboundLayers[r],s=b.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const d={};for(const b in t){const e=t[b];e in d||(d[e]=[]),d[e].push(n[b])}const h={};for(const b in r){const e=r[b];e in h||(h[e]=[]),h[e].push(a[b])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(Ty);this.layers=[];for(const b of p){const e=h[b];e.sort(((e,t)=>{const n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof mw&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(Ty);const f=this.inputs.slice(),m=[];for(const b of p)for(const e of d[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new dy(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const b of g){const e=g.filter((e=>e===b)).length;if(1!==e)throw new dy(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new hy("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new hy(`Duplicate weight name: ${s}`);n[s]=t,r++}const s=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new hy(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new hy(`${e.length} of ${r} weights are not set: ${e}`)}Jx(s)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${fw}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=pw(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return pu((()=>{e=vy(e);const n=new ov;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return cv(this.outputs,n,t)}))}computeMask(e,t){return pu((()=>{let n;return e=vy(e),n=null==t?gy(null,e.length):vy(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Gx(e);if(t.length!==this.inputLayers.length)throw new hy(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Ty);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}const a=Gx(e.computeOutputShape(xy(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}const a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){const e=s[i];by(e in n),a.push(n[e])}return xy(a)}runInternalGraph(e,t){null==t&&(t=gy(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Ty);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(const t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){const[t,n]=s[0];null==u.mask&&(u.mask=n),o=vy(e.call(t,u)),l=vy(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=vy(e.call(r,u)),l=vy(e.computeMask(r,i));if(e.activityRegularizer)throw new py("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}const a=[],s=[],i=[];for(const o of this.outputs){by(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof mw?1:0;for(let e=0;e<r.inboundNodes.length;e++){const a=mw.nodeKey(r,e);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new hy("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new hy(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new hy(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return pu((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=mw.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const e=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const e=s.inboundNodes[n],r=mw.nodeKey(s,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(DW){console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],s=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[mw.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,o,i])}a.push(n)}}}const i={};i.name=s.name,i.className=e,i.config=r,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const e=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=mw.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[s];r.push([e.name,i,o])}e.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=mw.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[s];a.push([e.name,i,o])}return e.outputLayers=a,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let a;for(const i of t){const o=i[0],l=i[1],u=i[2];if(a=null==i[3]?{}:i[3],!(o in r))return void s(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(xy(n),a)}function o(e){const a=e.name,i=Ov(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new hy(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!$y(a);)for(const e of u){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const c=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];by(e in r);const a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];by(e in r);const a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new hy("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){pu((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function gw(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function bw(e,t){return gw(e,t,"classWeight")}async function yw(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=pu((()=>{if(1===e.shape.length)return nc(e);if(2===e.shape.length){if(e.shape[1]>1){return ud(e,1)}if(1===e.shape[1])return Nd(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());fu(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),ap(a,"float32")}return null}function xw(e,t){return ic(e,t)}function vw(e,t){let n,r;const a=t;n=a.xs,r=a.ys,Wr(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=ww("input",e.inputNames,n),i=ww("output",e.outputNames,r),o=s[0].shape[0];Wr(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Wr(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)Wr(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Wr(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function ww(e,t,n){if(n instanceof El)return[n];if(Array.isArray(n))return Wr(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const a of t){if(null==n[a])throw new hy(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function kw(e,t,n){const r=null!=n.batchesPerEpoch;if(Wr(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Wr(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Wr(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Wr(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Wr(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let s,i;if(a)if(Sw(n.validationData))Wr(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new py("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=a?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=Av(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=Dv(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:a}=vw(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);const i=[];if(null!=n.classWeight){const t=bw(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await yw(a[e],null,t[e]))}const u=r.concat(a).concat(i),p=o(u);fu(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];s[t]=n,mu(n)}await h.onBatchEnd(d,s),Nv(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(a){let t;t=Sw(n.validationData)?vy(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):vy(e.evaluate(s,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Sw(e){return"function"===typeof e.iterator}function Iw(e){Wr(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Nw(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>lx(e,t,n-t))):lx(e,t,n-t)}function Cw(e,t){return pu((()=>null==e?null:Array.isArray(e)?e.map((e=>Cw(e,t))):gx(e,"int32"===t.dtype?t:tc(t,"int32"))))}function Tw(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Ew(e){const t=[];e instanceof El&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(ox(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function $w(e,t){if(null==e)return;const n=[];if(t instanceof El)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const a in t){const e=t[a];n.push(e.id)}const r=[];if(e instanceof El)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const a in e){const t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Rw(e){return Array.isArray(e)}function _w(e){return!function(e){return e instanceof El}(e)&&!Rw(e)}function Aw(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(Rw(e)&&e.length>0)t=!0;else if(_w(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new hy(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(_w(e)){r=[];for(const n of t){if(null==e[n])throw new hy(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(Rw(e)){if(e.length!==t.length)throw new hy(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new hy(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=Ew(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new hy(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new hy(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function Fw(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new hy(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new hy(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new hy(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new hy(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class Dw extends mw{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new hy("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ow(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>mf.adagrad(.01),Adadelta:()=>mf.adadelta(1,.95,sx()),Adam:()=>mf.adam(.001,.9,.999,sx()),Adamax:()=>mf.adamax(.002,.9,.999,sx(),0),RMSProp:()=>mf.rmsprop(.001,.9,0,sx()),SGD:()=>mf.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new hy(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof bc))throw new hy("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new hy(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>qv(e)))}else{const n=qv(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new hy(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(qv(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Xy("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Xy("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===jv?-1!==["accuracy","acc"].indexOf(i)?r=Kv:-1!==["crossentropy","ce"].indexOf(i)&&(r=Qv):this.lossFunctions[e]===Uv?-1!==["accuracy","acc"].indexOf(i)?r=Jv:-1!==["crossentropy","ce"].indexOf(i)&&(r=ew):-1!==["accuracy","acc"].indexOf(i)?r=Xv:-1!==["crossentropy","ce"].indexOf(i)&&(r=Zv),-1!==["accuracy","acc"].indexOf(i)?a="acc":-1!==["crossentropy","ce"].indexOf(i)&&(a="ce"),s=r,n=""+a}else{const e=nw(i);s=e,n=""+rw(i)}let t;Xy(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Iw(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction;return xy(this.testLoop(t,e,r,n.verbose,n.steps))}finally{$w(a[0],e),$w(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let s=[];if(n.verbose>0)throw new py("Verbose mode is not implemented yet.");Wr(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(s=pu((()=>{if(t.value){const{xs:n,ys:r}=vw(e,t.value),i=n.concat(r),u=pu((()=>a(i)));if(fu(i),0===l)for(let e=0;e<u.length;++e)s.push(dc(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=pu((()=>rc(s[e],ic(c,t)))),l>0&&fu(n)}fu(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){const e=s[u];s[u]=sc(s[u],o),fu(e)}return xy(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new hy(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new hy(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new hy("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new ov;if(e instanceof El&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new hy(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new hy(`No value is provided for the model's input ${o.name}`);s.add(o,t)}const i=cv(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){const t=gy(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){const i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new hy(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return pu((()=>{const r=this.checkNumSamples(e);if(n)throw new py("Verbose predictLoop() is not implemented yet.");const a=Tw(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){pu((()=>{const n=a[t][0],r=a[t][1],s=Nw(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});const o=new ov(i);return cv(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)))}return xy(s.map((e=>Dd(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Ew(e);Fw(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Iw(e),this.predictLoop(n,e)}finally{$w(n,e)}}predictOnBatch(e){Fw(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new dy("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===Uv?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=Ey(e.map((e=>e.shape[0])));n.sort();const r=Ey(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new hy(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new hy(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!Gr(n,r))throw new hy(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Aw(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Aw(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[Mv,jv,Wv];for(let a=0;a<e.length;++a){const s=e[a],i=t[a],o=n[a];if(null!=i){if(i===Wv&&1===s.shape[s.shape.length-1])throw new hy(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new hy(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new hy(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=bw(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await yw(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return pu((()=>{const s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new py("Verbose mode is not implemented yet.");if(null!=a)throw new py("steps mode in testLoop() is not implemented yet");{const r=Tw(s,n),a=ap(rx(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],o=r[n][1],l=lx(a,s,o-s),u=Cw(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(dc(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=rc(i[e],ic(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=sc(i[e],s)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(yy(e,r)>1){a+=`_${yy(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new ov(e),o=cv(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=a[n]&&(e=xw(e,a[n]));const s=Ih(e);t.push(s),l=0===n?e:rc(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=Ih(t(r[a],o[a]))}mu(e),s.push(e)}return l=Ih(l),this.calculateLosses().forEach((e=>{l=rc(l,e)})),l}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>pu((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});const i=new ov(s),o=cv(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],s=Ih(r(a[e],o[e]));n=0===e?s:rc(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=Ih(n(a[r],o[r]));t.push(s)}return t}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;Iw(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new py("validationData including sample weights is not supported yet."):new hy(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,h);l=t[0],u=t[1],m=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=Nw(n,e,t),a=n,n=Nw(n,0,e),u=Nw(r,e,t),s=r,r=Nw(r,0,e),m=l.concat(u)}else null!=d.validationSteps&&(g=!0);const b=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,w;g?(this.makeTestFunction(),v=this.testFunction,w=x.slice().concat(x.map((e=>"val_"+e)))):(v=null,m=[],w=x.slice());const k=Av(d.callbacks,d.yieldEvery);return await this.fitLoop(y,b,x,h,d.epochs,d.verbose,k,v,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,$w(n,e),$w(r,t),$w(a,e),$w(s,t),$w(l,i),$w(u,o),null!=c&&fu(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new hy("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=rx(0,m)),null==s&&(s=1);const{callbackList:b,history:y}=Dv(i,s,a,d,m,h,r,f,c);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<a;++x){await b.onEpochBegin(x);const a={};if(null!=h)throw new py("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new py("batch shuffling is not implemneted yet");u&&Mr(g);const s=ap(g),i=Tw(m,r);for(let u=0;u<i.length;++u){const c={};if(await b.onBatchBegin(u,c),pu((()=>{const d=i[u][0],h=i[u][1],p=lx(s,d,h-d);c.batch=u,c.size=h-d;const m=Cw(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,mu(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],s=e[t];mu(s),a["val_"+r]=s}}})),await b.onBatchEnd(u,c),Nv(c),this.stopTraining_)break}s.dispose()}if(await b.onEpochEnd(x,a),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return kw(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(const o of s){const e=await o.data();i.push(e[0])}return fu(s),$w(n[0],e),$w(n[1],t),xy(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=hu().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-hu().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=wy(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>wy(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=wy(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[wy(rw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>wy(rw(e))));{const e={};for(const t in this.metrics)e[t]=wy(rw(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Ov(hw(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=ky(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>ky(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=ky(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>ky(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=ky(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,Cu.getSaveHandlers(n));if(0===t.length)throw new hy(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new hy(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}var n;if(null==e.save)throw new hy("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await yu(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${fw}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await yu(await this.optimizer.getWeights(),e);r.specs.push(...n),r.data=(s=[r.data,t],cu.join(s))}var s;if(null!=this.userDefinedMetadata){const e=!0;sw(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){sw(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Dw.className="Model",gc(Dw);class Ow extends Dw{}Ow.className="Functional",gc(Ow);class Lw extends Dw{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:zy("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new hy(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Lw||e instanceof Dw;let n;if(t){if(n=e,1!==n.outputs.length)throw new hy("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new hy("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new hy("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new hy("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new iv({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new hy(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new hy("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=sv(this.outputs[0])}this.inboundNodes=[],new nv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:gy(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(qx(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Dw({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new dy("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new dy("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new dy("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new dy("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new hy("Legacy serialization format not supported yet.");n=t}else Wr(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,a=t;const s=new e(a);if(!(s instanceof Lw))throw new py(`Sequential.fromConfig called on non-Sequential input: ${s}`);for(const i of n){const e=Ov(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new hy("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new hy("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}Lw.className="Sequential",gc(Lw);class Mw extends fc{getConfig(){return{}}}class zw extends Mw{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new py(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Kd(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}zw.className="elu",gc(zw);class Pw extends Mw{apply(e){return Vh(e)}}Pw.className="selu",gc(Pw);class Bw extends Mw{apply(e){return Uh(e)}}Bw.className="relu",gc(Bw);class Ww extends Mw{apply(e){return pu((()=>Ch(6,Uh(e))))}}Ww.className="relu6",gc(Ww);class Uw extends Mw{apply(e){return e}}Uw.className="linear",gc(Uw);class jw extends Mw{apply(e){return Hh(e)}}jw.className="sigmoid",gc(jw);class Vw extends Mw{apply(e){return function(e){return pu((()=>{const t=rc(.5,ic(.2,e));return Fd(t,0,1)}))}(e)}}Vw.className="hardSigmoid",gc(Vw);class Gw extends Mw{apply(e){return Zh(e)}}Gw.className="softplus",gc(Gw);class Hw extends Mw{apply(e){return function(e){return pu((()=>sc(e,rc(Ic(e),1))))}(e)}}Hw.className="softsign",gc(Hw);class qw extends Mw{apply(e){return rp(e)}}qw.className="tanh",gc(qw);class Kw extends Mw{apply(e){return Jh(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Kw.className="softmax",gc(Kw);class Xw extends Mw{apply(e){return ch(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Xw.className="logSoftmax",gc(Xw);class Yw extends Mw{apply(e){return pu((()=>pu((()=>{const t=Math.sqrt(2),n=ic(.5,rc(1,Yd(sc(e,t))));return ic(e,n)}))))}}Yw.className="gelu",gc(Yw);class Qw extends Mw{apply(e){return pu((()=>ic(.5,ic(e,rc(1,rp(ic(oc(sc(2,Math.PI)),rc(e,ic(.044715,wc(e,3))))))))))}}Qw.className="gelu_new",gc(Qw);class Jw extends Mw{apply(e){return pu((()=>ic(e,rp(Zh(e)))))}}Jw.className="mish",gc(Jw);class Zw extends Mw{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return pu((()=>ic(Hh(ic(e,t)),e)))}}function ek(e){return e.getClassName()}function tk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cy(e,mc.getMap().classNameMap,t,"activation")}function nk(e){if(null==e){const e={className:"linear",config:{}};return tk(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},tk(t)}return e instanceof Mw?e:tk(e)}function rk(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}Zw.className="swish",gc(Zw);class ak extends fc{}class sk extends ak{constructor(e){super(),rk(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return pu((()=>{let t=_h([1]);return this.hasL1&&(t=rc(t,uh(ic(this.l1,Ic(e))))),this.hasL2&&(t=rc(t,uh(ic(this.l2,bx(e))))),Nd(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}sk.className="L1L2",gc(sk);const ik={l1l2:"L1L2"};function ok(e){return Iy(e)}function lk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cy(e,mc.getMap().classNameMap,t,"regularizer")}function uk(e){if(null==e)return null;if("string"===typeof e){return lk({className:e in ik?ik[e]:e,config:{}})}return e instanceof ak?e:lk(e)}class ck extends av{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Hx(e);let n=Uh(e);return null!=this.maxValue&&(n=Fd(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}ck.className="ReLU",gc(ck);class dk extends av{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Hx(e);return sh(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}dk.className="LeakyReLU",gc(dk);class hk extends av{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=jx(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=uk(e.alphaRegularizer),this.alphaConstraint=Sv(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new hy(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=qx(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Zx({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Hx(e),Oh(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ux(this.alphaInitializer),alphaRegularizer:ok(this.alphaRegularizer),alphaConstraint:wv(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}hk.className="PReLU",gc(hk);class pk extends av{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new py(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Hx(e);return Kd(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}pk.className="ELU",gc(pk);class fk extends av{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Hx(e);return ic(n,tc(rh(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}fk.className="ThresholdedReLU",gc(fk);class mk extends av{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Kw).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return pu((()=>{let n=Hx(e);const r=t.mask;if(null!=r){const e=ic(kc(Ah(n.shape),tc(r,n.dtype)),dc(-1e9));n=rc(n,e)}return this.axis instanceof Array?this.axis.length>1?Qd(kc(n,xh(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function gk(e,t,n){if("number"===typeof e)return gy(e,t);if(e.length!==t)throw new hy(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){const s=e[a];if((r=s)!==parseInt(r.toString(),10))throw new hy(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e;var r}function bk(e,t,n,r){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function yk(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+nx([n-t,0]);else{if("same"!==r)throw new hy(`Unsupport padding mode: ${r}.`);e*=t}return e}function xk(e,t){return pu((()=>(Gy(t),"channelsFirst"===t?dp(e,[0,2,3,1]):e)))}function vk(e,t){return pu((()=>(Gy(t),"channelsFirst"===t?dp(e,[0,2,3,4,1]):e)))}function wk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return pu((()=>{if(null==s&&(s="channelsLast"),Gy(s),3!==e.shape.length)throw new hy(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new hy(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new hy(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(e=dp(e,[0,2,1])),"causal"===a)throw new py("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Bd(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=xx(o,n)),o}))}function kk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return pu((()=>{if(null==s&&(s="channelsLast"),Gy(s),3!==e.rank&&4!==e.rank)throw new hy(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new hy(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=xk(e,s);if("causal"===a)throw new py("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Cp({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=dp(l,[0,3,1,2])),l}))}function Sk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return pu((()=>{if(null==s&&(s="channelsLast"),Gy(s),4!==e.rank&&5!==e.rank)throw new hy(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new hy(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=vk(e,s);if("causal"===a)throw new py("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=jd(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=xx(o,n)),"channelsFirst"===s&&(o=dp(o,[0,4,1,2,3])),o}))}mk.className="Softmax",gc(mk);class Ik extends av{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ik.verifyArgs(t),this.rank=e,Ay(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new py(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=gk(t.kernelSize,e,"kernelSize"),this.strides=gk(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Hy(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Gy(this.dataFormat),this.activation=nk(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=jx(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Sv(t.biasConstraint),this.biasRegularizer=uk(t.biasRegularizer),this.activityRegularizer=uk(t.activityRegularizer),this.dilationRate=gk(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new hy(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new hy(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new hy(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(by("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!_y(e.kernelSize,"number",1,3))throw new hy(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ek(this.activation),useBias:this.useBias,biasInitializer:Ux(this.biasInitializer),biasRegularizer:ok(this.biasRegularizer),activityRegularizer:ok(this.activityRegularizer),biasConstraint:wv(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Nk extends Ik{constructor(e,t){super(e,t),this.kernel=null,Nk.verifyArgs(t),this.filters=t.filters,Ay(this.filters,"filters"),this.kernelInitializer=jx(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Sv(t.kernelConstraint),this.kernelRegularizer=uk(t.kernelRegularizer)}build(e){e=qx(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new hy(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return pu((()=>{let t;e=Hx(e);const n=null==this.bias?null:this.bias.read(),r=Dy(this.activation.getClassName());if(null!=r&&2===this.rank)t=kk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=wk(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=kk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new py("convolutions greater than 3D are not implemented yet.");t=Sk(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=qx(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const e=bk(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Ux(this.kernelInitializer),kernelRegularizer:ok(this.kernelRegularizer),kernelConstraint:wv(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new hy(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Ck extends Nk{constructor(e){super(2,e),Ck.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!_y(e.kernelSize,"number",1,2))throw new hy(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Ck.className="Conv2D",gc(Ck);class Tk extends Nk{constructor(e){super(3,e),Tk.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new hy(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Tk.className="Conv3D",gc(Tk);class Ek extends Ck{constructor(e){if(super(e),this.inputSpec=[new Zx({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new hy(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=qx(e)).length)throw new hy("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new hy("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Zx({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return pu((()=>{let t=Hx(e);if(4!==t.shape.length)throw new hy(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const i=n[a],o=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,yk(i,c,l,this.padding),yk(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=dp(t,[0,2,3,1]));let p=Ud(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=dp(p,[0,3,1,2])),null!=this.bias&&(p=xx(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=qx(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=yk(t[r],o,s,this.padding),t[a]=yk(t[a],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ek.className="Conv2DTranspose",gc(Ek);class $k extends Tk{constructor(e){if(super(e),this.inputSpec=[new Zx({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new hy(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=qx(e)).length)throw new hy("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new hy("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Zx({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return pu((()=>{let t=Hx(e);if(5!==t.shape.length)throw new hy(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s,i;"channelsFirst"===this.dataFormat?(i=2,a=3,s=4):(i=1,a=2,s=3);const o=n[i],l=n[a],u=n[s],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,yk(o,p,c,this.padding),yk(l,f,d,this.padding),yk(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=dp(t,[0,2,3,4,1]));let b=Gd(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=dp(b,[0,4,1,2,3])),null!==this.bias&&(b=xx(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){const t=(e=qx(e)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=yk(t[r],u,i,this.padding),t[a]=yk(t[a],c,o,this.padding),t[s]=yk(t[s],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}$k.className="Conv3DTranspose",gc($k);class Rk extends Nk{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new hy("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new hy("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new hy(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=jx(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=uk(t.depthwiseRegularizer),this.depthwiseConstraint=Sv(t.depthwiseConstraint),this.pointwiseInitializer=jx(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=uk(t.pointwiseRegularizer),this.pointwiseConstraint=Sv(t.pointwiseConstraint)}build(e){if((e=qx(e)).length<this.rank+2)throw new hy(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new hy(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Zx({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return pu((()=>{let t;if(e=Hx(e),1===this.rank)throw new py("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=dp(e,[0,2,3,1])),t=Gh(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=xx(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=dp(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ux(this.depthwiseInitializer),e.pointwiseInitializer=Ux(this.pointwiseInitializer),e.depthwiseRegularizer=ok(this.depthwiseRegularizer),e.pointwiseRegularizer=ok(this.pointwiseRegularizer),e.depthwiseConstraint=wv(this.depthwiseConstraint),e.pointwiseConstraint=wv(this.pointwiseConstraint),e}}Rk.className="SeparableConv";class _k extends Rk{constructor(e){super(2,e)}}_k.className="SeparableConv2D",gc(_k);class Ak extends Nk{constructor(e){super(1,e),Ak.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!_y(e.kernelSize,"number",1,1))throw new hy(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Ak.className="Conv1D",gc(Ak);class Fk extends av{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return pu((()=>{if(e=Hx(e),"channelsLast"===this.dataFormat){const t=cx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return cx(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=cx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return cx(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Fk.className="Cropping2D",gc(Fk);class Dk extends av{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gy(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Ry(By,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return pu((()=>{let t=Hx(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=dp(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?pf.resizeNearestNeighbor(t,[e,r]):pf.resizeBilinear(t,[e,r]);return dp(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?pf.resizeNearestNeighbor(t,[e,r]):pf.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Dk.className="UpSampling2D",gc(Dk);class Ok extends Ik{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=jx(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Sv(e.depthwiseConstraint),this.depthwiseRegularizer=uk(e.depthwiseRegularizer)}build(e){if((e=qx(e)).length<4)throw new hy(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new hy(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return pu((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return pu((()=>{null==a&&(a="channelsLast"),Gy(a);let i=xk(e,a);if(4!==e.rank)throw new hy(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new hy(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=qd(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=dp(i,[0,3,1,2])),i}))}(e=Hx(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=xx(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=qx(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=bk(t,this.kernelSize[0],this.padding,this.strides[0]),s=bk(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ux(this.depthwiseInitializer),e.depthwiseRegularizer=ok(this.depthwiseRegularizer),e.depthwiseConstraint=wv(this.depthwiseRegularizer),e}}function Lk(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new hy("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function Mk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return pu((()=>{const l=t.shape.length;if(l<3)throw new hy(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(rx(2,l));if(t=dp(t,u),null!=s)throw new py("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=tc(tc(a,"bool"),"float32"),a.rank===l-1&&(a=Jd(a,-1)),a=dp(a,u)),r&&(t=jh(t,0),null!=a&&(a=jh(a,0)));const c=[];let d,h=n;const p=t.shape[0],f=op(t);let m,g;null!=a&&(m=op(a));for(let t=0;t<p;++t){const n=f[t],r=pu((()=>e(n,h)));if(null==a)d=r[0],h=r[1];else{const e=pu((()=>{const e=m[t],n=kc(Fh(e),e);return{output:rc(ic(r[0],e),ic(h[0],n)),newStates:h.map(((t,a)=>rc(ic(r[1][a],e),ic(t,n))))}}));d=e.output,h=e.newStates}o&&c.push(d)}if(o){g=np(c,1)}return[d,g,h]}))}Ok.className="DepthwiseConv2D",gc(Ok);class zk extends av{constructor(e){let t;if(super(e),null==e.cell)throw new hy("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Hk({cells:e.cell}):e.cell,null==t.stateSize)throw new hy("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Zx({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return rx(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Vx(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return pu((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new py("Constants support is not implemented in RNN yet.");Vx(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Zx({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Gr(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new hy(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map((e=>new Zx({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];pu((()=>{if(!this.stateful)throw new cy("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new hy("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>_h([n,e]))):this.states_=[_h([n,this.cell.stateSize])];else if(null==e)fu(this.states_),null!=this.keptStates&&(fu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>_h([n,e]))):this.states_[0]=_h([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new hy(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):fu(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!Gr(r.shape,s))throw new hy(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>mu(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=Lk(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Zx({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof ev){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return pu((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=Hx(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new hy(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=Mk(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return pu((()=>{let t=_h(e.shape);return t=uh(t,[1,2]),t=ox(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?px(t,[1,e]):t)):this.cell.stateSize>1?[px(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===zk.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Ov(t.cell,n);return new e(Object.assign(t,{cell:r}))}}zk.className="RNN",gc(zk);class Pk extends av{}class Bk extends Pk{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ay(this.units,"units"),this.activation=nk(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=uk(e.kernelRegularizer),this.recurrentRegularizer=uk(e.recurrentRegularizer),this.biasRegularizer=uk(e.biasRegularizer),this.kernelConstraint=Sv(e.kernelConstraint),this.recurrentConstraint=Sv(e.recurrentConstraint),this.biasConstraint=Sv(e.biasConstraint),this.dropout=tx([1,nx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=tx([1,nx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=qx(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return pu((()=>{if(2!==e.length)throw new hy(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=qk({ones:()=>Fh(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=qk({ones:()=>Fh(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;a=mx(null!=s?ic(e,s):e,this.kernel.read()),null!=this.bias&&(a=xx(a,this.bias.read())),null!=i&&(n=ic(n,i));let o=rc(a,mx(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ek(this.activation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),recurrentInitializer:Ux(this.recurrentInitializer),biasInitializer:Ux(this.biasInitializer),kernelRegularizer:ok(this.kernelRegularizer),recurrentRegularizer:ok(this.recurrentRegularizer),biasRegularizer:ok(this.biasRegularizer),activityRegularizer:ok(this.activityRegularizer),kernelConstraint:wv(this.kernelConstraint),recurrentConstraint:wv(this.recurrentConstraint),biasConstraint:wv(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Bk.className="SimpleRNNCell",gc(Bk);class Wk extends zk{constructor(e){e.cell=new Bk(e),super(e)}call(e,t){return pu((()=>{null!=this.cell.dropoutMask&&(fu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(fu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}}Wk.className="SimpleRNN",gc(Wk);class Uk extends Pk{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new hy("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ay(this.units,"units"),this.activation=nk(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=nk(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=uk(e.kernelRegularizer),this.recurrentRegularizer=uk(e.recurrentRegularizer),this.biasRegularizer=uk(e.biasRegularizer),this.kernelConstraint=Sv(e.kernelConstraint),this.recurrentConstraint=Sv(e.recurrentConstraint),this.biasConstraint=Sv(e.biasConstraint),this.dropout=tx([1,nx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=tx([1,nx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=qx(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return pu((()=>{if(2!==e.length)throw new hy(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=qk({ones:()=>Fh(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=qk({ones:()=>Fh(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=ic(e,a[0]));let u=mx(e,this.kernel.read());this.useBias&&(u=xx(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ic(r,s[0]));const c=this.recurrentKernel.read(),[d,h]=ep(c,[2*this.units,this.units],c.rank-1),p=mx(r,d),[f,m,g]=ep(u,3,u.rank-1),[b,y]=ep(p,2,p.rank-1);i=this.recurrentActivation.apply(rc(f,b)),o=this.recurrentActivation.apply(rc(m,y));const x=mx(ic(o,r),h);l=this.activation.apply(rc(g,x));const v=rc(ic(i,r),ic(rc(1,Eh(i)),l));return[v,v]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ek(this.activation),recurrentActivation:ek(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),recurrentInitializer:Ux(this.recurrentInitializer),biasInitializer:Ux(this.biasInitializer),kernelRegularizer:ok(this.kernelRegularizer),recurrentRegularizer:ok(this.recurrentRegularizer),biasRegularizer:ok(this.biasRegularizer),activityRegularizer:ok(this.activityRegularizer),kernelConstraint:wv(this.kernelConstraint),recurrentConstraint:wv(this.recurrentConstraint),biasConstraint:wv(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Uk.className="GRUCell",gc(Uk);class jk extends zk{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Uk(e),super(e)}call(e,t){return pu((()=>{null!=this.cell.dropoutMask&&(fu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(fu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}jk.className="GRU",gc(jk);class Vk extends Pk{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ay(this.units,"units"),this.activation=nk(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=nk(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=uk(e.kernelRegularizer),this.recurrentRegularizer=uk(e.recurrentRegularizer),this.biasRegularizer=uk(e.biasRegularizer),this.kernelConstraint=Sv(e.kernelConstraint),this.recurrentConstraint=Sv(e.recurrentConstraint),this.biasConstraint=Sv(e.biasConstraint),this.dropout=tx([1,nx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=tx([1,nx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=qx(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends Ix{apply(t,r){const a=e.apply([n]),s=(new Cx).apply([n]),i=e.apply([2*n]);return hx(hx(a,s),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return pu((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new hy(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=qk({ones:()=>Fh(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=qk({ones:()=>Fh(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=ic(e,s[0]));let d=mx(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ic(r,i[0])),d=rc(d,mx(r,this.recurrentKernel.read())),this.useBias&&(d=xx(d,this.bias.read()));const[h,p,f,m]=ep(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=rc(ic(l,a),ic(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=ic(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ek(this.activation),recurrentActivation:ek(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),recurrentInitializer:Ux(this.recurrentInitializer),biasInitializer:Ux(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ok(this.kernelRegularizer),recurrentRegularizer:ok(this.recurrentRegularizer),biasRegularizer:ok(this.biasRegularizer),activityRegularizer:ok(this.activityRegularizer),kernelConstraint:wv(this.kernelConstraint),recurrentConstraint:wv(this.recurrentConstraint),biasConstraint:wv(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Vk.className="LSTMCell",gc(Vk);class Gk extends zk{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Vk(e),super(e)}call(e,t){return pu((()=>{null!=this.cell.dropoutMask&&(fu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(fu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Gk.className="LSTM",gc(Gk);class Hk extends Pk{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return pu((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],s=0===i?[e[0]].concat(n):[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;Vx(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{Xy(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of t.cells)r.push(Ov(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Qx(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}Jx(t)}}function qk(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):vx(t(),n),o=()=>wx(i,t,r);if(!a||a<=1)return mu(o().clone());return Array(a).fill(void 0).map(o).map((e=>mu(e.clone())))}Hk.className="StackedRNNCells",gc(Hk);var Kk=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};class Xk extends zk{constructor(e){if(e.unroll)throw new py("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new py("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Zx({ndim:5})]}call(e,t){return pu((()=>{if(null!=this.cell.dropoutMask&&(fu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(fu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new hy("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return pu((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=_h([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];pu((()=>{if(!this.stateful)throw new cy("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new hy("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>_h(a))):this.states_=[_h(a)];else if(null==e)fu(this.states_),null!=this.keptStates&&(fu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>_h(a))):this.states_[0]=_h(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new hy(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):fu(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!Gr(n.shape,r))throw new hy(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>mu(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=bk(l,r[0],a,s[0],i[0]),d=bk(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}Xk.className="ConvRNN2D";class Yk extends Vk{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ay(this.filters,"filters"),this.kernelSize=gk(n,2,"kernelSize"),this.kernelSize.forEach((e=>Ay(e,"kernelSize"))),this.strides=gk(r||1,2,"strides"),this.strides.forEach((e=>Ay(e,"strides"))),this.padding=a||"valid",Hy(this.padding),this.dataFormat=s||"channelsLast",Gy(this.dataFormat),this.dilationRate=gk(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>Ay(e,"dilationRate")))}build(e){var t;e=qx(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new hy(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends Ix{apply(e,t){return dx([n.apply([r]),Ah([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return pu((()=>{if(3!==e.length)throw new hy(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=qk({ones:()=>Fh(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?ic(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=qk({ones:()=>Fh(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3);const[b,y,x,v]=ep(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?ep(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,w,this.padding),u=this.inputConv(u,y,k,this.padding),c=this.inputConv(c,x,S,this.padding),d=this.inputConv(d,v,I,this.padding);const[N,C,T,E]=ep(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const $=this.recurrentActivation.apply(rc(l,p)),R=this.recurrentActivation.apply(rc(u,f)),_=rc(ic(R,s),ic($,this.activation.apply(rc(c,m)))),A=ic(this.recurrentActivation.apply(rc(d,g)),this.activation.apply(_));return[A,A,_]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=Kk(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const a=Pd(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?xx(a,n,this.dataFormat):a}recurrentConv(e,t){return Pd(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Yk.className="ConvLSTM2DCell",gc(Yk);class Qk extends Xk{constructor(e){const t=new Yk(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Qk.className="ConvLSTM2D",gc(Qk);class Jk extends av{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return wx((()=>vx(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Jk.className="Dropout",gc(Jk);class Zk extends Jk{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Zk.className="SpatialDropout1D",gc(Zk);class eS extends av{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ay(this.units,"units"),this.activation=nk(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=jx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Sv(e.kernelConstraint),this.biasConstraint=Sv(e.biasConstraint),this.kernelRegularizer=uk(e.kernelRegularizer),this.biasRegularizer=uk(e.biasRegularizer),this.activityRegularizer=uk(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=qx(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=qx(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e),r=Dy(this.activation.getClassName());let a;return null!=r?a=mx(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=mx(n,this.kernel.read()),null!=this.bias&&(a=xx(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:ek(this.activation),useBias:this.useBias,kernelInitializer:Ux(this.kernelInitializer),biasInitializer:Ux(this.biasInitializer),kernelRegularizer:ok(this.kernelRegularizer),biasRegularizer:ok(this.biasRegularizer),activityRegularizer:ok(this.activityRegularizer),kernelConstraint:wv(this.kernelConstraint),biasConstraint:wv(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}eS.className="Dense",gc(eS);class tS extends av{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=qx(e);for(const t of e.slice(1))if(null==t)throw new hy(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ex(e,1)]}call(e,t){return pu((()=>{this.invokeCallHook(e,t);let n=Hx(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=dp(n,e)}return function(e){if(e.rank<=1)throw new hy(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],ex(e.shape,1)];return Nd(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}tS.className="Flatten",gc(tS);class nS extends av{constructor(e){super(e),this.supportsMasking=!0,this.activation=nk(e.activation)}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e);return this.activation.apply(n)}))}getConfig(){const e={activation:ek(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}nS.className="Activation",gc(nS);class rS extends av{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return pu((()=>{return e=Hx(e),t=e,n=this.n,pu((()=>{if(2!==t.shape.length)throw new hy(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return px(ox(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}rS.className="RepeatVector",gc(rS);class aS extends av{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,s=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==s)throw new hy("Can only specifiy one unknown dimension.");s=o}else a*=e}const i=ex(e);if(null!==s){if(0===a||i%a!==0)throw new hy(n);r[s]=i/a}else if(i!==a)throw new hy(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Nd(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}aS.className="Reshape",gc(aS);class sS extends av{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=rx(1,e.dims.length+1);if(!Gr(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Zx({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=qx(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return dp(Hx(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}sS.className="Permute",gc(sS);class iS extends av{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Hx(e);return ld($h(n,this.maskValue),-1)}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e),r=ld($h(n,this.maskValue),-1,!0);return ic(n,tc(r,n.dtype))}))}}iS.className="Masking",gc(iS);class oS extends av{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(vy(e.inputLength))}this.inputDim=e.inputDim,Ay(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ay(this.outputDim,"outputDim"),this.embeddingsInitializer=jx(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=uk(e.embeddingsRegularizer),this.activityRegularizer=uk(e.activityRegularizer),this.embeddingsConstraint=Sv(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return pu((()=>this.maskZero?(e=Hx(e),$h(e,uc(e))):null))}computeOutputShape(e){if(e=qx(e),null==this.inputLength)return[...e,this.outputDim];const t=vy(this.inputLength);if(t.length!==e.length-1)throw new hy(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new hy(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return pu((()=>{this.invokeCallHook(e,t);let n=Hx(e);"int32"!==n.dtype&&(n=ix(n,"int32"));const r=gx(this.embeddings.read(),Nd(n,[n.size]));return Nd(r,qx(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ux(this.embeddingsInitializer),embeddingsRegularizer:ok(this.embeddingsRegularizer),activityRegularizer:ok(this.activityRegularizer),embeddingsConstraint:wv(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}oS.className="Embedding",gc(oS);class lS extends av{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new py}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new hy("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[qx(e)]),e.length<2)throw new hy(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=Ey(t),t.length>1)throw new hy(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===Ey(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return pu((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=nx(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=ox(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const s of e){const e=s.rank;if(null==e){const e=s.shape,r=e[0],a=e.slice(1).concat([r]);let i=Nd(s,[r].concat(ex(e.slice(1))));i=dp(i,[1,0]),i=Nd(i,a),t.push(i),n=!0}else if(e>1){const r=rx(1,e).concat([0]);t.push(dp(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Nd(dp(Nd(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(rx(0,a-1));r=dp(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=Ey(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return pu((()=>{if(null==t)return null;if(!Array.isArray(t))throw new hy("`mask` should be an Array");if(!Array.isArray(e))throw new hy("`inputs` should be an Array");if(t.length!==e.length)throw new hy(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Jd(e,0))))[0];for(let e=1;e<t.length-1;++e)n=vh(n,t[e]);return n}))}}class uS extends lS{constructor(e){super(e)}mergeFunction(e){return pu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=rc(t,e[n]);return t}))}}uS.className="Add",gc(uS);class cS extends lS{constructor(e){super(e)}mergeFunction(e){return pu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ic(t,e[n]);return t}))}}cS.className="Multiply",gc(cS);class dS extends lS{constructor(e){super(e)}mergeFunction(e){return pu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=rc(t,e[n]);return ic(1/e.length,t)}))}}dS.className="Average",gc(dS);class hS extends lS{constructor(e){super(e)}mergeFunction(e){return pu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ec(t,e[n]);return t}))}}hS.className="Maximum",gc(hS);class pS extends lS{constructor(e){super(e)}mergeFunction(e){return pu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ch(t,e[n]);return t}))}}pS.className="Minimum",gc(pS);class fS extends lS{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new hy("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let a=!1;for(const e of n)if(Gr(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new hy("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return pu((()=>dx(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new hy("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new hy("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new hy("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new hy(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return pu((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(tc(Fh(e[s]),"bool")):t[s].rank<e[s].rank?r.push(Jd(t[s],-1)):r.push(t[s]);const a=Dd(r,this.axis);return od(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function mS(e,t){for(;e<0;)e+=t;return e}fS.className="Concatenate",gc(fS);class gS extends lS{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Wr(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new py("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new hy(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new hy(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>mS(t,e[n].shape.length))):[mS(this.axes,n.shape.length),mS(this.axes,r.shape.length)],this.normalize&&(n=Lv(n,t[0]),r=Lv(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new py("batchDot is not implemented for tensors of 4D or higher rank yet");if(Wr(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Wr(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new py("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return pu((()=>{let n,i;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=Nd(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Nd(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?uh(ic(e,t),s[0]):uh(ic(dp(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=wh(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=tp(i,t)}return 1===i.shape.length&&(i=Jd(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[mS(this.axes,e.length),mS(this.axes,t.length)],n}computeOutputShape(e){Wr(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new py("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}gS.className="Dot",gc(gS);class bS extends av{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e);return wx((()=>rc(fx(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}bS.className="GaussianNoise",gc(bS);class yS extends av{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return pu((()=>{this.invokeCallHook(e,t);const n=Hx(e);if(this.rate>0&&this.rate<1){return wx((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return ic(n,fx(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}yS.className="GaussianDropout",gc(yS);class xS extends av{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Hx(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return pu((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=Hx(e),r=-1.7580993408473766;let a=ah(Bh(n),this.rate);a=ix(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=rc(ic(t,a),ic(rc(a,-1),r));return rc(ic(o,s),i)};return wx(r,(()=>Hx(e)),t.training||!1)}return e}))}}function vS(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=$d(e,t,n,r,a,i);else if(3===e.rank)s=Rd(e,t,n,r,a,i);else{if(4!==e.rank)throw new py(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=_d(e,t,n,r,a,i)}return s}function wS(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Gr(r.slice().sort(),rx(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return pu((()=>{const s=Th(e,r),i=s.mean,o=s.variance;return[vS(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return pu((()=>{const s=Th(e,r),i=s.mean,o=s.variance,l=[];for(const t of rx(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Nd(i,l),c=Nd(o,l),d=null==t?null:Nd(t,l),h=null==n?null:Nd(n,l);return[vS(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}xS.className="AlphaDropout",gc(xS);class kS extends av{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=jx(e.betaInitializer||"zeros"),this.gammaInitializer=jx(e.gammaInitializer||"ones"),this.movingMeanInitializer=jx(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jx(e.movingVarianceInitializer||"ones"),this.betaConstraint=Sv(e.betaConstraint),this.gammaConstraint=Sv(e.gammaConstraint),this.betaRegularizer=uk(e.betaRegularizer),this.gammaRegularizer=uk(e.gammaRegularizer)}build(e){e=qx(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new hy(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Zx({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return pu((()=>{const n=null!=t.training&&t.training,r=Hx(e),a=r.shape,s=a.length,i=rx(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);const l=gy(1,s);l[o]=a[o];const u=i.slice();u.sort();const c=!Gr(u,rx(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const e=Nd(this.movingMean.read(),l),t=Nd(this.movingVariance.read(),l),n=this.center?Nd(this.beta.read(),l):null,a=this.scale?Nd(this.gamma.read(),l):null;return vS(r,e,t,n,a,this.epsilon)}return vS(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=wS(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{pu((()=>{const r=1-n,a=e.read(),s=ic(kc(a,t),r);e.write(kc(a,s))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ux(this.betaInitializer),gammaInitializer:Ux(this.gammaInitializer),movingMeanInitializer:Ux(this.movingMeanInitializer),movingVarianceInitializer:Ux(this.movingVarianceInitializer),betaRegularizer:ok(this.betaRegularizer),gammaRegularizer:ok(this.gammaRegularizer),betaConstraint:wv(this.betaConstraint),gammaConstraint:wv(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}kS.className="BatchNormalization",gc(kS);class SS extends av{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=jx(e.betaInitializer||"zeros"),this.gammaInitializer=jx(e.gammaInitializer||"ones"),this.betaRegularizer=uk(e.betaRegularizer),this.gammaRegularizer=uk(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=qx(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Ey(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=Hx(e),r=n.shape,a=r.length;return pu((()=>{let{mean:e,variance:t}=Th(n,this.axis,!0);const s=gy(1,a);for(const n of this.axis)s[n]=r[n];const i=e=>null!=e&&e.shape.length!==a?Nd(e,s):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=Zd(e,u),t=Zd(t,u),null!=o&&(o=Zd(o,c)),null!=l&&(l=Zd(l,c)),vS(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ux(this.betaInitializer),gammaInitializer:Ux(this.gammaInitializer),betaRegularizer:ok(this.betaRegularizer),gammaRegularizer:ok(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}SS.className="LayerNormalization",gc(SS);class IS extends av{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new hy(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new hy(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new hy(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Zx({ndim:4})]}computeOutputShape(e){let t,n;return e=qx(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return pu((()=>{return t=Hx(e),n=this.padding,r=this.dataFormat,pu((()=>{if(4!==t.rank)throw new hy(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new hy("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new hy(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Dh(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function NS(e,t,n,r,a,s){return pu((()=>{let i;Gy(a),qy(s),Hy(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=xk(e,a);const o="same"===r?"same":"valid";return i="max"===s?kh(e,t,n,o):Cd(e,t,n,o),"channelsFirst"===a&&(i=dp(i,[0,3,1,2])),i}))}function CS(e,t,n,r,a,s){return pu((()=>{let i;Gy(a),qy(s),Hy(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=vk(e,a);const o="same"===r?"same":"valid";return i="max"===s?Sh(e,t,n,o):Td(e,t,n,o),"channelsFirst"===a&&(i=dp(i,[0,4,1,2,3])),i}))}IS.className="ZeroPadding2D",gc(IS);class TS extends av{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new hy(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(Ay(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new hy(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}Ay(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Hy(this.padding),this.inputSpec=[new Zx({ndim:3})]}computeOutputShape(e){const t=bk((e=qx(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return pu((()=>{this.invokeCallHook(e,t),e=ox(Hx(e),2);const n=this.poolingFunction(Hx(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return tp(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class ES extends TS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gy(a),Hy(r),NS(e,t,n,r,a,"max")}}ES.className="MaxPooling1D",gc(ES);class $S extends TS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gy(a),Hy(r),NS(e,t,n,r,a,"avg")}}$S.className="AveragePooling1D",gc($S);class RS extends av{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new hy(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ay(this.poolSize,"poolSize"),Ay(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gy(this.dataFormat),Hy(this.padding),this.inputSpec=[new Zx({ndim:4})]}computeOutputShape(e){e=qx(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=bk(t,this.poolSize[0],this.padding,this.strides[0]),n=bk(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return pu((()=>(this.invokeCallHook(e,t),this.poolingFunction(Hx(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class _S extends RS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gy(a),Hy(r),NS(e,t,n,r,a,"max")}}_S.className="MaxPooling2D",gc(_S);class AS extends RS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gy(a),Hy(r),NS(e,t,n,r,a,"avg")}}AS.className="AveragePooling2D",gc(AS);class FS extends av{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new hy(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ay(this.poolSize,"poolSize"),Ay(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gy(this.dataFormat),Hy(this.padding),this.inputSpec=[new Zx({ndim:5})]}computeOutputShape(e){e=qx(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=bk(t,this.poolSize[0],this.padding,this.strides[0]),n=bk(n,this.poolSize[1],this.padding,this.strides[1]),r=bk(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return pu((()=>(this.invokeCallHook(e,t),this.poolingFunction(Hx(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class DS extends FS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gy(a),Hy(r),CS(e,t,n,r,a,"max")}}DS.className="MaxPooling3D",gc(DS);class OS extends FS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gy(a),Hy(r),CS(e,t,n,r,a,"avg")}}OS.className="AveragePooling3D",gc(OS);class LS extends av{constructor(e){super(e),this.inputSpec=[new Zx({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new py}}class MS extends LS{constructor(e){super(e||{})}call(e,t){return pu((()=>{const t=Hx(e);return Ih(t,1)}))}}MS.className="GlobalAveragePooling1D",gc(MS);class zS extends LS{constructor(e){super(e||{})}call(e,t){return pu((()=>{const t=Hx(e);return lh(t,1)}))}}zS.className="GlobalMaxPooling1D",gc(zS);class PS extends av{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Gy(this.dataFormat),this.inputSpec=[new Zx({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new py}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class BS extends PS{call(e,t){return pu((()=>{const t=Hx(e);return"channelsLast"===this.dataFormat?Ih(t,[1,2]):Ih(t,[2,3])}))}}BS.className="GlobalAveragePooling2D",gc(BS);class WS extends PS{call(e,t){return pu((()=>{const t=Hx(e);return"channelsLast"===this.dataFormat?lh(t,[1,2]):lh(t,[2,3])}))}}WS.className="GlobalMaxPooling2D",gc(WS);class US extends av{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Ov(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class jS extends US{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=qx(e)).length<3)throw new hy(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=qx(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return pu((()=>Mk(((e,n)=>[Hx(this.layer.call(e,t)),[]]),e=Hx(e),[],!1,null,null,!1,!0)[1]))}}jS.className="TimeDistributed",gc(jS);class VS extends US{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ov(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Ov(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,Ry(jy,"BidirectionalMergeMode",a),e.weights)throw new py("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):xy(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=Lk(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const s=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new hy("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const r=n.map((e=>new Zx({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new py("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof ev;for(const l of s)if(l instanceof ev!==o)throw new hy("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return pu((()=>{const n=t.initialState;let r,a,s,i;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=jh(a,1)),"concat"===this.mergeMode?i=dx([r,a]):"sum"===this.mergeMode?i=rc(r,a):"ave"===this.mergeMode?i=ic(.5,rc(r,a)):"mul"===this.mergeMode?i=ic(r,a):null==this.mergeMode&&(i=[r,a]),this.returnState?null==this.mergeMode?i.concat(s):[i].concat(s):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Xy(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Xy(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Ov(t.layer);if(delete t.layer,null!=t.numConstants)throw new py("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}VS.className="Bidirectional",gc(VS);class GS extends av{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return pu((()=>("float32"!==(e=Hx(e)).dtype&&(e=ix(e,"float32")),rc(ic(e,this.scale),this.offset))))}}GS.className="Rescaling",gc(GS);const{resizeBilinear:HS,cropAndResize:qS}=pf;class KS extends av{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return pu((()=>{let l,u=!1;const c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=np([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=uu(d,[d.length,4]),p=Wh(0,d.length,1,"int32"),f=qS(l,h,p,[r,a],"nearest");return ix(u?Hx(op(f)):f,o)}))}upsize(e,t,n,r){return pu((()=>ix(HS(e,[t,n]),r)))}call(e,t){return pu((()=>{const t=Hx(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2];let i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=qx(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}KS.className="CenterCrop",gc(KS);class XS extends av{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=qx(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return pu((()=>{let n;if("int32"!==(e=Hx(e)).dtype&&(e=ix(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new hy(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Hx(t.countWeights)}const r=lh(e),a=Nh(e),s=rh(this.numTokens,r).bufferSync().get(0),i=ah(a,0).bufferSync().get(0);if(!s||!i)throw new hy(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=Hx(e);if("int32"!==a.dtype&&(a=ix(a,"int32")),"int"===t)return a;const s=a.shape;if(0===a.rank&&(a=Jd(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=Jd(a,-1)),a.rank>2)throw new hy(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);const i=["multiHot","oneHot"].includes(t),o=a;let l;if(l=Hd(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return ic(l,r);throw new hy("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}XS.className="CategoryEncoding",gc(XS);const YS=new Set(["bilinear","nearest"]);class QS extends av{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!YS.has(e.interpolation))throw new hy(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=qx(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return pu((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return pf.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return pf.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...YS]} are supported`)}))}}QS.className="Resizing",gc(QS);class JS{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}JS.className="RandomSeed";class ZS extends av{constructor(e){super(e),this.randomGenerator=new JS(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}ZS.className="BaseRandomLayer";const eI=new Set(["bilinear","nearest"]);class tI extends ZS{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new hy(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new hy(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new hy(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!eI.has(n))throw new hy(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=qx(e))[2];return[this.imgHeight,-1,t]}call(e,t){return pu((()=>{const t=Hx(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Bh([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return pf.resizeBilinear(e,a);case"nearest":return pf.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...eI]} are supported`)}}))}}tI.className="RandomWidth",gc(tI);var nI,rI;wa().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(nI||(nI={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(rI||(rI={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function aI(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(lI(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const i=aI(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function sI(e){return iI(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:oI)}function iI(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(lI(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=iI(e.map((e=>e[s])),t,n);a[s]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function oI(e){return null===e?null:lI(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function lI(e){let t=!1;if(wa().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof El)&&!(e instanceof Promise)&&!t)}function uI(e){return function(e,t){return aI(e,t)}(e,cI)}function cI(e){return e instanceof El?{value:e.clone(),recurse:!1}:lI(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class dI{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class hI extends dI{constructor(){super(hI.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function pI(e){return new bI(e)}function fI(e,t){return new EI(e,t)}hI.INITIAL_CAPACITY=32;class mI{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new II(this,e)}filter(e){return new kI(this,e)}map(e){return new SI(this,e)}mapAsync(e){return new NI(this,e)}serialMapAsync(e){return new NI(this,e).serial()}flatmap(e){return new TI(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new wI(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:oI;return this.rowMajorBatch(e,t).map((e=>sI(e,n)))}concatenate(e,t){return new EI(new gI([this,e]),t)}take(e){return e<0||null==e?this:new vI(this,e)}skip(e){return e<0||null==e?this:new xI(this,e)}prefetch(e){return new RI(this,e)}shuffle(e,t){return new _I(this,e,t)}serial(){return new yI(this)}}class gI extends mI{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:uI(e),done:!1}}}class bI extends mI{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(FW){throw FW.message=`Error thrown while iterating through a dataset: ${FW.message}`,FW}}}class yI extends mI{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class xI extends mI{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;fu(e.value)}return this.upstream.next()}}class vI extends mI{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class wI extends mI{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class kI extends mI{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;fu(e.value)}}}class SI extends mI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=jl(e.value),n=this.transform(e.value),r=jl(n);for(const a of t)Ul(a,r)||a.dispose();return{value:n,done:!1}}}class II extends mI{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(FW){if(!this.handler(FW))return{value:null,done:!0}}}}class NI extends mI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=jl(e.value),n=await this.transform(e.value),r=jl(n);for(const a of t)Ul(a,r)||a.dispose();return{value:n,done:!1}}}class CI extends mI{constructor(){super(),this.outputQueue=new hI,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class TI extends CI{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=jl(e.value),n=this.transform(e.value),r=jl(n);this.outputQueue.pushAll(n);for(const a of t)Ul(a,r)||a.dispose();return!0}}class EI extends mI{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var $I;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}($I||($I={}));class RI extends mI{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new dI(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class _I extends RI{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Lh.alea(n||dl().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class AI{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Wr(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),FI((async()=>(await n.iterator()).columnMajorBatch(e,t,DI)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,FI((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,FI((async()=>(await t.iterator()).filter((t=>pu((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return FI((async()=>(await t.iterator()).map((t=>pu((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return FI((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return FI((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,FI((async()=>fI(pI((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,FI((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=Lh.alea(t||dl().toString());return FI((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,FI((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function FI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends AI{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function DI(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof El||fl(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof El?np(e):uu(e)}(e),recurse:!1}}return{value:null,recurse:!0}}AI.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function OI(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Wr("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const LI=Tm;class MI extends Or{nextDataId(){return MI.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Dr(this,du())}write(e,t,n){this.firstUse&&(this.firstUse=!1,wa().get("IS_NODE")&&zo("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ra(n[0])){const a=n.map((e=>hl(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return Gf(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>pl(e)));return ec(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ec(e.shape,e.dtype,t)}makeOutput(e,t,n){return du().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=dl();e();return{kernelMs:dl()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){OI([e],"where");const t=this.readSync(e.dataId);return LI(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}MI.nextDataId=0;function zI(e){return(t,n,r)=>{const a=ea(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function PI(e,t,n){return BI(e,zI(t),n)}function BI(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r;const{x:o}=a;OI(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=Nm(u)}else c=u;const d=n||o.dtype,h=t(c,d,s);return l.makeTensorInfo(o.shape,d,h)}}gu("cpu",(()=>new MI),1);const WI=PI(Is,(e=>e>=0?e:Math.exp(e)-1)),UI={kernelName:Is,backendName:"cpu",kernelFunc:WI};function jI(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const VI={kernelName:Ws,backendName:"cpu",kernelFunc:jI};function GI(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;OI([a],"leakyRelu");const i=Vr(a.shape),o=n.data.get(a.dataId).values,l=Zr("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}const HI={kernelName:qs,backendName:"cpu",kernelFunc:GI};function qI(e){return(t,n,r,a,s)=>{const i=Tc(t,n),o=i.length,l=la(i),u=Zr(s,Vr(i)),c=t.length,d=n.length,h=la(t),p=la(n),f=Nc(t,i),m=Nc(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],a[g%a.length]);else for(let g=0;g<u.length;++g){const t=ga(g,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const s=ma(n,c,h),i=t.slice(-d);m.forEach((e=>i[e]=0));const b=ma(i,d,p);u[g]=e(r[s],a[b])}return[u,i]}}const KI=qI(((e,t)=>e<0?t*e:e));function XI(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;OI([r,a],"prelu");const s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=KI(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}const YI={kernelName:Ei,backendName:"cpu",kernelFunc:XI},QI=PI(Li,(e=>Math.max(0,e))),JI={kernelName:Li,backendName:"cpu",kernelFunc:QI},ZI=PI(Ui,(e=>Math.min(Math.max(0,e),6))),eN={kernelName:Ui,backendName:"cpu",kernelFunc:ZI},tN=zI((e=>1/(1+Math.exp(-e)))),nN=PI(to,(e=>1/(1+Math.exp(-e)))),rN={kernelName:to,backendName:"cpu",kernelFunc:nN};function aN(e,t,n,r,a){if("linear"===n)return jI({inputs:{x:t},backend:e});if("relu"===n)return QI({inputs:{x:t},backend:e});if("elu"===n)return WI({inputs:{x:t},backend:e});if("relu6"===n)return ZI({inputs:{x:t},backend:e});if("prelu"===n)return XI({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return GI({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return nN({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function sN(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}const iN={kernelName:Ja,backendName:"cpu",kernelFunc:sN};function oN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return sN({inputs:{real:oN(e,t,"float32"),imag:oN(e,t,"float32")},backend:e})}const r=ha(Vr(t),n);return e.makeTensorInfo(t,n,r)}function lN(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const uN={kernelName:Di,backendName:"cpu",kernelFunc:lN};function cN(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=cl([0],n),[a,s]=qI(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function dN(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return jI({inputs:{x:a},backend:n});const e=oN(n,a.shape,a.dtype),t=dN({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=sN({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=lN({inputs:{input:a},backend:n}),t=dN({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!ta(a.dtype,s)){const e=jI({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const i=n.data.get(a.dataId).values,[o,l,u]=cN(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}const hN={kernelName:Xa,backendName:"cpu",kernelFunc:dN};function pN(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:i,b:o}=a,l=s;OI([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?Nm(u):u,h="string"===i.dtype?Nm(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e;const{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){const e=dN({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=dN({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,b,y]=n(i.shape,o.shape,s,u,f,m),x=l.makeTensorInfo(y,"float32",g),v=l.makeTensorInfo(y,"float32",b),w=sN({inputs:{real:x,imag:v},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(x),l.disposeIntermediateTensorInfo(v),w}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function fN(e){return(t,n,r,a,s,i)=>{const o=Tc(t,n),l=Vr(o),u=o.length,c=la(o),d=Zr("float32",l),h=Zr("float32",l),p=Nc(t,o),f=Nc(n,o),m=Gf(r,a),g=Gf(s,i),b=t.length,y=la(t),x=n.length,v=la(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){const t=ga(w,u,c),n=t.slice(-b);p.forEach((e=>n[e]=0));const r=ma(n,b,y),a=t.slice(-x);f.forEach((e=>a[e]=0));const s=ma(a,x,v),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}const mN=qI(((e,t)=>e+t)),gN=fN(((e,t,n,r)=>({real:e+n,imag:t+r}))),bN=pN($a,mN,gN),yN={kernelName:$a,backendName:"cpu",kernelFunc:bN};function xN(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=Vr(a.shape),o=Yr(s,i),l=Vr(o);Wr(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);const u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}const vN={kernelName:Mi,backendName:"cpu",kernelFunc:xN};function wN(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;OI([a,s],"matMul");const l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Vr(f),b=Vr(m),y=Tc(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);Wr(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));const x=o?[b,p,d]:[b,d,p],v=xN({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=xN({inputs:{x:s},backend:n,attrs:{shape:x}}),k=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],I=o?w.shape[1]:w.shape[2],N=Math.max(g,b),C=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,E=la(v.shape),$=la(w.shape),[R,_,A]=i?[E[0],1,E[1]]:[E[0],E[1],1],[F,D,O]=o?[1,$[1],$[0]]:[$[1],1,$[0]],L=S*I,M=ec([N,S,I],v.dtype),z=M.values,P=n.blockSize;for(let B=0;B<N;B++){const e=B%g,t=B%b;for(let n=0;n<S;n+=P){const r=Math.min(n+P,S);for(let a=0;a<I;a+=P){const s=Math.min(a+P,I);for(let i=0;i<k;i+=P){const o=Math.min(i+P,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=C[e*R+l*_+a*A]*T[a*F+n*D+t*O]}z[B*L+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,M.dtype,M.values)}const kN={kernelName:Va,backendName:"cpu",kernelFunc:wN};const SN={kernelName:Oo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=wN({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=bN({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=aN(n,h,c,o,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function IN(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const NN={kernelName:Ca,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;OI(t,"abs");let r=new Float32Array(Vr(t.shape));return r=IN(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},CN=PI(Ta,(e=>Math.acos(e))),TN={kernelName:Ta,backendName:"cpu",kernelFunc:CN},EN=PI(Ea,(e=>Math.acosh(e))),$N={kernelName:Ea,backendName:"cpu",kernelFunc:EN};const RN={kernelName:Ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;OI(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),s=ec(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){const e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function _N(e,t,n,r,a){const s=t.length,i=Vr(t),o=la(t),l=la(a),u=Zr(n,Vr(a));for(let c=0;c<i;++c){const t=ga(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[ma(n,s,l)]=e[c]}return u}function AN(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;OI(a,"transpose");const i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];const l=_N(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}const FN={kernelName:To,backendName:"cpu",kernelFunc:AN};const DN={kernelName:_a,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;OI(a,"all");const o=Qr(s,a.shape);let l=o;const u=gh(l,a.shape.length);let c=a;null!=u&&(c=AN({inputs:{x:a},backend:n,attrs:{perm:u}}),l=yh(l.length,a.shape.length)),mh("all",l,c.shape.length);const[d,h]=ph(c.shape,l),p=Vr(h),f=ha(Vr(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=xN({inputs:{x:g},backend:n,attrs:{shape:fh(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const ON={kernelName:Aa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;OI(a,"any");const o=Qr(s,a.shape);let l=o;const u=gh(l,a.shape.length);let c=a;null!=u&&(c=AN({inputs:{x:a},backend:n,attrs:{perm:u}}),l=yh(l.length,a.shape.length)),mh("any",l,c.shape.length);const[d,h]=ph(c.shape,l),p=Vr(h),f=ha(Vr(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=xN({inputs:{x:g},backend:n,attrs:{shape:fh(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const LN={kernelName:Fa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;OI(a,"argMax");let i=Qr(s,a.shape);const o=gh(i,a.shape.length);let l=a;const u=[];null!=o&&(l=AN({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=yh(i.length,l.shape.length)),i=[i[0]],mh("argMax",i,l.shape.length);const[c,d]=ph(l.shape,i),h=ha(Vr(c),"int32"),p=Vr(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a>t&&(t=a,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}};const MN={kernelName:Da,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;OI(a,"argMin");let i=Qr(s,a.shape);const o=gh(i,a.shape.length);let l=a;const u=[];null!=o&&(l=AN({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=yh(i.length,l.shape.length)),i=[i[0]],mh("argMin",i,l.shape.length);const[c,d]=ph(l.shape,i),h=ha(Vr(c),"int32"),p=Vr(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a<t&&(t=a,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}},zN=PI(Oa,(e=>Math.asin(e))),PN={kernelName:Oa,backendName:"cpu",kernelFunc:zN},BN=PI(La,(e=>Math.asinh(e))),WN={kernelName:La,backendName:"cpu",kernelFunc:BN},UN=PI(Ma,(e=>Math.atan(e))),jN={kernelName:Ma,backendName:"cpu",kernelFunc:UN},VN=qI(((e,t)=>Math.atan2(e,t))),GN=pN(Pa,VN),HN={kernelName:Pa,backendName:"cpu",kernelFunc:GN},qN=PI(za,(e=>Math.atanh(e))),KN={kernelName:za,backendName:"cpu",kernelFunc:qN};function XN(e,t,n,r,a,s){const i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ec(a.outShape,n),g=m.values,b=a.outShape[1]*a.outShape[2]*a.outShape[3],y=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let v=0;v<a.batchSize;++v){const t=v*b,n=v*r[0];for(let m=0;m<a.inChannels;++m)for(let b=0;b<a.outHeight;++b){const v=b*i-h,w=Math.max(0,v),k=Math.min(a.inHeight,c+v),S=t+b*y;for(let t=0;t<a.outWidth;++t){const i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i);let b=f,y=0,v=0;for(let t=w;t<k;t+=l){const a=n+t*r[1];for(let t=c;t<h;t+=u){const n=e[a+t*r[2]+m];"max"===s&&n>b?b=n:"avg"===s&&(y+=n,v++)}if(isNaN(b))break}g[S+t*x+m]="avg"===s?y/v:b}}}return m}function YN(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=ec(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=ec(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let b=n;for(;b<0;)b+=u;const y=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const x=Math.min(r.inWidth,h+d);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=u){const i=t-n;for(let n=p;n<x;n+=c){const o=n-d,l=m.get(g,t,n,e);l>v&&(v=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function QN(e,t,n,r,a,s){const i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,b=a.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ec(a.outShape,n),v=x.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let N=0;N<a.batchSize;++N){const t=N*w,n=N*r[0];for(let x=0;x<a.inChannels;++x)for(let w=0;w<a.outDepth;++w){const N=w*i-m;let C=N;for(;C<0;)C+=u;const T=Math.min(a.inDepth,h+N),E=t+w*k;for(let t=0;t<a.outHeight;++t){const i=t*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(a.inHeight,p+i),w=E+t*S;for(let t=0;t<a.outWidth;++t){const i=t*l-b;let o=i;for(;o<0;)o+=d;const p=Math.min(a.inWidth,f+i),g=w+t*I;let k=y,S=0,N=0;for(let t=C;t<T;t+=u){const a=n+t*r[1];for(let t=h;t<m;t+=c){const n=a+t*r[2];for(let t=o;t<p;t+=d){const a=e[n+t*r[3]+x];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===s?S/Math.max(N,1):k}}}}return x}const JN={kernelName:Ba,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;OI(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Wr(wd(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=dd(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Gr(u.inShape,u.outShape))c=jI({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=la(a.shape),r=XN(e,a.shape,a.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const ZN={kernelName:Ua,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;OI(a,"avgPool3d");const c=hd(a.shape,s,i,1,o,l,u),d=QN(n.data.get(a.dataId).values,a.shape,a.dtype,la(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const eC={kernelName:ja,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;OI([a,s],"avgPool3DGrad");const c=hd(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=v-1-c.padInfo.front,I=k-1-c.padInfo.left,N=w-1-c.padInfo.top,C=ec(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(a);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-S,s=n-N,i=r-I;let o=0;for(let t=0;t<v;t+=b){const n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=x){const a=(i+t)/p;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;o+=E.get($,n,r,a,e)}}}C.set(o*T,$,t,n,r,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const tC={kernelName:Wa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;OI([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=dd(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,x=y-1-c.padInfo.left,v=b-1-c.padInfo.top,w=ec(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=ec(a.shape,"float32",S);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-v,a=n-x;let s=0;for(let t=0;t<b;t+=m){const n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const r=(a+t)/h;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;s+=I.get(N,n,r,e)}}w.set(s*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const nC={kernelName:Ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;Wr(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Wr(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Wr(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),OI([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,b=p.length,y=h.length,x=d.length;let v=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[v++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),v>=g&&(v=0),w>=x&&(w=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};function rC(e,t,n,r,a){const s=nd(r,t,n),i=Vr(n),o=la(r);if(s){const n=rd(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}const l=ec(r,a,"string"===a?Nm(e):e),u=ec(n,a);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?Cm(u.values):u.values}function aC(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;OI(a,"slice");const[o,l]=ad(a,s,i);Vc(a,o,l);const u=rC(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}const sC={kernelName:Qi,backendName:"cpu",kernelFunc:aC};const iC={kernelName:Ga,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;OI([a],"batchToSpaceND");const o=s.reduce(((e,t)=>e*t)),l=Ef(a.shape,s,o),u=$f(l.length,s.length),c=Rf(a.shape,s,o),d=_f(i,s.length),h=Af(c,i,s.length),p=xN({inputs:{x:a},backend:n,attrs:{shape:l}}),f=AN({inputs:{x:p},backend:n,attrs:{perm:u}}),m=xN({inputs:{x:f},backend:n,attrs:{shape:c}}),g=aC({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function oC(e,t,n,r,a){const s=Vr(r),i=ha(a,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function lC(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e.shape[0],s=e.shape[1],i=ec([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){const s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}const uC={kernelName:Ha,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=oC(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}},cC=qI(((e,t)=>e&t)),dC={kernelName:qa,backendName:"cpu",kernelFunc:pN(qa,cC)};const hC={kernelName:Ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=Tc(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},pC=zI((e=>Math.ceil(e))),fC=BI(Ya,pC),mC={kernelName:Ya,backendName:"cpu",kernelFunc:fC},gC=PI(Qa,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),bC={kernelName:Qa,backendName:"cpu",kernelFunc:gC},yC={kernelName:Za,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Vr(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function xC(e,t,n,r){const a=ea(n,Vr(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Vr(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?Nm(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}function vC(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const wC={kernelName:js,backendName:"cpu",kernelFunc:vC};function kC(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Qr(a,t[0].shape)[0];yf(t.map((e=>e.shape)),s);let i=xf(t.map((e=>e.shape)),s);if(0===Vr(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Vr(e.shape)>0));if(1===o.length)return jI({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>lN({inputs:{input:e},backend:n}))),t=o.map((e=>vC({inputs:{input:e},backend:n}))),r=kC({inputs:e,backend:n,attrs:{axis:s}}),a=kC({inputs:t,backend:n,attrs:{axis:s}}),i=sN({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}const l=o.map((e=>{const t=Vr(e.shape.slice(s));return xN({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=xf(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],d=xC(u,i,t[0].dtype,c),h=xf(o.map((e=>e.shape)),s),p=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const SC={kernelName:es,backendName:"cpu",kernelFunc:kC};function IC(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;OI([a,s],"conv2d");const d=Sd(l),h=pd(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,y=h.padInfo.top,x="channelsLast"===h.dataFormat,v=new Il(h.outShape,a.dtype),w=la(a.shape),k=la(s.shape),S=w[0],I=x?w[1]:w[2],N=x?w[2]:1,C=x?1:w[1],T=v.strides[0],E=x?v.strides[1]:v.strides[2],$=x?v.strides[2]:1,R=x?1:v.strides[1],_=n.data.get(a.dataId).values,A=n.data.get(s.dataId).values,F=v.values;for(let D=0;D<h.batchSize;++D){const e=D*S,t=D*T;for(let n=0;n<h.outHeight;++n){const r=t+n*E,a=n*h.strideHeight-y;for(let t=0;t<p;++t){const n=a+t*m;if(n<0||n>=h.inHeight)continue;const s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){const t=r+e*$,n=e*h.strideWidth-b;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const a=i+r*N;let o=s+e*k[1];for(let e=0;e<h.inChannels;++e){const n=_[a+e*C];for(let e=0;e<h.outChannels;++e)F[t+e*R]+=n*A[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,F)}const NC={kernelName:ts,backendName:"cpu",kernelFunc:IC};const CC={kernelName:ns,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;OI([a,s],"conv2dBackpropFilter");const d=Sd(l),h=pd(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,b="channelsLast"===h.dataFormat,y=new Il(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new Il(a.shape,a.dtype,w),I=new Il(s.shape,s.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((v-N)/p)),t=Math.min(h.outHeight,(h.inHeight+v-N)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((x-n)/f)),a=Math.min(h.outWidth,(h.inWidth+x-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){const e=N+u*p-v;for(let t=r;t<a;++t){const r=n+t*f-x;o+=b?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}y.set(o,N,n,s,i)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const TC={kernelName:rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;OI([a,s],"conv2dBackpropInput");const d=la(s.shape),h=la(a.shape);let p=Sd(u);const f=pd(i,s.shape,o,1,l,c,!1,p),m=new Il(f.inShape,"float32"),g=m.values,b=n.data.get(a.dataId).values,y=n.data.get(s.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:C,inWidth:T,outChannels:E,outHeight:$,outWidth:R,strideHeight:_,strideWidth:A}=f;p=f.dataFormat;const F=S-1-f.padInfo.top,D=I-1-f.padInfo.left,O="channelsLast"===p,L=m.strides[0],M=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,P=O?1:m.strides[1],B=h[0],W=O?h[1]:h[2],U=O?h[2]:1,j=O?1:h[1];for(let V=0;V<k;++V)for(let e=0;e<N;++e)for(let t=0;t<C;++t){const n=t-F,r=Math.max(0,Math.ceil(n/_)),a=Math.min($,(S+n)/_);for(let s=0;s<T;++s){const i=s-D,o=Math.max(0,Math.ceil(i/A)),l=Math.min(R,(I+i)/A);let u=0;for(let t=r;t<a;++t){const r=t*_-n;for(let n=o;n<l;++n){const a=B*V+W*t+U*n,s=x*(S-1-r)+v*(I-1-(n*A-i))+w*e;for(let e=0;e<E;++e){u+=b[a+j*e]*y[s+e]}}}g[L*V+M*t+z*s+P*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const EC={kernelName:as,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;OI([a,s],"conv3d");const u=fd(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,b=g.front,y=g.left,x=g.top,v=new Il(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=v.values,I=la(a.shape),N=la(s.shape);for(let C=0;C<u.batchSize;++C){const e=C*I[0],t=C*v.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*v.strides[1],a=n*u.strideDepth-b;for(let t=0;t<c;++t){const n=a+t*p;if(n<0||n>=u.inDepth)continue;const s=t*N[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*v.strides[2],n=e*u.strideHeight-x;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const a=s+e*N[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-y;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const s=a+e*N[2],i=o+t*u.inChannels;let l=s;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const $C={kernelName:ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;OI([a,s],"conv3dBackpropFilterV2");const u=la(a.shape),c=la(s.shape),d=fd(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new Il(d.filterShape,"float32"),x=y.values,[v,w,k,S]=y.strides,I=n.data.get(s.dataId).values,[N,C,T,E]=c,$=n.data.get(a.dataId).values,[R,_,A,F]=u,D=d.padInfo.front,O=d.padInfo.left,L=d.padInfo.top;for(let M=0;M<m;++M){const e=Math.max(0,Math.ceil((D-M)/h)),t=Math.min(d.outDepth,(d.inDepth+D-M)/h),n=M*v;for(let r=0;r<g;++r){const a=Math.max(0,Math.ceil((L-r)/p)),s=Math.min(d.outHeight,(d.inHeight+L-r)/p),i=r*w+n;for(let n=0;n<b;++n){const o=Math.max(0,Math.ceil((O-n)/f)),l=Math.min(d.outWidth,(d.inWidth+O-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){const c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){const d=c*R,g=c*N;for(let c=e;c<t;++c){const e=(M+c*h-D)*_+d,t=c*C+g;for(let c=a;c<s;++c){const a=(r+c*p-L)*A+e,s=c*T+t;for(let e=o;e<l;++e){const t=e*E+s;m+=$[(n+e*f-O)*F+a+i]*I[t+u]}}}}x[c+u]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const RC={kernelName:is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;OI([a],"conv3dBackpropInputV2");const u=la(a.shape),c=la(s.shape),d=fd(l,s.shape,o,1,i),h=new Il(d.inShape,"float32"),p=h.values,[f,m,g,b]=h.strides,y=n.data.get(a.dataId).values,[x,v,w,k]=u,S=n.data.get(s.dataId).values,[I,N,C,T]=c,{batchSize:E,filterDepth:$,filterHeight:R,filterWidth:_,inChannels:A,inDepth:F,inHeight:D,inWidth:O,outChannels:L,outDepth:M,outHeight:z,outWidth:P,strideDepth:B,strideHeight:W,strideWidth:U}=d,j=$-1-d.padInfo.front,V=R-1-d.padInfo.top,G=_-1-d.padInfo.left;for(let H=0;H<E;++H)for(let e=0;e<A;++e)for(let t=0;t<F;++t){const n=t-j,r=Math.max(0,Math.ceil(n/B)),a=Math.min(M,($+n)/B);for(let s=0;s<D;++s){const i=s-V,o=Math.max(0,Math.ceil(i/W)),l=Math.min(z,(R+i)/W);for(let u=0;u<O;++u){const c=u-G,d=Math.max(0,Math.ceil(c/U)),h=Math.min(P,(_+c)/U);let E=0;for(let t=r;t<a;++t){const r=t*B-n;for(let n=o;n<l;++n){const a=n*W-i;for(let s=d;s<h;++s){const i=x*H+v*t+w*n+k*s,o=I*($-1-r)+N*(R-1-a)+C*(_-1-(s*U-c))+T*e;for(let e=0;e<L;++e){E+=y[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+b*u+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},_C=PI(os,(e=>Math.cos(e))),AC={kernelName:os,backendName:"cpu",kernelFunc:_C},FC=PI(ls,(e=>Math.cosh(e))),DC={kernelName:ls,backendName:"cpu",kernelFunc:FC};const OC={kernelName:ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,b=ec([f,m,g,p],"float32"),y=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,w=la(a.shape),k=la(b.shape);for(let S=0;S<f;S++){const e=4*S,t=y[e],n=y[e+1],r=y[e+2],a=y[e+3],s=x[S];if(s>=c)continue;const i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];b.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];b.values[n]=u}continue}const d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0];const o=v[a];a=n+f*w[2]+t*w[1]+s*w[0];const l=v[a];a=n+d*w[2]+r*w[1]+s*w[0];const u=v[a];a=n+f*w[2]+r*w[1]+s*w[0];const h=o+(l-o)*m,p=u+(v[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],b.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];b.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];b.values[r]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const LC={kernelName:us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;OI(a,"cumprod");const l=gh([s],a.shape.length);let u=a;null!=l&&(u=AN({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=yh(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ml(u.dtype,"int32"),h=da(Vr(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=i?1:p[t];else{const n=m(b,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=AN({inputs:{x:g},backend:n,attrs:{perm:bh(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const MC={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;OI(a,"cumsum");const l=gh([s],a.shape.length);let u=a;null!=l&&(u=AN({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=yh(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ml(u.dtype,"int32"),h=ha(Vr(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)h[t]=i?0:p[t];else{const n=m(b,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=AN({inputs:{x:g},backend:n,attrs:{perm:bh(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const zC={kernelName:hs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=oC(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){const e=lC(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};const PC={kernelName:ps,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;Wr("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let b=0;b<o;++b)for(let e=0;e<d;++e){const t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){const r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){const n=e+a+c*(r+u*(t+l*b));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function BC(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;OI([a,s],"depthwiseConv2DNative");const c=la(a.shape),d=la(s.shape);let h=l;null==h&&(h=[1,1]),Wr(wd(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));const p=pd(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,v=y.top,w=p.outChannels/p.inChannels,k=new Il(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,N=k.values;for(let C=0;C<p.batchSize;++C){const e=C*c[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],a=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=a+t*g;if(n<0||n>=p.inHeight)continue;const s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const r=n+e*b;if(r<0||r>=p.inWidth)continue;const a=s+e*d[1],o=i+r*p.inChannels;let l=t,u=a;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)N[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const WC={kernelName:fs,backendName:"cpu",kernelFunc:BC};const UC={kernelName:ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;OI([a,s],"depthwiseConv2dNativeBackpropFilter");const d=pd(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Il(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(a.dataId).values,w=new Il(a.shape,a.dtype,v),k=n.data.get(s.dataId).values,S=new Il(s.shape,s.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((y-I)/h)),t=Math.min(d.outHeight,(d.inHeight+y-I)/h);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((b-n)/p)),a=Math.min(d.outWidth,(d.inWidth+b-n)/p);for(let s=0;s<d.outChannels;++s){const i=Math.trunc(s/x),o=s%x;let l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*h-y;for(let t=r;t<a;++t){const r=n+t*p-b;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const jC={kernelName:gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;OI([a,s],"depthwiseConv2DNativeBackpropInput");const d=la(a.shape),h=la(s.shape),p=pd(c,s.shape,i,o,l,u,!0),f=new Il(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(a.dataId).values,[v,w,k]=d,S=n.data.get(s.dataId).values,[I,N,C]=h,{batchSize:T,filterHeight:E,filterWidth:$,inChannels:R,inHeight:_,inWidth:A,outChannels:F,outHeight:D,outWidth:O,strideHeight:L,strideWidth:M}=p,z=E-1-p.padInfo.top,P=$-1-p.padInfo.left,B=F/R;for(let W=0;W<T;++W)for(let e=0;e<R;++e)for(let t=0;t<_;++t){const n=t-z,r=Math.max(0,Math.ceil(n/L)),a=Math.min(D,(E+n)/L);for(let s=0;s<A;++s){const i=s-P,o=Math.max(0,Math.ceil(i/M)),l=Math.min(O,($+i)/M);let u=0;for(let t=r;t<a;++t){const r=t*L-n;for(let n=o;n<l;++n){const a=v*W+w*t+k*n,s=I*(E-1-r)+N*($-1-(n*M-i))+C*e;for(let t=0;t<B;++t){u+=x[a+(e*B+t)]*S[s+t]}}}m[g*W+b*t+y*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const VC={kernelName:bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=Vr(r.shape),s=n.data.get(r.dataId).values,i=ec([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},GC={kernelName:ys,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:C,outShape:T}=cd(a.shape,s.shape,i,o,"NHWC",l),E=Vr(T),$=T.length,R=ea(a.dtype,E);for(let _=0;_<f;++_)for(let e=0;e<y;++e){const t=e*w-v.top;for(let n=0;n<x;++n){const r=n*k-v.left;for(let i=0;i<b;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<I;++t){const l=r+t*C;if(l>=0&&l<g){const r=ma([_,n,l,i],d,la(a.shape)),u=ma([e,t,i],p,la(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}R[ma([_,e,n,i],$,la(T))]=o}}}return{dataId:u.write(cl(R,a.dtype),T,a.dtype),shape:T,dtype:a.dtype}}},HC={kernelName:vs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=ca(a.shape,c.data.get(a.dataId).values),h=ca(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=cd(a.shape,s.shape,o,l,"NHWC",u);Wr(i.rank===C.length,(()=>`Error in ${vs}, dy must have the same rank as output ${C.length}, but got ${i.rank}`));const T=ca(C,c.data.get(i.dataId).values),E=pa(s.shape,s.dtype);for(let $=0;$<p;++$)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const r=n*w-x.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*N;if(l>=0&&l<m){const r=d[$][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}E[i][o][a]+=T[$][e][n][a]}}}return{dataId:c.write(cl(E,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},qC={kernelName:xs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=ca(a.shape,c.data.get(a.dataId).values),h=ca(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=cd(a.shape,s.shape,o,l,"NHWC",u);Wr(i.rank===C.length,(()=>`Error in ${xs}, dy must have the same rank as output ${C.length}, but got ${i.rank}`));const T=ca(C,c.data.get(i.dataId).values),E=pa(a.shape,a.dtype);for(let $=0;$<p;++$)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const r=n*w-x.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*N;if(l>=0&&l<m){const r=d[$][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}E[$][i][o][a]+=T[$][e][n][a]}}}return{dataId:c.write(cl(E,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const KC={kernelName:ws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=s.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[x*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*x;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}s.width=p,s.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),a}},XC=qI(((e,t)=>e*t)),YC=fN(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),QC=pN(bi,XC,YC),JC={kernelName:bi,backendName:"cpu",kernelFunc:QC};function ZC(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;let o;OI(a,"sum"),o="bool"===a.dtype?dN({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):jI({inputs:{x:a},backend:n});const l=o.shape.length,u=Qr(s,o.shape),c=gh(u,l);let d=u,h=o;null!=c&&(h=AN({inputs:{x:o},backend:n,attrs:{perm:c}}),d=yh(d.length,l)),mh("sum",d,h.shape.length);const[p,f]=ph(h.shape,d);let m=oN(n,p,Ml(h.dtype,"int32"));const g=Vr(f),b=n.data.get(m.dataId).values,y=n.data.get(h.dataId).values;for(let x=0;x<b.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[x]=t}if(i){const e=m;m=xN({inputs:{x:m},backend:n,attrs:{shape:fh(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const eT={kernelName:ao,backendName:"cpu",kernelFunc:ZC};const tT={kernelName:Ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=rm(a,s.length);sm(i.length,l,s);const{path:u,steps:c}=im(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=am(p,l[e]);let a;om(t)?a=s[e]:(a=AN({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Gr(a.shape,i)||(a=xN({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=QC({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=ZC({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const nT={kernelName:Ns,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;OI([r,a],"eluGrad");const s=new Float32Array(Vr(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},rT=qI(((e,t)=>e===t?1:0)),aT=pN(Ts,rT,null,"bool"),sT={kernelName:Ts,backendName:"cpu",kernelFunc:aT},iT=Pf,oT=Bf,lT=Wf,uT=Uf,cT=jf,dT=Vf,hT=PI(Cs,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+iT*n);return t*(1-((((dT*r+cT)*r+uT)*r+lT)*r+oT)*r*Math.exp(-n*n))})),pT={kernelName:Cs,backendName:"cpu",kernelFunc:hT},fT=zI((e=>Math.exp(e))),mT=BI(Es,fT,"float32"),gT={kernelName:Es,backendName:"cpu",kernelFunc:mT};function bT(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Wr(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),xN({inputs:{x:a},backend:n,attrs:{shape:o}})}const yT={kernelName:$s,backendName:"cpu",kernelFunc:bT},xT=zI((e=>Math.expm1(e))),vT=BI(Rs,xT),wT={kernelName:Rs,backendName:"cpu",kernelFunc:vT},kT=qI(((e,t)=>e/t)),ST=pN(ks,kT),IT={kernelName:ks,backendName:"cpu",kernelFunc:ST},NT=qI(((e,t)=>e-t)),CT=fN(((e,t,n,r)=>({real:e-n,imag:t-r}))),TT=pN(wo,NT,CT),ET={kernelName:wo,backendName:"cpu",kernelFunc:TT};function $T(e,t,n){const r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=Vr(u),d=Zr("float32",c),h=Zr("float32",c);for(let g=0;g<a;g++){const e=aC({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=aC({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=sN({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=RT(a,t,n),c=Gf(i,u);for(let t=0;t<s;t++){const e=Xf(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=sN({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function RT(e,t,n){const r=Vr(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((o=r)&o-1)){const a=_T(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",ul(r,"float32")),i=jI({inputs:{x:s},backend:n}),l=IT.kernelFunc({inputs:{a:e,b:s},backend:n}),u=IT.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){const o=Jf(a*r,t,n),l=Xf(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),Yf(r,s,i,a)}return r}(Gf(s,i),r,t);return Hf(e)}var o}function _T(e,t,n,r,a){if(1===n)return{real:e,imag:t};const s=Gf(e,t),i=n/2,o=qf(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=sN({inputs:{real:d,imag:h},backend:a}),f=Kf(s),m=f.real,g=f.imag,b=[m.length],y=a.makeTensorInfo(b,"float32",m),x=a.makeTensorInfo(b,"float32",g),v=sN({inputs:{real:y,imag:x},backend:a}),w=_T(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],N=a.makeTensorInfo(I,"float32",k),C=a.makeTensorInfo(I,"float32",S),T=sN({inputs:{real:N,imag:C},backend:a}),E=_T(m,g,i,r,a),$=E.real,R=E.imag,_=[$.length],A=a.makeTensorInfo(_,"float32",$),F=a.makeTensorInfo(_,"float32",R),D=sN({inputs:{real:A,imag:F},backend:a}),O=Qf(n,r),L=[O.real.length],M=a.makeTensorInfo(L,"float32",O.real),z=a.makeTensorInfo(L,"float32",O.imag),P=sN({inputs:{real:M,imag:z},backend:a}),B=QC({inputs:{a:P,b:D},backend:a}),W=bN({inputs:{a:T,b:B},backend:a}),U=TT({inputs:{a:T,b:B},backend:a}),j=lN({inputs:{input:W},backend:a}),V=lN({inputs:{input:U},backend:a}),G=vC({inputs:{input:W},backend:a}),H=vC({inputs:{input:U},backend:a}),q=kC({inputs:[j,V],backend:a,attrs:{axis:0}}),K=kC({inputs:[G,H],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const AT={kernelName:_s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Vr(r.shape),s=r.shape[r.shape.length-1],i=xN({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=$T(i,!1,n),l=xN({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function FT(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||sa(a),o=ea(i,Vr(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}const DT={kernelName:As,backendName:"cpu",kernelFunc:FT};const OT={kernelName:Fs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,s=r,i=Zr(a.dtype,Vr(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){const e=h*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let a=0;a<c;a++){const s=Math.round(u-t-1),o=e+n+r+a;let l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},LT=zI((e=>Math.floor(e))),MT=BI(Ds,LT),zT={kernelName:Ds,backendName:"cpu",kernelFunc:MT},PT=qI(((e,t)=>Math.floor(e/t))),BT=pN(Os,PT,null,"int32"),WT={kernelName:Os,backendName:"cpu",kernelFunc:BT};const UT={kernelName:Lo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=IC({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=xN({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=bN({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=bN({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=xN({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=aN(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=aN(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const jT={kernelName:Mo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=BC({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=bN({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=aN(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function VT(e,t,n,r,a,s,i,o,l){const u=ec([r,s],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<a;t++){const s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}const GT={kernelName:zs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=Vr(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=Ff(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=VT(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};function HT(e,t,n){const r=ec(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}const qT={kernelName:Ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;OI([a,s],"gatherV2");const l=Qr(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let x=0;x<u.length;++x){const e=u[x];Wr(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);const h=Vr(s.shape),p=Im(a,s,l,d),f=xN({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=xN({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=HT(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},KT=qI(((e,t)=>e>t?1:0)),XT=pN(Ps,KT,null,"bool"),YT={kernelName:Ps,backendName:"cpu",kernelFunc:XT},QT=qI(((e,t)=>e>=t?1:0)),JT=pN(Bs,QT,null,"bool"),ZT={kernelName:Bs,backendName:"cpu",kernelFunc:JT};const eE={kernelName:Us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Vr(r.shape),s=r.shape[r.shape.length-1],i=xN({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=$T(i,!0,n),l=xN({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},tE=PI(Vs,(e=>Number.isFinite(e)?1:0),"bool"),nE={kernelName:Vs,backendName:"cpu",kernelFunc:tE},rE=PI(Gs,(e=>Math.abs(e)===1/0?1:0),"bool"),aE={kernelName:Gs,backendName:"cpu",kernelFunc:rE},sE=PI(Hs,(e=>Number.isNaN(e)?1:0),"bool"),iE={kernelName:Hs,backendName:"cpu",kernelFunc:sE},oE=qI(((e,t)=>e<t?1:0)),lE=pN(Ks,oE,null,"bool"),uE={kernelName:Ks,backendName:"cpu",kernelFunc:lE},cE=qI(((e,t)=>e<=t?1:0)),dE=pN(Xs,cE,null,"bool"),hE={kernelName:Xs,backendName:"cpu",kernelFunc:dE};function pE(e,t,n){const r=(t-e)/(n-1),a=ha(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const fE={kernelName:Ys,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=pE(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},mE=zI((e=>Math.log(e))),gE=BI(Qs,mE),bE={kernelName:Qs,backendName:"cpu",kernelFunc:gE},yE=PI(Js,(e=>Math.log1p(e))),xE={kernelName:Js,backendName:"cpu",kernelFunc:yE},vE=qI(((e,t)=>e&&t)),wE=pN(Zs,vE,null,"bool"),kE={kernelName:Zs,backendName:"cpu",kernelFunc:wE},SE=PI(ei,(e=>e?0:1),"bool"),IE={kernelName:ei,backendName:"cpu",kernelFunc:SE},NE=qI(((e,t)=>e||t)),CE=pN(ti,NE,null,"bool"),TE={kernelName:ti,backendName:"cpu",kernelFunc:CE};const EE={kernelName:ni,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;OI(a,"LRN");const u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=Vr(a.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-s);const r=e-t+Math.min(t+s,c);let a=0;for(;n<=r;n++){const e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};const $E={kernelName:ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;OI(i,"LRNGrad");const d=Vr(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const e=y%h,t=y-e+Math.max(0,e-o),n=y-e+Math.min(h,e+o+1);let r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[y]/r;y===a&&(e+=Math.pow(r,-c)),e*=p[y],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function RE(e,t,n,r){const a=Zr(r,Vr(n));for(let s=0;s<a.length;++s){const n=s*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}function _E(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n;let l=a.shape;const u=l.length,c=Qr(s,l);let d=c;const h=gh(d,u);let p=o.data.get(a.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=_N(p,l,a.dtype,h,e),d=yh(d.length,u),l=e}OI(a,"max"),mh("max",d,u);const[f,m]=ph(l,d),g=RE(p,Vr(m),f,a.dtype),b=o.write(g,f,a.dtype);let y=f;if(i){y=fh(f,c)}return{dataId:b,shape:y,dtype:a.dtype}}const AE={kernelName:ai,backendName:"cpu",kernelFunc:_E},FE=qI(((e,t)=>Math.max(e,t))),DE=pN(si,FE),OE={kernelName:si,backendName:"cpu",kernelFunc:DE};const LE={kernelName:ii,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;OI(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Wr(wd(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=dd(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Gr(u.inShape,u.outShape))c=jI({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=la(a.shape),r=XN(e,a.shape,a.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const ME={kernelName:li,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;OI(a,"maxPool3d");const c=hd(a.shape,s,i,1,o,l,u),d=QN(n.data.get(a.dataId).values,a.shape,a.dtype,la(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const zE={kernelName:ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;OI([a,s],"maxPool3DGrad");const c=hd(s.shape,i,o,1,l,u),d=function(e,t){const n=ec(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*r-h;let x=y;for(;x<0;)x+=i;const v=Math.min(t.inDepth,u+y);for(let r=0;r<t.outHeight;++r){const u=r*a-p;let h=u;for(;h<0;)h+=o;const w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let t=x;t<v;t+=i){const n=t-y;for(let r=h;r<w;r+=o){const a=r-u;for(let s=k;s<S;s+=l){const i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,N=n*c*d+a*c+i)}}}n.set(N,m,b,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,y=c.effectiveFilterDepth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=y-1-c.padInfo.front,k=v-1-c.padInfo.left,S=x-1-c.padInfo.top,I=ec(s.shape,"float32"),N=n.bufferSync(a);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-w,s=n-S,i=r-k;let o=0;for(let t=0;t<y;t+=m){const n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<x;r+=g){const a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<v;s+=b){const l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=y*x*v-1-d.get(C,n,a,l,e)===t*x*v+r*v+s?1:0;if(0===u)continue;o+=N.get(C,n,a,l,e)*u}}}I.set(o,C,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const PE={kernelName:oi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;OI([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=dd(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=ec(h.outShape,o.dtype,YN(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,b=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,S=ec(o.shape,"float32"),I=n.data.get(a.dataId).values,N=ec(a.shape,"float32",I);for(let C=0;C<h.batchSize;++C)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const r=t-k,a=n-w;let s=0;for(let t=0;t<x;t+=b){const n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<v;r+=y){const i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const o=x*v-1-f.get(C,n,i,e)===t*v+r?1:0;if(0===o)continue;s+=N.get(C,n,i,e)*o}}S.set(s,C,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const BE={kernelName:ci,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;OI(a,"MaxPoolWithArgmax");const c=u.data.get(a.dataId).values,d=dd(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){const s=XN(e,0,n,la(t),a,"max"),i=YN(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const WE={kernelName:di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=Qr(s,a.shape),l=Vr(ph(a.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const d=dN({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(d);const h=ST({inputs:{a:d,b:c},backend:n});u.push(h);const p=ZC({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const UE={kernelName:hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;OI(a,"min");const o=Qr(s,a.shape);let l=o;const u=gh(l,a.shape.length);let c=a;null!=u&&(c=AN({inputs:{x:a},backend:n,attrs:{perm:u}}),l=yh(l.length,a.shape.length)),mh("min",l,c.shape.length);const[d,h]=ph(c.shape,l),p=Vr(h),f=ha(Vr(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=xN({inputs:{x:g},backend:n,attrs:{shape:fh(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},jE=qI(((e,t)=>Math.min(e,t))),VE=pN(pi,jE),GE={kernelName:pi,backendName:"cpu",kernelFunc:VE};const HE={kernelName:fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;OI(a,"mirrorPad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=la(a.shape),f=Vr(o),m=o.length,g=la(o),b=Zr(a.dtype,f);for(let y=0;y<f;y++){let e=ga(y,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=ma(e,h,p);b[y]=d[t]}return{dataId:n.write(b,o,a.dtype),shape:o,dtype:a.dtype}}},qE=qI(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),KE=pN(mi,qE),XE={kernelName:mi,backendName:"cpu",kernelFunc:KE};function YE(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length;let o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Qr([o],a.shape),u=_E({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=fh(u.shape,l),d=xN({inputs:{x:u},backend:n,attrs:{shape:c}}),h=TT({inputs:{a:a,b:d},backend:n}),p=mT({inputs:{x:h},backend:n}),f=ZC({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=xN({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ST({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const QE={kernelName:oo,backendName:"cpu",kernelFunc:YE};const JE={kernelName:gi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;OI(a,"multinomial");const l=o?a:YE({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=ha(Vr(h),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];const n=Lh.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){const e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}};function ZE(e,t,n){const r=ul(-1,n);return XC([],t,r,e,n)}const e$={kernelName:yi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;OI(r,"neg");const a=n.data.get(r.dataId).values,[s,i]=ZE(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},t$=Bp;const n$={kernelName:vi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;OI(a,"NonMaxSuppression");const u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=t$(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},r$=Wp;const a$={kernelName:wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;OI(a,"NonMaxSuppressionPadded");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=r$(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},s$=Up;const i$={kernelName:ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;OI(a,"NonMaxSuppressionWithScore");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:b}=s$(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},o$=qI(((e,t)=>e!==t?1:0)),l$=pN(xi,o$,null,"bool"),u$={kernelName:xi,backendName:"cpu",kernelFunc:l$};const c$={kernelName:Ii,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;OI(a,"oneHot");const u=Vr(a.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function d$(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=lN({inputs:{input:r},backend:n}),t=d$({inputs:{x:e},backend:n}),a=vC({inputs:{input:r},backend:n}),s=d$({inputs:{x:a},backend:n}),i=sN({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return FT({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const h$={kernelName:_o,backendName:"cpu",kernelFunc:d$};const p$={kernelName:Si,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=lN({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=vC({inputs:{input:a},backend:r}),i=d$({inputs:{x:s},backend:r}),o=sN({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return FT({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function f$(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return bT({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Ur(s,e.shape,"All tensors passed to stack must have matching shapes"),Wr(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=kC({inputs:t.map((e=>{const t=bT({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const m$={kernelName:Ni,backendName:"cpu",kernelFunc:f$};const g$={kernelName:Ci,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;OI(a,"pad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=Vr(a.shape),d=a.shape.length,h=la(a.shape),p=Vr(o),f=o.length,m=la(o),g=Zr(a.dtype,p);0!==i&&g.fill(i);for(let b=0;b<c;b++){g[ma(ga(b,d,h).map(((e,t)=>e+l[t])),f,m)]=u[b]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},b$=qI(((e,t)=>Math.pow(e,t))),y$=pN(Ti,b$),x$={kernelName:Ti,backendName:"cpu",kernelFunc:y$};function v$(e,t,n,r){const[a,s]=ph(e,r),i=Ml(t,"int32"),o=ha(Vr(a),i),l=Vr(s);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}const w$={kernelName:$i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;OI(a,"prod");const o=a.shape.length,l=Qr(s,a.shape),u=gh(l,o);let c=l,d=a;const h=[];null!=u&&(d=AN({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=yh(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=v$(d.shape,d.dtype,p,c);let b=m;return i&&(b=fh(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,g,f)}};function k$(e,t,n,r){const a=[];let s=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const a=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function S$(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function I$(e,t,n,r,a){const s=t.slice();s[0]=a;const i=ea(n,Vr(s)),o=e.length;return function(e,t,n,r,a,s){const i=S$(t,2)[1],o=S$(s,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function N$(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=ga(r,t.length,la(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=k$(s,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=ea("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=I$(n,r,a,c,d);return[h,p[0],p[1]]}const C$={kernelName:Ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=N$(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},T$=2147483647;function E$(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=ea("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=o?e[0]:e[m],n=l?r[0]:r[m],a=u?s[0]:s[m];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&n<t||a<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/a)),i>T$)throw new Error(`Requires ((limit - start) / delta) <= ${T$}`);h[m+1]=h[m]+i}const p=ea(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=o?e[0]:e[m];const r=u?s[0]:s[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[h,p]}const $$={kernelName:_i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=E$(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var R$=vf;class _${constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=kf(u),this.raggedRank=Sf(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===R$.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===R$.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case R$.VALUE_ROWIDS:return _$.getMaxWidthValueRowID(t);case R$.ROW_SPLITS:return _$.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${R$[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return F$(e,n)}calculateOutputSize(e){const t=this.valuesShape;If(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=wf(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return Wr(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,s=[];for(let i=0;i<a-1;++i){const a=e[i+1]-e[i];let o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){const a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case R$.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case R$.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${R$[s]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case R$.FIRST_DIM_SIZE:return e[0];case R$.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case R$.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${R$[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const r=F$(t,!1),a=ea(this.valuesDType,Vr(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,s=n;let i=r.slice();i=i.slice(e+1);const o=Vr(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;pu((()=>{const t=Nd(u,e),n=Ad(t,i);u=n.dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){const e=a.subarray(c*o);A$(s.subarray(d*o),e,(h-d)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){A$(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}}function A$(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function F$(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function D$(e,t,n,r,a,s,i,o,l,u){return new _$(e,t,n,r,a,s,i,o,l,u).compute()}const O$={kernelName:Ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=D$(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};function L$(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return ha(0,r);const a=ha(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const M$={kernelName:Fi,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=L$(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},z$=PI(Oi,(e=>1/e)),P$={kernelName:Oi,backendName:"cpu",kernelFunc:z$};const B$={kernelName:Bi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;OI(a,"resizeBilinear");const l=la(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Vr([d,u,c,f])),b=[s&&u>1?h-1:h,s&&c>1?p-1:p],y=[s&&u>1?u-1:u,s&&c>1?c-1:c];let x=0;const v=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],b=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[b+e]-n)*a-s)*r;g[x++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};const W$={kernelName:Wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;OI([s,a],"resizeBilinearGrad");const o=la(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(s.dataId).values;let v=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<h;t++){const n=t*b,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],b=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[b+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};const U$={kernelName:zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;OI(a,"resizeNearestNeighbor");const l=la(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),b=[s&&u>1?h-1:h,s&&c>1?p-1:p],y=[s&&u>1?u-1:u,s&&c>1?c-1:c],x=b[0]/y[0],v=b[1]/y[1];let w=0;for(let k=0;k<d;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?x*(t+.5):x*t;let r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const a=e+r*l[1];for(let e=0;e<c;e++){const t=i?v*(e+.5):v*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=a+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};const j$={kernelName:Pi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;OI([s,a],"resizeNearestNeighborGrad");const o=la(a.shape),l=la(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,b=[i&&p>1?c-1:c,i&&f>1?d-1:d],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=b[0]/y[0],v=b[1]/y[1],w=1/x,k=1/v,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let N=0;N<u;N++){const e=N*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){const r=n+s*o[2],u=Math.floor(s*k),b=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){const u=r+a;if(u<0||u>=p)continue;const h=e+u*l[1],m=u*x;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+b;if(t<0||t>=f)continue;const r=h+t*l[2],a=t*v;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};const V$={kernelName:ji,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;OI(a,"reverse");const i=a.shape.length,o=Qr(s,a.shape);if(0===i)return jI({inputs:{x:a},backend:n});const l=new Il(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},G$={kernelName:Do,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=Zr(a.dtype,Vr(a.shape)),[c,d,h,p]=a.shape,[f,m]=Tf(o,d,h),g=Math.sin(s),b=Math.cos(s),y=l.data.get(a.dataId).values;for(let x=0;x<c;x++){const e=x*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let r=0;r<h;r++){const a=r*p;for(let s=0;s<p;s++){const o=[c,t,r,s],l=o[2],x=o[1];let v=(l-f)*b-(x-m)*g,w=(l-f)*g+(x-m)*b;v=Math.round(v+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===s?255:i[s]),v>=0&&v<h&&w>=0&&w<d){k=y[e+w*(h*p)+v*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},H$=PI(Vi,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),q$={kernelName:Vi,backendName:"cpu",kernelFunc:H$},K$=zI((e=>1/Math.sqrt(e))),X$=BI(Gi,K$),Y$={kernelName:Gi,backendName:"cpu",kernelFunc:X$};function Q$(e,t,n,r,a,s,i,o,l,u){const c=[r/a,a],d=e.values,h=t.values;if(0===r)return ec(n,t.dtype);const p=l instanceof Il?l:ec(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const e=[];let s=0;for(let t=0;t<i;t++){const n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}const J$={kernelName:Hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Lf(0,a,i),h=Q$(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function Z$(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function eR(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const tR={kernelName:Ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){const i=ea("int32",n*a);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?Z$(n,t[e+l]):eR(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};const nR={kernelName:Xi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;OI([r,a,s],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=Ml(a.dtype,s.dtype),d=ha(Vr(a.shape),c);let h=0;const p=0===i||i>1||1===a.shape.length?1:Vr(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},rR=Mf,aR=zf,sR=PI(Yi,(e=>e>=0?aR*e:rR*(Math.exp(e)-1))),iR={kernelName:Yi,backendName:"cpu",kernelFunc:sR},oR=PI(eo,(e=>e<0?-1:e>0?1:0)),lR={kernelName:eo,backendName:"cpu",kernelFunc:oR},uR=PI(Ji,(e=>Math.sin(e))),cR={kernelName:Ji,backendName:"cpu",kernelFunc:uR},dR=PI(Zi,(e=>Math.sinh(e))),hR={kernelName:Zi,backendName:"cpu",kernelFunc:dR},pR=Math.log(1.1920928955078125e-7)+2,fR=PI(no,(e=>{const t=e>-pR,n=e<pR,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),mR={kernelName:no,backendName:"cpu",kernelFunc:fR};const gR={kernelName:so,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;OI([a],"spaceToBatchND");const o=Vr(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);const u=g$.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=Ef(u.shape,s,o,!1),d=$f(c.length,s.length,!1),h=Rf(u.shape,s,o,!1),p=xN({inputs:{x:u},backend:n,attrs:{shape:c}}),f=AN({inputs:{x:p},backend:n,attrs:{perm:d}}),m=xN({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function bR(e,t,n,r,a,s,i){const o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(cm(o));return[ea(n,0),[0,d],ea(a,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*d];if(t<0)throw new Error(dm(g,t));if(t>=l)throw new Error(hm(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],s=ea(n,t*d),h=ea(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}}return[s,[t,d],h,u,c]}}const yR={kernelName:lo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=bR(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function xR(e,t,n,r,a){const s=Vr(r),i=t[0],o=a.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=a[m];if(-1===e){if(-1!==c)throw new Error(pm(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(fm(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/u);if(u*e!==s)throw new Error(gm(r,l));l[c]=e}if(Vr(l)!==s)throw new Error(bm(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=ea(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const vR={kernelName:uo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=xR(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};function wR(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const h=ea(n,d.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=a[p];for(;;){let t=0;if(f<o){if(t=a[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(vm(g,c));g>m&&h.fill(i,m*u,g*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(wm(n,r[n],l[0]));for(let n=0;n<u;n++)h[g*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)h[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&h.fill(i,m*u,c*u),[h,d]}const kR={kernelName:co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=wR(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const SR={kernelName:ho,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=wR(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const IR={kernelName:po,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Lf(0,a,o),p=!1,f=n.bufferSync(a);let m;switch(s.dtype){case"bool":m=Q$(f,n.bufferSync(s),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=Q$(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"int32":m=Q$(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=Q$(f,n.bufferSync(s),o,h,c,u,l,d,pl(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const NR={kernelName:io,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Qr(i,a.shape)[0],l=um(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=aC({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},CR=zI((e=>Math.sqrt(e))),TR=PI(ro,(e=>Math.sqrt(e))),ER={kernelName:ro,backendName:"cpu",kernelFunc:TR},$R={kernelName:mo,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,a=n;OI(r,"square");const s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},RR=qI(((e,t)=>{const n=e-t;return n*n})),_R=pN(fo,RR),AR={kernelName:fo,backendName:"cpu",kernelFunc:_R},FR=zI(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),DR=BI(go,FR),OR={kernelName:go,backendName:"cpu",kernelFunc:DR},LR=PI(Ao,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),MR={kernelName:Ao,backendName:"cpu",kernelFunc:LR};function zR(e,t,n,r){const a=ec(e,t.dtype);for(let s=0;s<a.size;s++){const e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}const PR={kernelName:bo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;OI(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=sd(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=xN({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||b){Wr(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=Hc(y,x,v),t=aC({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});w=xN({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=zR(p,n.bufferSync(a),v,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class BR{constructor(e,t,n,r,a,s){this.separator=hl(e),this.nGramWidths=t,this.leftPad=hl(n),this.rightPad=hl(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){const o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length;h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=ea("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}const i=new Array(s[a]);for(let o=0;o<a;++o){const n=t[o];let r=s[o];if(this.nGramWidths.forEach((a=>{const s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){const a=t[o+1]-t[o];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}}function WR(e,t,n,r,a,s,i,o){return new BR(n,r,a,s,i,o).compute(e,t)}const UR={kernelName:yo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=WR(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function jR(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function VR(e,t,n){const r=e.length,a=[];let s=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const r=a.length;jR(e[h],t,n,a);const l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}const l=ea("int32",2*s),u=new Array(s),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}const GR={kernelName:xo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=VR(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function HR(e,t){const n=ea("int32",e.length);for(let r=0;r<e.length;++r)n[r]=ll(e[r]).modulo(t).getLowBitsUnsigned();return n}const qR={kernelName:vo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=HR(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},KR=PI(ko,(e=>Math.tan(e))),XR={kernelName:ko,backendName:"cpu",kernelFunc:KR},YR=PI(So,(e=>Math.tanh(e)));const QR={kernelName:qi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Lf(0,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=Q$(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function JR(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=ec(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const s=e.locToIndex(n);r.values[a]=e.values[s]}return r}const ZR={kernelName:Io,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;OI(a,"tile");const i=JR(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},e_=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function t_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);t_(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}const a=e[t];let s=n,i=r;for(Br(e,n,t),e_(e[r],a)>0&&Br(e,n,r);s<i;){for(Br(e,s,i),s++,i--;e_(e[s],a)<0;)s+=1;for(;e_(e[i],a)>0;)i-=1}0===e_(e[n],a)?Br(e,n,i):(i+=1,Br(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function n_(e,t,n,r,a){const s=t[t.length-1],[i,o]=[e.length/s,s],l=Zr(n,i*r),u=Zr("int32",i*r);for(let d=0;d<i;d++){const t=d*o,n=e.subarray(t,t+o);let s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(t_(s,r),s=s.slice(0,r)),a&&s.sort(e_);const i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[ec(c,n,l),ec(c,"int32",u)]}const r_={kernelName:No,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;OI(a,"topk");const o=n.data.get(a.dataId).values,[l,u]=n_(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const a_={kernelName:Co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],b=la(a.shape),y=b[0],x=b[1],v=b[2],w=la(g),k=w[0],S=w[1],I=w[2],N=Zr(a.dtype,Vr(g));N.fill(l);const C=r.data.get(a.dataId).values,T=r.data.get(s.dataId).values;for(let E=0;E<c;++E){const e=1===s.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a;const s=e[6]*n+e[7]*t+1;if(0===s)continue;const u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=s_(u,h,o),f=s_(c,d,o);switch(i){case"nearest":a=o_(C,d,h,y,x,v,E,f,p,r,l);break;case"bilinear":a=l_(C,d,h,y,x,v,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}N[E*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,N)}return{dataId:r.write(N,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function s_(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return zr(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return zr(0,n,t-1)}(e,t);case"nearest":return function(e,t){return zr(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function i_(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function o_(e,t,n,r,a,s,i,o,l,u,c){return i_(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function l_(e,t,n,r,a,s,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*i_(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*i_(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*i_(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*i_(e,t,n,r,a,s,i,p,f,u,c))}function u_(e,t,n,r){const a=Qr(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const i=new Map,o=new Int32Array(n[a]),l=new Il(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const d=s.slice();d[1]=i.size;const h=new Il(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const c_={kernelName:Eo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;OI(s,"unique");const i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=u_(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const d_={kernelName:$o,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a.shape.length,o=a.shape[s],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);const c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;const e=aC({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=xN({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};const h_={kernelName:Ro,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;OI(a,"unsortedSegmentSum");const o=[],l=[],u=a.shape.length-s.shape.length;let c=s;for(let h=0;h<u;++h){const e=bT({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){const e=ul(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=aT({inputs:{a:t,b:c},backend:n}),s=dN({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=QC({inputs:{a:s,b:a},backend:n}),u=ZC({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}const d=f$({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},p_=[SN,NN,TN,$N,yN,RN,DN,ON,LN,MN,PN,WN,jN,HN,KN,JN,ZN,eC,tC,kN,nC,iC,uC,dC,hC,hN,mC,bC,iN,yC,SC,NC,CC,TC,EC,$C,RC,AC,DC,OC,LC,MC,zC,PC,WC,UC,jC,VC,GC,HC,qC,KC,tT,UI,nT,sT,pT,gT,yT,wT,AT,DT,OT,zT,WT,UT,jT,GT,qT,YT,ZT,VI,eE,wC,nE,aE,iE,HI,uE,hE,fE,bE,xE,kE,IE,TE,EE,$E,AE,OE,LE,ME,zE,PE,BE,WE,UE,GE,HE,XE,JE,JC,e$,n$,a$,i$,u$,c$,p$,m$,g$,x$,YI,w$,C$,$$,O$,M$,uN,IT,P$,JI,eN,vN,B$,W$,U$,j$,V$,G$,q$,Y$,J$,tR,nR,iR,rN,lR,cR,hR,sC,QE,mR,gR,yR,vR,kR,SR,IR,NR,ER,$R,AR,OR,MR,PR,UR,GR,qR,ET,eT,XR,{kernelName:So,backendName:"cpu",kernelFunc:YR},QR,ZR,r_,a_,FN,c_,d_,h_,h$];for(const n of p_)Go(n);const f_={},m_={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function g_(e,t){if(!(e in f_)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(wa().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete f_[e]}),!1),wa().getBool("SOFTWARE_WEBGL_ENABLED")&&(m_.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",m_)||n.getContext("experimental-webgl",m_);return n.getContext("webgl2",m_)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;f_[e]=n}const n=f_[e];return null==n||n.isContextLost()?(delete f_[e],g_(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),f_[e])}var b_,y_,x_;function v_(e,t){return[t,e]}function w_(e){const t=Vr(e);return qr(Math.ceil(t/4))}function k_(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function S_(e,t){const n=e;let r,a,s,i,o,l,u,c,d,h;return 2===wa().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function I_(e,t){const n=t();return wa().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(b_||(b_={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(y_||(y_={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(x_||(x_={}));function N_(e){return!!(wa().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function C_(e,t){return O_(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const T_=/ERROR: [0-9]+:([0-9]+):/g;function E_(e,t){const n=T_.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>Kr((t+1).toString(),s)+e));let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Kr(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function $_(e,t){if(I_(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function R_(e,t,n,r,a,s,i){const o=e.getAttribLocation(t,n);return-1!==o&&(I_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),I_(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),I_(e,(()=>e.enableVertexAttribArray(o))),!0)}function __(e,t,n,r){I_(e,(()=>function(e,t,n){L_(e,n),I_(e,(()=>e.activeTexture(e.TEXTURE0+n))),I_(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),I_(e,(()=>e.uniform1i(n,r)))}function A_(e,t,n){I_(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),I_(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function F_(e,t){I_(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),I_(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function D_(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function O_(e,t,n){const r=I_(e,(()=>t()));if(null==r)throw new Error(n);return r}function L_(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function M_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Vr(e.slice(0,e.length-t))}function z_(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function P_(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[M_(e),...z_(e)]),t}function B_(e){return e%2===0}function W_(e,t){if(Gr(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(B_(n)&&B_(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&B_(e[0])&&B_(t[0])}let U_,j_;function V_(e,t){return null!=e.getExtension(t)}function G_(e){try{if(null!=g_(e))return!0}catch(FW){return console.log("Error when getting WebGL context: ",FW),!1}return!1}function H_(e){if(0===e)return!1;const t=g_(e);if(1!==e){if(V_(t,"EXT_color_buffer_float"))return q_(t);const e="EXT_color_buffer_half_float";if(V_(t,e)){const n=t.getExtension(e);return function(e,t){const n=S_(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!V_(t,"OES_texture_float"))return!1;if(!V_(t,"WEBGL_color_buffer_float"))return!1;return q_(t)}function q_(e){const t=S_(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function K_(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Wr("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const X_=wa();function Y_(){let e,t,n,r,a,s,i,o,l,u;return 2===wa().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=wa().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Q_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=la(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function J_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=la(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function Z_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function eA(e){const t=la(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}X_.registerFlag("HAS_WEBGL",(()=>X_.getNumber("WEBGL_VERSION")>0)),X_.registerFlag("WEBGL_VERSION",(()=>G_(2)?2:G_(1)?1:0)),X_.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),X_.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===X_.get("WEBGL_VERSION"))),X_.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),X_.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),X_.registerFlag("WEBGL_PACK",(()=>X_.getBool("HAS_WEBGL"))),X_.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_CLIP",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_REDUCE",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_LAZILY_UNPACK",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_CONV_IM2COL",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>X_.getBool("WEBGL_PACK"))),X_.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==U_){const t=g_(e);U_=t.getParameter(t.MAX_TEXTURE_SIZE)}return U_}(X_.getNumber("WEBGL_VERSION")))),X_.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==j_){const t=g_(e);j_=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,j_)}(X_.getNumber("WEBGL_VERSION")))),X_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=X_.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=g_(e);return t=V_(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:V_(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),X_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>X_.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Jl())),X_.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=g_(e);if(1===e){if(!V_(t,"OES_texture_float"))return!1}else if(!V_(t,"EXT_color_buffer_float"))return!1;return q_(t)}(X_.getNumber("WEBGL_VERSION")))),X_.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!X_.getBool("WEBGL_FORCE_F16_TEXTURES")&&X_.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),X_.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>H_(X_.getNumber("WEBGL_VERSION")))),X_.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=X_.getNumber("WEBGL_VERSION"))&&null!=g_(e).fenceSync;var e})),X_.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>X_.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),X_.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),X_.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Jl()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),X_.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),X_.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),X_.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),X_.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),X_.registerFlag("WEBGL_EXP_CONV",(()=>!1)),X_.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>X_.getBool("IS_TEST"))),X_.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),X_.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),X_.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),X_.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const tA="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:nA}=a;function rA(e,t,n){const r=[];if(e.forEach((e=>{const t=Vr(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=fA(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?sA(e,r):aA(e,r);const s=e.shapeInfo.logicalShape,i=t.logicalShape;s.length<=i.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=nA(e.shapeInfo.logicalShape,t.logicalShape),l=pA(i),u=i-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Vr(e.shapeInfo.logicalShape),m=Vr(t.logicalShape),g=1===m;if(1!==s||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Gr(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=pA(l),c=nA(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${a}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=Y_(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${iA}\n    ${oA}\n    ${lA}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return cA();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Gr(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return cA();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(Gr(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${J_(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=Q_(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${J_(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=Q_(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=Q_(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=Q_(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=uA);return[d,l,c,a,u,s,n.userCode].join("\n")}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=dA(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${hA(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=dA(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===s)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Gr(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Jr(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${aA(mA(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${gA(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${hA(e)}\n      }\n    `;const u=s[0],c=s[1],d=dA(r);if(1===c)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Jr(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${aA(mA(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${gA(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${hA(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=dA(r);if(t)return`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=Jr(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${aA(mA(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${gA(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${hA(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const b=dA(r);if(t)return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=Jr(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${aA(mA(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${gA(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${hA(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=dA(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=Jr(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${aA(mA(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${gA(t,s)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${hA(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=dA(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function sA(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Y_();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=Y_();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=Y_();if(null!=s&&Gr(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${sA(mA(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${gA(s,r)});\n        }\n      `}const o=Y_();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=Y_();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2);let h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const iA="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",oA="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",lA="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",uA="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function cA(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function dA(e){return`offset${e}`}function hA(e){const t=e.name,n=Vr(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function pA(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function fA(e,t,n){const{newShape:r,keptDims:a}=Jr(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!Gr(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function mA(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function gA(e,t){return t.map((t=>e[t])).join(", ")}function bA(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=rA(a,i,t),l=function(e,t){const n=O_(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(I_(e,(()=>e.shaderSource(n,t))),I_(e,(()=>e.compileShader(n))),wa().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw E_(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return wa().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},yA(e,t,u)))}function yA(e,t,n){const r=[],a=[];let s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===wa().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const a={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${d}Shape`,c),a.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)a.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function xA(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!Gr(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!Gr(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function vA(e){return wa().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class wA{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=b_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Y_();this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?J_(["r","c","d"],e):Q_(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class kA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=b_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Y_();this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?J_(["r","c","d"],e):Q_(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class SA{constructor(e){this.variableNames=["A"],this.outTexUsage=y_.DOWNLOAD;const t=Y_();this.outputShape=e,this.userCode=`\n      ${tA}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class IA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=y_.DOWNLOAD;const t=Y_();this.outputShape=e,this.userCode=`\n      ${tA}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const NA={R:0,G:1,B:2,A:3};class CA{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Y_();this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){const e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${NA[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":eA(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class TA{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Y_();this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":eA(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}function EA(e){const t=Y_();return function(e,t){const n=O_(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(I_(e,(()=>e.shaderSource(n,t))),I_(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function $A(e){return function(e,t){const n=O_(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return I_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),I_(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function RA(e){return function(e,t){const n=O_(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return I_(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),I_(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function _A(e,t,n,r,a,s){!function(e,t){const n=wa().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return O_(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return I_(e,(()=>e.bindTexture(o,i))),I_(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),I_(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),I_(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),I_(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===wa().getNumber("WEBGL_VERSION")?I_(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):I_(e,(()=>e.texStorage2D(o,1,r,t,n))),I_(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function AA(e){return e.internalFormatFloat}function FA(e){return e.internalFormatHalfFloat}function DA(e){return e.downloadTextureFormat}function OA(e){return e.internalFormatPackedFloat}function LA(e){return e.internalFormatPackedHalfFloat}function MA(e,t,n,r,a,s,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=k_(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class zA{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=wa().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){f_[e]=t}(t,e)):this.gl=g_(t),e=this.gl,2===wa().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>I_(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>I_(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>I_(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>I_(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>I_(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>I_(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>I_(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>I_(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===wa().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=C_(this.gl,e),V_(this.gl,t))this.textureHalfFloatExtension=C_(this.gl,t);else if(wa().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),V_(this.gl,r))this.colorBufferHalfFloatExtension=C_(this.gl,r);else if(wa().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",V_(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!V_(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=$A(this.gl),this.indexBuffer=RA(this.gl),this.framebuffer=function(e){return O_(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=S_(this.gl,this.textureHalfFloatExtension)}get debug(){return wa().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;I_(e,(()=>e.finish())),I_(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),I_(e,(()=>e.deleteFramebuffer(this.framebuffer))),I_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),I_(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),I_(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=v_(t,n);return _A(e,a,s,AA(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=v_(t,n);return _A(e,a,s,FA(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=v_(t,n);return _A(e,a,s,DA(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){I_(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===wa().getNumber("WEBGL_VERSION")?I_(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):I_(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===wa().getNumber("WEBGL_VERSION")?I_(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):I_(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),I_(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,s){let i,o,l;I_(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===wa().getNumber("WEBGL_VERSION")?I_(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):I_(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),I_(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=k_(t,n);return _A(e,a,s,LA(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=k_(t,n);return _A(e,a,s,OA(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(F_(this.gl,this.framebuffer),this.outputTexture=null),I_(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,s]=v_(t,n),i=new Uint8Array(t*n*4);return I_(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return MA(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();I_(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const a=16*t*n;return I_(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),I_(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),I_(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(wa().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return I_(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=EA(t));const n=function(e){return O_(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);I_(t,(()=>t.attachShader(n,this.vertexShader))),I_(t,(()=>t.attachShader(n,e))),function(e,t){if(I_(e,(()=>e.linkProgram(t))),!wa().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&$_(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;I_(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){I_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),R_(e,t,"clipSpacePos",n,3,20,0)&&R_(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(I_(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&$_(this.gl,this.program),I_(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return O_(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),I_(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),__(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=k_(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&$_(this.gl,this.program),D_(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}I_(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),I_(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=C_(this.gl,2===wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Xr((()=>this.disposed||this.isQueryAvailable(e,wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in wa().platform&&(n=wa().platform.setTimeoutCustom.bind(wa().platform)),Xr((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),A_(this.gl,e,this.framebuffer),this.debug&&D_(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(A_(this.gl,this.outputTexture,this.framebuffer),this.debug&&D_(this.gl)):F_(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;A_(r,e,this.framebuffer),this.debug&&D_(r),this.outputTexture=e,I_(r,(()=>r.viewport(0,0,t,n))),I_(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),I_(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:PA,XI:BA,Nk:WA,f6:UA,ct:jA,YG:VA,hH:GA,z3:HA,sG:qA,uM:KA,vS:XA,qB:YA,GG:QA,rq:JA,lg:ZA,WR:eF,cu:tF,GE:nF,px:rF,jC:aF,He:sF,hE:iF,BF:oF,Dk:lF,cl:uF,_B:cF,ub:dF,_f:hF,Ku:pF,qy:fF,Zy:mF,bu:gF,zv:bF,dH:yF,HS:xF,yH:vF,l3:wF,z9:kF,x6:SF,_m:IF,eW:NF,GK:CF,SP:TF,yr:EF,dl:$F,Dw:RF,xT:_F,_X:AF,wz:FF}=s;function DF(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function OF(e,t){return 1===t?[e]:DF(e,t)}class LF{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=vA(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=OF("rc",this.rank),t=pA(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class MF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length);let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2===1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r,a;this.userCode=`\n      ${r=t,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?Z_(["r","c","d"],"inputShape"):Q_(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":eA(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class zF{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=BF(t,n),a=WF(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=PF(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let i;return r===x_.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===x_.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===x_.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===x_.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===x_.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=BF(n,r),s=WF(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const i=PF(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=wa().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function PF(e,t,n,r,a){const s=function(e,t){switch(e){case x_.PACKED_2X2_FLOAT32:return OA(t);case x_.PACKED_2X2_FLOAT16:return LA(t);case x_.UNPACKED_FLOAT32:return AA(t);case x_.UNPACKED_FLOAT16:return FA(t);case x_.PACKED_4X1_UNSIGNED_BYTE:return DA(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(a){const[t,n]=k_(e[0],e[1]);i=t*n}else{const[t,n]=v_(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return i*o}function BF(e,t){if(e===y_.UPLOAD)return x_.PACKED_2X2_FLOAT32;if(e===y_.RENDER||null==e)return function(e){return wa().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?x_.PACKED_2X2_FLOAT32:x_.UNPACKED_FLOAT32:e?x_.PACKED_2X2_FLOAT16:x_.UNPACKED_FLOAT16}(t);if(e===y_.DOWNLOAD||e===y_.PIXELS)return x_.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function WF(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class UF{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const jF="if (isnan(x)) return x;",VF="return abs(x);";const GF=jF+"\n  return (x < 0.0) ? 0.0 : x;\n",HF=jF+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",qF="return x;";class KF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class XF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length);const t=e.length,n=OF("rc",t),r=pA(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const YF=Tm,QF={};const JF=wa().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class ZF extends Or{nextDataId(){return ZF.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!wa().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof zA)t=e;else{const n=g_(wa().getNumber("WEBGL_VERSION"),e);t=new zA(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=g_(wa().getNumber("WEBGL_VERSION"));t=new zA(e),this.binaryCache=((n=wa().getNumber("WEBGL_VERSION"))in QF||(QF[n]={}),QF[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zF(this.gpgpu),this.numMBBeforeWarning=null==wa().global.screen?1024:wa().global.screen.height*wa().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Dr(this,du())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];const l=P_(t),u=new CA(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((wa().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||wa().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:y_.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(wa().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:y_.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new KF(i,qF):new UF(i,qF);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=dl()),"complex64"===r){c=Gf(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=dl()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new KF(r,qF):new UF(r,qF);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(wa().getBool("DEBUG")&&!wa().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===wa().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&wa().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...w_(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=Gf(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Vr(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;I_(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&du().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new KF(a,qF):new UF(a,qF);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=du().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>pl(e)));return ec(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ec(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!N_(n)){if(wa().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Vr(t);if(wa().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...w_(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=wa().getBool("WEBGL_PACK")&&!0===r,i=s?P_(t):t,o=s?new IA(i):new SA(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=ml(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=ml(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:dl(),endMs:null}}endTimer(e){return wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=dl(),e)}async getQueryTime(e){if(wa().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:JF;return wa().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Vr(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){zo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return YF(e.shape,t)}packedUnaryOp(e,t,n){const r=new KF(e.shape,t),a=this.compileAndRun(r,[e],n);return du().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=yF(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(wa().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,VF,e.dtype);const t=new UF(e.shape,VF),n=this.compileAndRun(t,[e]);return du().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ra(n[0])){const a=n.map((e=>hl(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return du().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new XF(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new LF(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[M_(e.shape),...z_(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[M_(t),...z_(t)],s=new MF(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){Wr(Vr(a)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=P_(a);let o;o=r?new kA(i):new wA(i);const l=[null!=t?t:w_(i)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===b_.DENSE){const t=null!=s?s:w_(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Vr(i.shape))return o.values=Zr(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Vr(t.shape)<=wa().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!W_(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=fA(e.packedInputs,t.shape,s);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=la(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&Gr(t.shape,s),f=1===Vr(t.shape),m=Nc(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&Gr(s,n.texData.texShape),b=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${b}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${wa().getNumber("WEBGL_VERSION")}`,s}(e,u,c),h=this.getAndSaveBinary(d,(()=>bA(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),wa().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(xA(t.inShapeInfos,n),xA([t.outShapeInfo],[r]));const s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===wa().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=fA(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Vr(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=la(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=wa().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=dl();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!wa().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!wa().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=pu((()=>{if(!wa().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=wa().getBool("DEBUG");wa().set("DEBUG",!1);const t=this.abs(dc(1e-8)).dataSync()[0];if(wa().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=dl());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=wa().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=wa().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&wa().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Pr(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Jr(e);e=t.newShape}let a=Vr(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){const t=M_(e);let n=2,r=2;e.length&&([n,r]=z_(e)),a=t*(n/2)*(r/2),s=qr(a).map((e=>2*e))}else s=qr(a);return s}(n,o),t.texShape=c),null!=a){const e=P_(n);let s,i=c[1],d=c[0];const h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!o&&h||([i,d]=k_(c[0],c[1])),s=o?new TA(e,h):new CA(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?y_.PIXELS:y_.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);const g=[[d,i]],b=!0,y=this.runWebGLProgram(s,[f],r,g,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,wa().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=dl()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*na(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await bf(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw E_(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=yA(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:s,channels:i}=e,o=du().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,a,s,i);return du().makeTensorFromDataId(l,t,n,o)}}ZF.nextDataId=0;Zl()&&gu("webgl",(()=>new ZF),2);const eD="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class tD{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Tc(t,n),this.enableShapeUniforms=vA(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const nD="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class rD{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Tc(t,n);const a=this.outputShape.length;this.enableShapeUniforms=vA(a);let s="";if(r)if(0===a||1===Vr(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${pA(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=OF("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function aD(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const sD={kernelName:Ws,backendName:"webgl",kernelFunc:aD};function iD(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=aD({inputs:{x:r},backend:n}),l=aD({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}const oD={kernelName:Ja,backendName:"webgl",kernelFunc:iD},lD="return (a < 0.) ? b * a : a;",uD="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const cD={kernelName:qs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",ul(s,"float32")),o=wa().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rD(uD,a.shape,i.shape):new tD(lD,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},dD="return (a < 0.) ? b * a : a;",hD="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const pD={kernelName:Ei,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=wa().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rD(hD,r.shape,a.shape):new tD(dD,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},fD="if (isnan(x)) return x;";function mD(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let{inputs:s,backend:i}=e;const{x:o}=s,l=i,u=a||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=wa().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new KF(o.shape,n):new UF(o.shape,t),l.runWebGLProgram(c,[o],u)}}function gD(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){const e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new tD(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],Ml(n.dtype,r.dtype))})),s=iD({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}const h=i||Ml(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){const e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?Nm(e):e,r="string"===u.dtype?Nm(t):t,[a,i]=s(u.shape,c.shape,n,r,h),o=d.makeTensorInfo(i,h);return d.texData.get(o.dataId).values=a,o}let p;return p=wa().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new rD(n,u.shape,c.shape,r):new tD(t,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function bD(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":GF;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":HF;if("prelu"===e)return t?hD:dD;if("leakyrelu"===e)return t?uD:lD;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class yD{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=vA(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const b=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${x};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const xD="return areal * breal - aimag * bimag;",vD="return areal * bimag + aimag * breal;";class wD{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Tc(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const kD="return a * b;";function SD(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=Ml(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new wD(xD,r.shape,a.shape),i=new wD(vD,r.shape,a.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=iD({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,o]=oF(r.shape,a.shape,e.values,t.values,s),l=n.makeTensorInfo(o,s);return n.texData.get(l.dataId).values=i,l}let i;return i=wa().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rD(kD,r.shape,a.shape):new tD(kD,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}const ID={kernelName:bi,backendName:"webgl",kernelFunc:SD};function ND(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=Vr(a.shape),l=Yr(s,o),u=Vr(l);Wr(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(a.dataId);return!c.isPacked||W_(a.shape,l)||null!==c.texture&&W_(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){const r=[M_(e.shape),...z_(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[M_(t),...z_(t)],i=new MF(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}const CD={kernelName:Mi,backendName:"webgl",kernelFunc:ND};class TD{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Hr(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class ED{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function $D(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Cf(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let i=0;i<a.length;i++){const{inSize:o,windowSize:l,outSize:u}=a[i];let c,d;c="mean"===n?0===i?new TD({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new TD({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new ED({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class RD{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const r=pA(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class _D{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=pA(this.rank),a=DF("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];const i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function AD(e,t,n){const r=wa().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _D(e.shape,t):new RD(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function FD(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){const a=t,s=e.shape.length,i=Qr(a,e.shape);let o=i;const l=gh(o,s),u=null!=l;let c=e;u&&(c=AD(e,l,r),o=yh(o.length,s)),mh("sum",o,s);const[d,h]=ph(c.shape,o);let p=d;n&&(p=fh(d,i));const f=Vr(h),m=ND({inputs:{x:c},attrs:{shape:[Vr(e.shape)/f,f]},backend:r}),g=$D(m,zl(e.dtype),"sum",r),b=ND({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),b}(a,s,i,n)}const DD={kernelName:ao,backendName:"webgl",kernelFunc:FD};function OD(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=a.shape[s[c]];let u;if(i.shouldExecuteOnCPU([a])){const e=i.texData.get(a.dataId).values,t=AF(e,a.shape,a.dtype,s,l);u=i.makeTensorInfo(l,a.dtype);i.texData.get(u.dataId).values=t}else u=AD(a,s,i);return u}const LD={kernelName:To,backendName:"webgl",kernelFunc:OD};function MD(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),b=n.shape.slice(0,-2),y=Vr(g),x=Vr(b),v=Tc(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Wr(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));const w=r?[y,h,f]:[y,f,h],k=a?[x,m,p]:[x,p,m],S=ND({inputs:{x:t},backend:s,attrs:{shape:w}}),I=ND({inputs:{x:n},backend:s,attrs:{shape:k}}),N=[S,I],C=Math.max(y,x),T=r?S.shape[1]:S.shape[2],E=null!=i,$=null!=o,R="leakyrelu"===u,_=null!=u?bD(u,!0):null;let A;if((1===f||1===m)&&T>1e3&&!1===(E||$||R||null!=_)){let e=S,t=I;r&&(e=OD({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),a&&(t=OD({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let i=e;1!==m&&(i=ND({inputs:{x:e},backend:s,attrs:{shape:[C,T,1]}}),N.push(i));const o=1===m?2:1;let l=t;n&&(l=ND({inputs:{x:t},backend:s,attrs:{shape:[C,1,T]}}),N.push(l));const u=SD({inputs:{a:i,b:l},backend:s});A=FD({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),N.push(u)}else{const e=Ml(t.dtype,n.dtype),u=new yD(w,k,[C,f,m],r,a,E,_,$,R),c=[S,I];if(null!=i&&c.push(i),$&&c.push(o),R){const e=s.makeTensorInfo([],"float32",ul(l,"float32"));c.push(e),N.push(e)}A=s.runWebGLProgram(u,c,e)}const F=ND({inputs:{x:A},backend:s,attrs:{shape:v}});N.push(A);for(const D of N)s.disposeIntermediateTensorInfo(D);return F}const zD={kernelName:Oo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return MD({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},PD="return abs(x);";const BD={kernelName:Ca,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=yF(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=wa().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new KF(r.shape,PD):new UF(r.shape,PD),n.runWebGLProgram(a,[r],r.dtype)}},WD=mD({opSnippet:jF+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),UD={kernelName:Ta,backendName:"webgl",kernelFunc:WD},jD=mD({opSnippet:jF+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),VD={kernelName:Ea,backendName:"webgl",kernelFunc:jD},GD="return a + b;",HD=gD({opSnippet:GD,packedOpSnippet:GD,supportsComplex:!0,cpuKernelImpl:PA}),qD={kernelName:$a,backendName:"webgl",kernelFunc:HD};class KD{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class XD{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const YD={kernelName:Ra,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return aD({inputs:{x:a[0]},backend:r});if(a.length>wa().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>Ml(e,t))),i=a.map((e=>e.shape)),o=wa().getBool("WEBGL_PACK")?new XD(a[0].shape,i):new KD(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};const QD={kernelName:_a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Qr(s,a.shape);let u=l;const c=gh(u,o);let d=a;null!=c&&(d=OD({inputs:{x:a},backend:n,attrs:{perm:c}}),u=yh(u.length,o)),mh("all",u,o);const[h,p]=ph(d.shape,u),f=ND({inputs:{x:d},backend:n,attrs:{shape:[-1,Vr(p)]}}),m=$D(f,f.dtype,"all",n);let g;if(i){g=ND({inputs:{x:m},backend:n,attrs:{shape:fh(h,l)}})}else g=ND({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};const JD={kernelName:Aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Qr(s,a.shape);let u=l;const c=gh(u,o);let d=a;null!=c&&(d=OD({inputs:{x:a},backend:n,attrs:{perm:c}}),u=yh(u.length,o)),mh("any",u,o);const[h,p]=ph(d.shape,u),f=ND({inputs:{x:d},backend:n,attrs:{shape:[-1,Vr(p)]}}),m=$D(f,f.dtype,"any",n);let g;if(i){g=ND({inputs:{x:m},backend:n,attrs:{shape:fh(h,l)}})}else g=ND({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class ZD{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class eO{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Wr(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=pA(o),u=OF("coords",o);let c,d;if(1===s){d=o+1;const e=pA(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=OF("sourceLocR",d-1).concat("inIdx.r"),g=OF("sourceLocG",d-1).concat("inIdx.g"),b=OF("sourceLocB",d-1).concat("inIdx.b"),y=OF("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function tO(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const i=Cf(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new ZD(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=tO(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function nO(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:t.shape,s=Cf(a[a.length-1]),i=new eO(a,s,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=nO(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function rO(e,t,n,r){const a=[n];if(mh("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!wa().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=ph(i.shape,a),u=Vr(l),c=ND({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=tO(e,c,r);n.push(d);const h=ND({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return nO(e,t,r)}const aO={kernelName:Fa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=Qr(s,a.shape);const o=gh(i,a.shape.length);let l=a;const u=[];null!=o&&(l=OD({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=yh(i.length,l.shape.length)),mh("argMax",[i[0]],l.shape.length);const c=rO(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const sO={kernelName:Da,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=Qr(s,a.shape);const o=gh(i,a.shape.length);let l=a;const u=[];null!=o&&(l=OD({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=yh(i.length,l.shape.length)),mh("argMin",[i[0]],l.shape.length);const c=rO(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},iO=mD({opSnippet:jF+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),oO={kernelName:Oa,backendName:"webgl",kernelFunc:iO},lO=mD({opSnippet:jF+"return log(x + sqrt(x * x + 1.0));"}),uO={kernelName:La,backendName:"webgl",kernelFunc:lO},cO=mD({opSnippet:jF+"\n  return atan(x);\n"}),dO={kernelName:Ma,backendName:"webgl",kernelFunc:cO},hO=gD({opSnippet:eD+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nD+"\n  return result;\n"}),pO={kernelName:Pa,backendName:"webgl",kernelFunc:hO},fO=mD({opSnippet:jF+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),mO={kernelName:za,backendName:"webgl",kernelFunc:fO};class gO{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(s/4),v=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class bO{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),k=s%4,S=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${v});\n      }\n    `}}const yO={kernelName:Ba,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;K_(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Wr(wd(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=dd(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Gr(u.inShape,u.outShape))return aD({inputs:{x:a},backend:n});const c=new gO(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};const xO={kernelName:Ua,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=hd(a.shape,s,i,[1,1,1],o,l,u),d=new bO(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};class vO{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wO{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const kO={kernelName:ja,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=hd(i.shape,o,l,[1,1,1],u,c),h=new wO(d);return n.runWebGLProgram(h,[a],i.dtype)}};const SO={kernelName:Wa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;K_([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=dd(i.shape,o,l,1,u),d=new vO(c);return n.runWebGLProgram(d,[a],i.dtype)}};const IO={kernelName:Va,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return MD({a:a,b:s,transposeA:i,transposeB:o,backend:n})}};class NO{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Tc(e,t),Tc(e,n);let i="0.0";null!=r&&(Tc(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(Tc(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class CO{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Tc(e,t),Tc(e,n);let i="vec4(0.0)";null!=r&&(Tc(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(Tc(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const TO={kernelName:Ls,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,mean:s,variance:i,offset:o,scale:l}=t;Wr(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Wr(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Wr(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[a,s,i];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));const p=wa().getBool("WEBGL_PACK_NORMALIZATION")?new CO(a.shape,s.shape,i.shape,d,h,u):new NO(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class EO{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=pA(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return $O.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${$O[t]} = start[${t}] + coords.${$O[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const $O=["x","y","z","w","u","v"];class RO{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=pA(this.rank),n=OF("coords",this.rank),r=OF("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function _O(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=ad(a,s,i);if(Vc(a,o,l),0===Vr(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=xF(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}const{isPacked:u}=n.texData.get(a.dataId),c=nd(a.shape,o,l);if(u||!c){const e=wa().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RO(l):new EO(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=rd(t,la(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}const AO={kernelName:Qi,backendName:"webgl",kernelFunc:_O},FO={kernelName:Ga,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Wr(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=Ef(a.shape,s,o),u=$f(l.length,s.length),c=Rf(a.shape,s,o),d=_f(i,s.length),h=Af(c,i,s.length),p=[],f=ND({inputs:{x:a},backend:n,attrs:{shape:l}}),m=OD({inputs:{x:f},backend:n,attrs:{perm:u}}),g=ND({inputs:{x:m},backend:n,attrs:{shape:c}}),b=_O({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const DO={kernelName:Ha,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=BA(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};const OO={kernelName:qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=wa().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=wa().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[s,i]=UA(r.shape,a.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=s,o}let o;return o=s?new rD("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new tD("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}};const LO={kernelName:Ka,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=Tc(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},MO=gD({opSnippet:"return float(a != b);",cpuKernelImpl:uF,dtype:"bool"}),zO={kernelName:xi,backendName:"webgl",kernelFunc:MO};function PO(e){const{inputs:t,backend:n}=e,{input:r}=t;return aD({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const BO={kernelName:Di,backendName:"webgl",kernelFunc:PO};const WO={kernelName:Xa,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return aD({inputs:{x:s},backend:r});const t=_h(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=iD({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=PO({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!ta(s.dtype,i)){const e=aD({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){const e=r.texData.get(s.dataId).values,[t,n,a]=jA(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){const n=new UF(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Zr("bool",1)),t=MO({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},UO="return ceil(x);",jO=mD({opSnippet:UO,packedOpSnippet:UO,cpuKernelImpl:VA}),VO={kernelName:Ya,backendName:"webgl",kernelFunc:jO};class GO{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class HO{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const qO={kernelName:Qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r;let o;o=wa().getBool("WEBGL_PACK_CLIP")?new HO(a.shape):new GO(a.shape);const l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}};class KO{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function XO(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const YO={kernelName:Za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new KO(r.shape),i=[XO(r,a.complexTensorInfos.real),XO(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}};class QO{constructor(e){this.outputShape=[],this.outputShape=xf(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){const e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class JO{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=xf(e,t);const n=this.outputShape,r=n.length,a=pA(r),s=OF("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${ZO(i,l,e)}),\n            vec2(${ZO(u,l,e)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${ZO(i,l,p)}),\n          vec2(${ZO(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function ZO(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function eL(e){const{inputs:t,backend:n}=e,{input:r}=t;return aD({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const tL={kernelName:js,backendName:"webgl",kernelFunc:eL};function nL(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>PO({inputs:{input:e},backend:n}))),a=e.map((e=>eL({inputs:{input:e},backend:n}))),s=nL(r,t,n),i=nL(a,t,n),o=iD({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=Vr(e.shape.slice(t));return ND({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=xf(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=GA(s,i,r,o),u=xf(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const s=e.filter((e=>Vr(e.shape)>0)),i=wa().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const t=i?new UF(e[0].shape,qF):new KF(e[0].shape,qF);return n.runWebGLProgram(t,e,r)}const o=wa().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const e=[];for(let a=0;a<s.length;a+=o){const r=s.slice(a,a+o);e.push(nL(r,t,n))}const r=nL(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new JO(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=xf(e.map((e=>e.shape)),t),a=e.map((e=>ND({inputs:{x:e},attrs:{shape:[-1,Vr(e.shape.slice(t))]},backend:n})));return{tensors2D:a,outShape:r}}(s,t,n),c=new QO(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=ND({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function rL(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Qr(a,t[0].shape)[0];yf(t.map((e=>e.shape)),s);const i=xf(t.map((e=>e.shape)),s);if(0===Vr(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Vr(e.shape)>0));return 1===o.length?aD({inputs:{x:o[0]},backend:n}):nL(o,s,n)}const aL={kernelName:es,backendName:"webgl",kernelFunc:rL};class sL{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let x="",v="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class iL{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class oL{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=vA(this.outputShape.length);const s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=s%2===0?Pr(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class lL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=vA(this.outputShape.length);const{dataFormat:n}=t,r=Y_(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function uL(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function cL(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=a.texData.get(t.dataId),d=r.inChannels,h=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const b=[];if(null!=i){const e=uL(i.shape,f);null!=e&&(i=ND({inputs:{x:i},backend:a,attrs:{shape:e}}),b.push(i))}if(null!=s){const e=uL(s.shape,f);null!=e&&(s=ND({inputs:{x:s},backend:a,attrs:{shape:e}}),b.push(s))}if(!((1===h||1===p)&&d>1e3)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&Gr(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),d={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,Wr(W_(c.shape,d.shape),(()=>`packed reshape ${c.shape} to ${d.shape} isn't free`));const p=ND({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});b.push(p);const f=MD({a:d,b:p,backend:a,transposeA:false,transposeB:m,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),y=a.texData.get(f.dataId);Wr(y.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,y.shape=r.outShape,g=aD({inputs:{x:f},backend:a}),g.shape=r.outShape,b.push(f)}else{const e=r.outHeight*r.outWidth,u=ND({inputs:{x:t},backend:a,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=ND({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=MD({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:a,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=ND({inputs:{x:d},backend:a,attrs:{shape:r.outShape}}),b.push(u),b.push(c),b.push(d)}for(const y of b)a.disposeIntermediateTensorInfo(y);return g}function dL(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,b=p*h,y=[r.batchSize,g,b],x=[];if(null!=i){const e=uL(i.shape,m);null!=e&&(i=ND({inputs:{x:i},backend:a,attrs:{shape:e}}),x.push(i))}if(null!=s){const e=uL(s.shape,m);null!=e&&(s=ND({inputs:{x:s},backend:a,attrs:{shape:e}}),x.push(s))}const v=ND({inputs:{x:n},backend:a,attrs:{shape:[1,g,Vr(n.shape)/g]}});x.push(v);const w=new lL(y,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=ND({inputs:{x:S},backend:a,attrs:{shape:y}});x.push(S),x.push(I);const N=null!=s,C=null!=i,T="leakyrelu"===l,E=l?bD(l,!0):null,$=new yD(m?I.shape:v.shape,m?v.shape:I.shape,m?[r.batchSize,b,r.outChannels]:[r.batchSize,r.outChannels,b],!0,!1,N,E,C,T),R=m?[I,v]:[v,I];if(s&&R.push(s),C&&R.push(i),T){const e=a.makeTensorInfo([],"float32",ul(o,"float32"));R.push(e),x.push(e)}const _=a.runWebGLProgram($,R,"float32"),A=ND({inputs:{x:_},backend:a,attrs:{shape:r.outShape}});x.push(_);for(const F of x)a.disposeIntermediateTensorInfo(F);return A}const hL={kernelName:ts,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=Sd(l),h=pd(a.shape,s.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&wa().getBool("WEBGL_EXP_CONV")){const e=new oL(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[a,s],"float32",t)}else if(wa().getBool("WEBGL_CONV_IM2COL"))p=dL({x:a,filter:s,convInfo:h,backend:n});else{const e=new sL(h);p=n.runWebGLProgram(e,[a,s],"float32")}else p=cL({x:a,filter:s,convInfo:h,backend:n});const f=ND({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class pL{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fL{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mL{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gL{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const bL={kernelName:ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=Sd(l),h=pd(a.shape,c,i,1,o,u,!1,d),p=new pL(h);return n.runWebGLProgram(p,[a,s],"float32")}};class yL{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=vA(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const xL={kernelName:rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=Sd(u),h=pd(i,s.shape,o,1,l,c,!1,d);if(wa().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new yL(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{const e=new fL(h);return n.runWebGLProgram(e,[a,s],"float32")}}};const vL={kernelName:as,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=fd(a.shape,s.shape,i,l,o),c=new iL(u);return n.runWebGLProgram(c,[a,s],"float32")}};const wL={kernelName:ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=fd(a.shape,l,i,1,o),c=new mL(u);return n.runWebGLProgram(c,[a,s],"float32")}};const kL={kernelName:is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=fd(l,s.shape,o,1,i),c=new gL(u);return n.runWebGLProgram(c,[a,s],"float32")}},SL=mD({opSnippet:fD+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${nD}\n  return result;\n`}),IL={kernelName:os,backendName:"webgl",kernelFunc:SL},NL=mD({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),CL={kernelName:ls,backendName:"webgl",kernelFunc:NL};class TL{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,b]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,x,v]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const EL={kernelName:ds,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new TL(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};var $L;!function(e){e.Prod="*",e.Sum="+"}($L||($L={}));class RL{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===$L.Prod?"1.0":"0.0",i=n?s:`getX(${_L(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${pA(a)} coords = getOutputCoords();\n        int end = ${AL(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${AL(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${_L(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function _L(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function AL(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function FL(e,t,n,r,a,s){const i=t.shape.length,o=gh([r],i);let l=t;null!=o&&(l=OD({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=yh(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=aD({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const t=new RL(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const t=new RL(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=OD({inputs:{x:d},backend:n,attrs:{perm:bh(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const DL={kernelName:us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return FL($L.Prod,a,n,s,i,o)}};const OL={kernelName:cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return FL($L.Sum,a,n,s,i,o)}};const LL={kernelName:hs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=BA(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=WA(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class ML{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const zL={kernelName:ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new ML("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}};class PL{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=vA(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class BL{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=vA(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?Pr(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const WL={kernelName:fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Wr(wd(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=pd(a.shape,s.shape,i,c,o,u,!0);let h;h=wa().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new BL(d):new PL(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",p)}};class UL{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jL{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const VL={kernelName:ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=pd(a.shape,c,i,o,l,u,!0),h=new UL(d);return n.runWebGLProgram(h,[a,s],"float32")}};const GL={kernelName:gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=pd(c,s.shape,i,o,l,u,!0),h=new jL(d);return n.runWebGLProgram(h,[a,s],"float32")}};class HL{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const qL={kernelName:bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=Vr(r.shape),i=ND({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new HL(s),l=n.runWebGLProgram(o,[i],i.dtype),u=ND({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class KL{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const XL={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=cd(a.shape,s.shape,i,o,"NHWC",l);let c;const d=new KL(u);c=n.runWebGLProgram(d,[a,s],"float32");const h=ND({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};const YL={kernelName:Ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=rm(a,s.length);sm(i.length,l,s);const{path:u,steps:c}=im(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=am(p,l[e]);let a;om(t)?a=s[e]:(a=OD({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Gr(a.shape,i)||(a=ND({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=SD({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=FD({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},QL=mD({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),JL={kernelName:Is,backendName:"webgl",kernelFunc:QL},ZL={kernelName:Ns,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=wa().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rD("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new tD("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},eM=gD({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:HA}),tM={kernelName:Ts,backendName:"webgl",kernelFunc:eM},nM=mD({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Pf};\n  float a1 = ${Bf};\n  float a2 = ${Wf};\n  float a3 = ${Uf};\n  float a4 = ${jf};\n  float a5 = ${Vf};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),rM={kernelName:Cs,backendName:"webgl",kernelFunc:nM},aM=mD({opSnippet:fD+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:qA,dtype:"float32"}),sM={kernelName:Es,backendName:"webgl",kernelFunc:aM};function iM(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Wr(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),ND({inputs:{x:s},backend:r,attrs:{shape:o}})}const oM={kernelName:$s,backendName:"webgl",kernelFunc:iM},lM="return exp(x) - 1.0;",uM=mD({opSnippet:lM,packedOpSnippet:lM,cpuKernelImpl:KA}),cM={kernelName:Rs,backendName:"webgl",kernelFunc:uM};class dM{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function hM(e,t,n){const r=n.texData.get(e.dataId),a=Vr(e.shape),s=e.shape[e.shape.length-1],i=ND({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new dM("real",o,t),u=new dM("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=iD({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=ND({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const pM={kernelName:_s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return hM(r,!1,n)}};class fM{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function mM(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||sa(a),"string"===s){const e=ea(s,Vr(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new fM(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const gM={kernelName:As,backendName:"webgl",kernelFunc:mM};class bM{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const yM={kernelName:Fs,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,a=n,s=new bM(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},xM="return floor(x);",vM=mD({opSnippet:xM,packedOpSnippet:xM,cpuKernelImpl:XA}),wM={kernelName:Ds,backendName:"webgl",kernelFunc:vM},kM=gD({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),SM={kernelName:Os,backendName:"webgl",kernelFunc:kM};class IM{constructor(e){this.variableNames=["A"];const t=Y_(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class NM{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Y_(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const CM={kernelName:Fo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,i="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){const e=wa().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=TM&&e===EM||(EM=e,TM=document.createElement("canvas").getContext("2d",{willReadFrequently:EM})),TM.canvas.width=l,TM.canvas.height=u,TM.drawImage(a,0,0,l,u),a=TM.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=y_.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const p=wa().getBool("WEBGL_PACK")?new NM(d):new IM(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let TM,EM=wa().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const $M={kernelName:Lo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Sd(c),g=pd(a.shape,s.shape,l,d,u,h,!1,m);let b;const y=[],x=null!=i,v=null!=o,w="leakyrelu"===p,k=()=>{const e=[a,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=ND({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(i,c)),v&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",ul(f,"float32"));e.push(t),y.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&wa().getBool("WEBGL_EXP_CONV")){const e=p?bD(p,!0):null,t=new oL(g,x,e,v,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],a=k();b=n.runWebGLProgram(t,a,"float32",r)}else if(wa().getBool("WEBGL_CONV_IM2COL"))b=dL({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?bD(p,!1):null,t=new sL(g,x,e,v,w),r=k();b=n.runWebGLProgram(t,r,"float32")}else b=cL({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=ND({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const RM={kernelName:Mo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Wr(wd(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=pd(a.shape,s.shape,l,m,u,d,!0),b=wa().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=h?bD(h,b):null,x=[a,s],v=null!=i,w=null!=o,k="leakyrelu"===h;if(v&&x.push(i),w&&x.push(o),k){const e=n.makeTensorInfo([],"float32",ul(p,"float32"));x.push(e),f.push(e)}let S;S=b?new BL(g,v,y,w,k):new PL(g,v,y,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(S,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class _M{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=pA(n.length);let s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const AM={kernelName:zs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=Vr(r.shape),[l,u,c,d]=Ff(r,a),h=ND({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=ND({inputs:{x:r},backend:n,attrs:{shape:[Vr(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=YA(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new _M(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=ND({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class FM{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=pA(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function DM(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=Qr(i,a.shape)[0];if(wa().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Wr(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=Im(a,s,l,o),c=Vr(s.shape),d=[],h=ND({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=ND({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=QA(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new FM(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const b=ND({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const OM={kernelName:Ms,backendName:"webgl",kernelFunc:DM},LM=gD({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:JA,dtype:"bool"}),MM={kernelName:Ps,backendName:"webgl",kernelFunc:LM},zM=gD({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ZA}),PM={kernelName:Bs,backendName:"webgl",kernelFunc:zM};const BM={kernelName:Us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return hM(r,!0,n)}},WM=mD({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),UM={kernelName:Vs,backendName:"webgl",kernelFunc:WM},jM=mD({opSnippet:"return float(isinf(x));",dtype:"bool"}),VM={kernelName:Gs,backendName:"webgl",kernelFunc:jM},GM=mD({opSnippet:"return float(isnan(x));",dtype:"bool"}),HM={kernelName:Hs,backendName:"webgl",kernelFunc:GM},qM=gD({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:eF,dtype:"bool"}),KM={kernelName:Ks,backendName:"webgl",kernelFunc:qM},XM=gD({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:tF,dtype:"bool"}),YM={kernelName:Xs,backendName:"webgl",kernelFunc:XM};const QM={kernelName:Ys,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=nF(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},JM=mD({opSnippet:fD+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:rF}),ZM={kernelName:Qs,backendName:"webgl",kernelFunc:JM},ez=mD({opSnippet:fD+"\n  return log(1.0 + x);\n"}),tz={kernelName:Js,backendName:"webgl",kernelFunc:ez},nz=gD({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),rz={kernelName:Zs,backendName:"webgl",kernelFunc:nz},az=mD({opSnippet:"return float(!(x >= 1.0));"}),sz={kernelName:ei,backendName:"webgl",kernelFunc:az},iz=gD({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),oz={kernelName:ti,backendName:"webgl",kernelFunc:iz};class lz{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class uz{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const cz={kernelName:ni,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=wa().getBool("WEBGL_PACK_NORMALIZATION")?new uz(a.shape,s,i,o,l):new lz(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}};class dz{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const hz={kernelName:ri,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new dz(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function pz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=Qr(s,a.shape);let u=l;const c=gh(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]);let p=a;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];const r=AF(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=AD(a,c,n);u=yh(u.length,o)}mh("max",u,o);const[f,m]=ph(p.shape,u);let g,b=f;if(i&&(b=fh(f,l)),h){const e=n.texData.get(p.dataId).values,t=aF(e,Vr(m),b,a.dtype);g=n.makeTensorInfo(b,a.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const a=Vr(t),s=ND({inputs:{x:e},attrs:{shape:[Vr(e.shape)/a,a]},backend:r}),i=$D(s,e.dtype,"max",r),o=ND({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,m,b,n);return d&&n.disposeIntermediateTensorInfo(p),g}const fz={kernelName:ai,backendName:"webgl",kernelFunc:pz},mz=gD({opSnippet:eD+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nD+"\n  return result;\n",cpuKernelImpl:sF}),gz={kernelName:si,backendName:"webgl",kernelFunc:mz};const bz={kernelName:ii,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;K_(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Wr(wd(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=dd(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Gr(u.inShape,u.outShape))return aD({inputs:{x:a},backend:n});const c=new gO(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};const yz={kernelName:li,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=hd(a.shape,s,i,[1,1,1],o,u,l),d=new bO(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};class xz{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vz{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const wz={kernelName:ui,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=hd(i.shape,o,l,[1,1,1],u,c),h=new bO(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new vz(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const kz={kernelName:oi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;K_([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=dd(o.shape,l,u,1,c,d),p=new gO(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new xz(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const Sz={kernelName:ci,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;Wr(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const c=[1,1];Wr(wd(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=dd(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new gO(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");return a=new gO(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};const Iz={kernelName:di,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=Qr(i,a.shape);let c=u;const d=gh(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[];let m=a;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];const n=AF(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype);o.texData.get(m.dataId).values=n}else m=AD(a,d,o);f.push(m),c=yh(c.length,l)}mh("sum",c,l);const[g,b]=ph(m.shape,c);let y=g;s&&(y=fh(g,u));const x=function(e,t,n,r){const a=Vr(t),s=ND({inputs:{x:e},attrs:{shape:[Vr(e.shape)/a,a]},backend:r}),i=$D(s,"float32","mean",r),o=ND({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,b,y,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return x}};const Nz={kernelName:hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Qr(s,a.shape);let u=l;const c=gh(u,o);let d=a;null!=c&&(d=OD({inputs:{x:a},backend:n,attrs:{perm:c}}),u=yh(u.length,a.shape.length)),mh("min",u,o);const[h,p]=ph(d.shape,u),f=ND({inputs:{x:d},backend:n,attrs:{shape:[-1,Vr(p)]}}),m=$D(f,f.dtype,"min",n);let g;if(i){g=ND({inputs:{x:m},backend:n,attrs:{shape:fh(h,l)}})}else g=ND({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},Cz=gD({opSnippet:eD+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nD+"\n  return result;\n",cpuKernelImpl:iF}),Tz={kernelName:pi,backendName:"webgl",kernelFunc:Cz};class Ez{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=pA(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class $z{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=pA(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=OF("rc",r),l=OF("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const Rz={kernelName:fi,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a}=t,{paddings:s,mode:i}=r,o=wa().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $z(a.shape,s,i):new Ez(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},_z=gD({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+nD+"\n  return result;\n"}),Az={kernelName:mi,backendName:"webgl",kernelFunc:_z};class Fz{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const Dz=gD({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Oz={kernelName:ks,backendName:"webgl",kernelFunc:Dz},Lz="return a - b;",Mz=gD({opSnippet:Lz,packedOpSnippet:Lz,supportsComplex:!0,cpuKernelImpl:$F}),zz={kernelName:wo,backendName:"webgl",kernelFunc:Mz};function Pz(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=Qr([s],a.shape),o=pz({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=fh(o.shape,i),u=ND({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Mz({inputs:{a:a,b:u},backend:n}),d=aM({inputs:{x:c},backend:n}),h=FD({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=ND({inputs:{x:h},backend:n,attrs:{shape:l}}),f=Dz({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const Bz={kernelName:oo,backendName:"webgl",kernelFunc:Pz};const Wz={kernelName:gi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:Pz({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Fz(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},Uz=jF+"\n  return -x;\n";const jz={kernelName:yi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=lF(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=wa().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new KF(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new UF(r.shape,Uz),n.runWebGLProgram(a,[r],r.dtype)}},Vz=Bp;const Gz={kernelName:vi,backendName:"webgl",kernelFunc:function(e){zo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=Vz(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Hz=Wp;const qz={kernelName:wi,backendName:"webgl",kernelFunc:function(e){zo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=Hz(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Kz=Up;const Xz={kernelName:ki,backendName:"webgl",kernelFunc:function(e){zo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:b}=Kz(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class Yz{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const Qz={kernelName:Ii,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=Vr(a.shape),c=new Yz(u,i,o,l),d=ND({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);const p=ND({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function Jz(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=PO({inputs:{input:r},backend:n}),t=Jz({inputs:{x:e},backend:n}),a=eL({inputs:{input:r},backend:n}),s=Jz({inputs:{x:a},backend:n}),i=iD({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return mM({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Zz={kernelName:_o,backendName:"webgl",kernelFunc:Jz};const eP={kernelName:Si,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=PO({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=eL({inputs:{input:a},backend:r}),i=Jz({inputs:{x:s},backend:r}),o=iD({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return mM({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const tP={kernelName:Ni,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return iM({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Ur(s,e.shape,"All tensors passed to stack must have matching shapes"),Wr(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=rL({inputs:t.map((e=>{const t=iM({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class nP{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=pA(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class rP{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=pA(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=OF("rc",r),l=OF("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const aP=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===Vr(a.shape)){const e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return mM({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}const o=wa().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rP(a.shape,s,i):new nP(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},sP={kernelName:Ci,backendName:"webgl",kernelFunc:aP},iP=gD({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+nD+"\n  return result;\n"}),oP={kernelName:Ti,backendName:"webgl",kernelFunc:iP};const lP={kernelName:$i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],u=Qr(s,a.shape);let c=u;const d=gh(c,o);let h,p=a;if(null!=d&&(p=OD({inputs:{x:a},backend:n,attrs:{perm:d}}),c=yh(c.length,o),l.push(p)),mh("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=cF(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=ph(p.shape,c),r=Vr(t),s=ND({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=$D(s,zl(a.dtype),"prod",n);h=ND({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(s),l.push(i)}if(i){l.push(h);const e=fh(h.shape,u);h=ND({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const uP={kernelName:Ri,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=dF(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const cP={kernelName:_i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=hF(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const dP={kernelName:Ai,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=pF(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},hP=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=fF(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},pP={kernelName:Fi,backendName:"webgl",kernelFunc:hP},fP=mD({opSnippet:"return 1.0 / x;"}),mP={kernelName:Oi,backendName:"webgl",kernelFunc:fP},gP=mD({opSnippet:jF+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),bP={kernelName:Li,backendName:"webgl",kernelFunc:gP},yP=mD({opSnippet:jF+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),xP={kernelName:Ui,backendName:"webgl",kernelFunc:yP};class vP{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class wP{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const kP={kernelName:Bi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=wa().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wP(a.shape,l,u,s,i):new vP(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}};class SP{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const IP={kernelName:Wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new SP(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class NP{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class CP{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const TP={kernelName:zi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=wa().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new CP(a.shape,l,u,s,i):new NP(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}};class EP{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const $P={kernelName:Pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new EP(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class RP{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=pA(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class _P{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=OF("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=pA(n);function o(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const AP={kernelName:ji,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=Qr(s,a.shape);if(0===i)return aD({inputs:{x:a},backend:n});const l=wa().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _P(a.shape,o):new RP(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}};class FP{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const DP={kernelName:Do,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new FP(a.shape,i),[c,d]=Tf(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},OP=mD({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),LP={kernelName:Vi,backendName:"webgl",kernelFunc:OP},MP=mD({opSnippet:"return inversesqrt(x);",cpuKernelImpl:mF}),zP={kernelName:Gi,backendName:"webgl",kernelFunc:MP};class PP{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=pA(a.length),l=pA(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class BP{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const o=pA(a.length),l=pA(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const WP={kernelName:Hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Lf(0,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);const p=ND({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=ND({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=wa().getBool("WEBGL_PACK")?new BP(l,o,p.shape.length,f.shape.length,c,h):new PP(l,o,p.shape.length,f.shape.length,c,h);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=ND({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class UP{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===wa().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const jP={kernelName:Ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new UP(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}};class VP{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}const s=pA(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const GP={kernelName:Xi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new VP(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],Ml(a.dtype,s.dtype))}},HP=mD({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Mf};\n  float scale = ${zf};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),qP={kernelName:Yi,backendName:"webgl",kernelFunc:HP},KP=mD({opSnippet:fD+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:bF}),XP={kernelName:to,backendName:"webgl",kernelFunc:KP},YP=mD({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),QP={kernelName:eo,backendName:"webgl",kernelFunc:YP},JP=mD({opSnippet:fD+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${nD}\n  return result;\n`}),ZP={kernelName:Ji,backendName:"webgl",kernelFunc:JP},eB=mD({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tB={kernelName:Zi,backendName:"webgl",kernelFunc:eB},nB=mD({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),rB={kernelName:no,backendName:"webgl",kernelFunc:nB},aB={kernelName:so,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Wr(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let b=1+s.length;b<a.shape.length;++b)l.push([0,0]);const u=[],c=aP({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=Ef(c.shape,s,o,!1),h=$f(d.length,s.length,!1),p=Rf(c.shape,s,o,!1),f=ND({inputs:{x:c},backend:n,attrs:{shape:d}}),m=OD({inputs:{x:f},backend:n,attrs:{perm:h}}),g=ND({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const sB={kernelName:lo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=vF(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const iB={kernelName:uo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=wF(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};const oB={kernelName:co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=kF(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const lB={kernelName:ho,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=kF(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const uB={kernelName:po,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Lf(0,a,o),p=!1;if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=pl(n.readSync(i.dataId)[0]),f=gF(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new PP(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=ND({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const cB={kernelName:io,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Qr(i,a.shape)[0],l=um(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{const t=[...d];t[o]=e;const r=_O({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},dB="return sqrt(x);",hB=mD({opSnippet:dB,packedOpSnippet:dB,cpuKernelImpl:SF}),pB={kernelName:ro,backendName:"webgl",kernelFunc:hB},fB={kernelName:mo,backendName:"webgl",kernelFunc:mD({opSnippet:"return x * x;"})},mB="return (a - b) * (a - b);",gB=gD({opSnippet:mB,packedOpSnippet:mB}),bB={kernelName:fo,backendName:"webgl",kernelFunc:gB};const yB={kernelName:go,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=Nm(n.readSync(a.dataId)),i=IF(s,"string",r);return n.makeTensorInfo(a.shape,"string",i)}};const xB={kernelName:Ao,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,s=jF+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new UF(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}};class vB{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=pA(n.length),s=pA(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const wB={kernelName:bo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=sd(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=ND({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||b){Wr(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=Hc(y,x,v),t=_O({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});w=ND({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=ec(a.shape,a.dtype,e),r=NF(p,t,v,y);w=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new vB(y,v,p);w=n.runWebGLProgram(e,[a],a.dtype)}}const k=ND({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const kB={kernelName:yo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=CF(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const SB={kernelName:xo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=TF(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const IB={kernelName:vo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(s.dataId),o=EF(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},NB=mD({opSnippet:"return tan(x);"}),CB={kernelName:ko,backendName:"webgl",kernelFunc:NB},TB=mD({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),EB={kernelName:So,backendName:"webgl",kernelFunc:TB};const $B={kernelName:qi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Lf(0,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);const p=ND({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=ND({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=ND({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new PP(l,o,p.shape.length,f.shape.length,c,h,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=ND({inputs:{x:b},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};class RB{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const r=pA(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function _B(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>pl(e))):e,r=ec(a.shape,a.dtype,t),i=RF(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new RB(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}const AB={kernelName:Io,backendName:"webgl",kernelFunc:_B};class FB{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class DB{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function OB(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function LB(e){let t=1;for(;t<e;)t*=2;return t}const MB={kernelName:No,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=wa().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=wa().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){const e=n.readSync(a.dataId),[t,r]=_F(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,mM({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=Vr(u)/c,m=ND({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&OB(n,p);const g=LB(s),b=LB(c);let y=null;const x=()=>null===y?[m,m]:[m,y],v=(e,t,r)=>{const a=x(),s=new FB(r),i=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=y;y=n.runWebGLProgram(s,a,"int32",i),OB(n,o)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)v(e,t,[f,b])}for(let N=b;N>g;N/=2){const e=x(),t=new DB([f,N/2]),r=[[c],[null===y?1:0],[g]],a=y;y=n.runWebGLProgram(t,e,"int32",r),OB(n,a);const s=g/2,i=2*s;for(let n=s;n>=1;n/=2)v(i,n,y.shape)}let w=y;y=_O({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),OB(n,w);let k=DM({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});OB(n,m);const S=u.slice(0,-1);S.push(s),w=y,y=ND({inputs:{x:y},attrs:{shape:S},backend:n}),OB(n,w);const I=k;return k=ND({inputs:{x:k},attrs:{shape:S},backend:n}),OB(n,I),[k,y]}};class zB{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const PB={kernelName:Co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new zB(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};const BB={kernelName:Eo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;K_(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=FF(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const WB={kernelName:$o,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;const e=_O({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=ND({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class UB{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const jB={kernelName:Ro,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[];let u=0;const c=gh([u],o);let d=a;null!=c&&(d=OD({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=yh(1,o)[0]);const h=Sm(d.shape,u,i),p=Vr([d.shape[u]]),f=ND({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=zl(a.dtype),g=(e,t,r,a,s)=>{const i=e.shape[0],o=e.shape[1],u=km(o,s),c=new UB({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;const h=hP({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=_B({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});l.push(h),l.push(p);return g(d,t,p,a,s)},b=ND({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}});let y=b;if(null!=c){l.push(b);const e=bh(c);y=OD({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},VB=[zD,BD,UD,VD,qD,YD,QD,JD,aO,sO,oO,uO,dO,pO,mO,yO,xO,kO,SO,IO,TO,FO,DO,OO,LO,WO,VO,qO,oD,YO,aL,hL,bL,xL,vL,wL,kL,IL,CL,EL,DL,OL,LL,zL,WL,VL,GL,qL,XL,YL,JL,ZL,tM,rM,sM,oM,cM,pM,gM,yM,wM,SM,CM,$M,RM,AM,OM,MM,PM,sD,BM,tL,UM,VM,HM,cD,KM,YM,QM,ZM,tz,rz,sz,oz,cz,hz,fz,gz,bz,yz,wz,kz,Sz,Iz,Nz,Tz,Rz,Az,Wz,ID,jz,Gz,qz,Xz,zO,Qz,eP,tP,sP,oP,pD,lP,uP,cP,dP,pP,BO,Oz,mP,bP,xP,CD,kP,IP,TP,$P,AP,DP,LP,zP,WP,jP,GP,qP,XP,QP,ZP,tB,AO,Bz,rB,aB,sB,iB,oB,lB,uB,cB,pB,fB,bB,yB,xB,wB,kB,SB,IB,zz,DD,CB,EB,$B,AB,MB,PB,LD,BB,WB,jB,Zz];for(const n of VB)Go(n);const GB=(e,t,n)=>ap([...t.map((t=>e.skills.includes(t)?1:0)),...n.map((t=>e.interests.includes(t)?1:0))]),HB=(e,t)=>{const n=[...new Set(t.flatMap((e=>e.skills)))],r=[...new Set(t.flatMap((e=>e.interests)))],a=GB(e,n,r);return t.filter((t=>t.id!==e.id)).map((t=>{const s=GB(t,n,r);var i,o;var l,u;const c=.7*(uh(ic(i=a,o=s)).dataSync()[0]/(pp(i).dataSync()[0]*pp(o).dataSync()[0]))+.3*(l=e.interests,u=t.interests,l.filter((e=>u.includes(e))).length/new Set([...l,...u]).size);return{...t,similarity:c}})).sort(((e,t)=>t.similarity-e.similarity)).slice(0,5)},qB=e=>{let{currentUserId:t}=e;const[n,r]=(0,i.useState)([]),[a,s]=(0,i.useState)(null),[o,l]=(0,i.useState)([]),[u,c]=(0,i.useState)(!0);return(0,i.useEffect)((()=>{(async()=>{try{const e=await Rr.get("/api/users");r(e.data);const n=e.data.find((e=>e.id===t));s(n)}catch(e){console.error("Error fetching users:",e)}finally{c(!1)}})()}),[t]),(0,i.useEffect)((()=>{if(a&&n.length>0){const e=HB(a,n);l(e)}}),[a,n]),(0,ht.jsxs)("div",{className:"bg-white p-4 rounded-lg shadow-md flex-1 overflow-y-auto",children:[(0,ht.jsx)("h3",{className:"text-lg font-bold mb-3 text-gray-800",children:"Recommended Connections"}),u?(0,ht.jsx)("p",{className:"text-gray-500",children:"Loading recommendations..."}):o.length>0?o.map((e=>(0,ht.jsxs)("div",{className:"flex items-center gap-4 border-b p-3",children:[(0,ht.jsx)("img",{src:e.profilePicture||"https://via.placeholder.com/50",alt:"Profile",className:"rounded-full w-12 h-12 object-cover border-2 border-gray-300"}),(0,ht.jsxs)("div",{className:"flex-1",children:[(0,ht.jsx)("p",{className:"font-semibold text-gray-700",children:e.name}),(0,ht.jsxs)("p",{className:"text-sm text-gray-500",children:["Skills: ",e.skills.join(", ")]}),(0,ht.jsxs)("p",{className:"text-sm text-gray-500",children:["Interests: ",e.interests.join(", ")]})]}),(0,ht.jsx)("button",{className:"bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition",children:"Connect"})]},e.id))):(0,ht.jsx)("p",{className:"text-gray-500",children:"No recommendations available"})]})},KB=(0,i.createContext)(),XB=e=>{let{children:t}=e;const[n,r]=(0,i.useState)(null),[a,s]=(0,i.useState)(null);return(0,i.useEffect)((()=>{try{const e=localStorage.getItem("currentUser");if(e){const t=JSON.parse(e);r(t),s(t.role||"student")}}catch(e){}}),[]),(0,ht.jsx)(KB.Provider,{value:{currentUser:n,role:a},children:t})},YB=()=>{const{currentUser:e}=(0,i.useContext)(KB),[t,n]=(0,i.useState)([]),[r,a]=(0,i.useState)(""),[s,o]=(0,i.useState)(""),[l,u]=(0,i.useState)("received"),[c,d]=(0,i.useState)([]),h=(0,i.useRef)(null);(0,i.useEffect)((()=>{if(!e)return;(async()=>{try{const{data:e}=await Rr.get("http://localhost:5000/api/users");d(e.map((e=>({id:e._id||e.id,displayName:e.displayName||e.name}))))}catch(DW){console.error("Failed to load users",DW)}})()}),[e]),(0,i.useEffect)((()=>{if(!e||!s)return;(async()=>{try{const t=e.id||e._id,{data:r}=await Rr.get(`http://localhost:5000/api/messages?a=${t}&b=${s}`);n(r.map((e=>({id:e._id,...e}))))}catch(DW){console.error("Failed to load messages",DW)}})()}),[s,e]);const p=async()=>{if(r.trim()&&s.trim()&&e)try{const t=e.id||e._id,i={text:r,senderId:t,recipientId:s,createdAt:(new Date).toISOString()};await Rr.post("http://localhost:5000/api/messages",i),a("");const o={id:Date.now(),...i,_id:Date.now()};n((e=>[...e,o])),setTimeout((()=>{var e;null===(e=h.current)||void 0===e||e.scrollIntoView({behavior:"smooth"})}),100);const{data:l}=await Rr.get(`http://localhost:5000/api/messages?a=${t}&b=${s}`);n(l.map((e=>({id:e._id,...e}))))}catch(t){console.error("Error sending message:",t),n((e=>e.filter((e=>e.id!==Date.now()))))}};return(0,ht.jsx)("div",{className:"bg-gray-800 p-4 rounded-lg shadow-lg flex flex-col h-full",children:e?(0,ht.jsxs)(ht.Fragment,{children:[(0,ht.jsxs)("div",{className:"mb-2",children:[(0,ht.jsx)("label",{className:"block text-xs text-gray-300 mb-1",children:"Select a user to chat with:"}),(0,ht.jsxs)("select",{value:s,onChange:e=>o(e.target.value),className:"w-full p-2 text-sm rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-500 focus:outline-none",children:[(0,ht.jsx)("option",{value:"",children:"Choose a user..."}),c.filter((t=>t.id!==(e.id||e._id))).map((e=>(0,ht.jsxs)("option",{value:e.id,children:[e.displayName||"Anonymous"," (",e.id,")"]},e.id)))]})]}),(0,ht.jsx)("div",{className:"flex justify-center mb-2",children:(0,ht.jsxs)("div",{className:"inline-flex rounded-full bg-gray-700 p-1 shadow-inner",children:[(0,ht.jsx)("button",{onClick:()=>u("received"),className:"px-4 py-1 rounded-full text-xs font-medium transition-all duration-200 "+("received"===l?"bg-blue-600 text-white shadow-md":"text-gray-300 hover:text-white hover:bg-gray-600"),children:"Received"}),(0,ht.jsx)("button",{onClick:()=>u("sent"),className:"px-4 py-1 rounded-full text-xs font-medium transition-all duration-200 "+("sent"===l?"bg-blue-600 text-white shadow-md":"text-gray-300 hover:text-white hover:bg-gray-600"),children:"Sent"})]})}),(0,ht.jsxs)("div",{className:"overflow-y-auto flex flex-col space-y-1 mb-2 p-2 bg-gray-900 rounded-lg flex-grow min-h-[100px] max-h-[400px] chat-scrollbar",children:[s?(()=>{const n=t.filter((t=>"sent"===l?String(t.senderId)===String(e.id||e._id)&&String(t.recipientId)===String(s):String(t.senderId)===String(s)&&String(t.recipientId)===String(e.id||e._id)));return n.length>0?n.map((t=>(0,ht.jsxs)("div",{className:"p-2 text-sm max-w-[80%] rounded-lg "+(String(t.senderId)===String(e.id||e._id)?"ml-auto bg-blue-500 text-white text-right":"bg-gray-600 text-white"),children:[(0,ht.jsx)("p",{children:t.text}),(0,ht.jsx)("p",{className:"text-xs opacity-70 mt-1",children:new Date(t.createdAt||Date.now()).toLocaleTimeString()})]},t.id))):(0,ht.jsx)("div",{className:"flex items-center justify-center h-full",children:(0,ht.jsx)("p",{className:"text-gray-400 text-sm",children:"No messages yet. Start the conversation!"})})})():(0,ht.jsx)("div",{className:"flex items-center justify-center h-full",children:(0,ht.jsx)("p",{className:"text-gray-400 text-sm",children:"Select a user to start chatting"})}),(0,ht.jsx)("div",{ref:h})]}),(0,ht.jsxs)("div",{className:"border-t border-gray-600 pt-3 flex-shrink-0 bg-gray-800 rounded-lg",children:[(0,ht.jsxs)("div",{className:"flex items-center space-x-2",children:[(0,ht.jsx)("input",{type:"text",value:r,onChange:e=>a(e.target.value),onKeyDown:e=>{"Enter"===e.key&&(e.preventDefault(),p())},placeholder:s?"Type your message here...":"Select a user first to start chatting",disabled:!s,className:"flex-grow p-3 text-sm border-2 border-blue-500 rounded-lg bg-gray-700 text-white focus:border-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed disabled:border-gray-600"}),(0,ht.jsx)("button",{onClick:p,disabled:!s||!r.trim(),className:"bg-blue-600 disabled:bg-gray-500 disabled:cursor-not-allowed text-white px-6 py-3 text-sm rounded-lg hover:bg-blue-700 transition-colors font-medium shadow-lg",children:"Send"})]}),!s&&(0,ht.jsx)("p",{className:"text-xs text-gray-400 mt-2 text-center",children:"Please select a user from the dropdown above to start chatting"})]})]}):(0,ht.jsx)("p",{className:"text-center text-gray-400",children:"Loading chat..."})})},QB=()=>{const e=ae(),[t,n]=(0,i.useState)(!1);return(0,ht.jsxs)("div",{className:"min-h-screen bg-gradient-to-br from-gray-900 to-gray-800 text-white font-sans",children:[(0,ht.jsxs)("div",{className:"bg-gray-900 text-white p-4 flex justify-between items-center shadow-lg",children:[(0,ht.jsx)("h2",{className:"text-2xl font-extrabold text-blue-400",children:"Academix"}),(0,ht.jsx)("button",{onClick:()=>n(!t),className:"bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-full shadow-lg transition duration-300",children:"\ud83d\udc64"})]}),(0,ht.jsx)("div",{className:`fixed top-0 left-0 h-full w-56 bg-gray-800 p-4 transform ${t?"translate-x-0":"-translate-x-64"} transition-transform duration-300 ease-in-out`,children:(0,ht.jsxs)("ul",{className:"space-y-3",children:[(0,ht.jsx)("li",{children:(0,ht.jsx)("button",{onClick:()=>e("/profile-settings"),className:"w-full p-2 bg-blue-600 rounded-md hover:bg-blue-700 transition",children:"Profile Settings"})}),(0,ht.jsx)("li",{children:(0,ht.jsx)("button",{onClick:()=>e("/account-management"),className:"w-full p-2 bg-blue-600 rounded-md hover:bg-blue-700 transition",children:"Account Management"})}),(0,ht.jsx)("li",{children:(0,ht.jsx)("button",{onClick:()=>{localStorage.removeItem("authToken"),e("/")},className:"w-full p-2 bg-red-600 rounded-md hover:bg-red-700 transition",children:"Sign Out"})})]})}),(0,ht.jsx)("div",{className:"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 p-4",children:[{path:"/collaborations",icon:"\ud83d\udc65",title:"Collaborations",count:3,color:"blue"},{path:"/studygroup",icon:"\ud83d\udcd6",title:"Study Groups",count:2,color:"purple"},{path:"/project",icon:"\ud83c\udfaf",title:"Projects",count:4,color:"green"},{path:"/queries-written",icon:"\ud83d\udcc5",title:"Queries",count:5,color:"red"},{path:"/event",icon:"\ud83d\udcc5",title:"Events",count:"Manage",color:"blue"}].map(((t,n)=>(0,ht.jsxs)("button",{onClick:()=>e(t.path),className:`flex flex-col items-center justify-center bg-${t.color}-500 text-white p-4 w-full max-w-[180px] h-auto rounded-lg shadow-lg hover:bg-${t.color}-600 transition duration-300 mx-auto`,children:[(0,ht.jsx)("span",{className:"text-3xl",children:t.icon}),(0,ht.jsx)("span",{className:"font-semibold text-sm",children:t.title}),(0,ht.jsx)("span",{className:"text-lg font-bold",children:t.count})]},n)))}),(0,ht.jsxs)("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4",children:[(0,ht.jsxs)("div",{className:"bg-gray-800 p-4 rounded-lg shadow-lg min-h-[224px] max-h-[500px] flex flex-col",children:[(0,ht.jsx)("h2",{className:"text-lg font-bold mb-2",children:"Recent Activity"}),(0,ht.jsx)("div",{className:"text-sm flex-grow overflow-hidden",children:(0,ht.jsx)(Fr,{})})]}),(0,ht.jsxs)("div",{className:"bg-gray-800 p-4 rounded-lg shadow-lg min-h-[224px] max-h-[500px] flex flex-col",children:[(0,ht.jsx)("h2",{className:"text-lg font-bold mb-2",children:"Your Peers"}),(0,ht.jsx)("div",{className:"text-sm flex-grow overflow-hidden",children:(0,ht.jsx)(qB,{})})]}),(0,ht.jsxs)("div",{className:"bg-gray-800 p-4 rounded-lg shadow-lg min-h-[320px] max-h-[600px] flex flex-col",children:[(0,ht.jsx)("h2",{className:"text-lg font-bold mb-2",children:"Chat"}),(0,ht.jsx)("div",{className:"text-sm flex-grow overflow-hidden",children:(0,ht.jsx)(YB,{})})]})]})]})},JB=()=>{ae();const[e,t]=(0,i.useState)([]);(0,i.useEffect)((()=>{(async()=>{try{const{data:e}=await Rr.get("http://localhost:5000/api/users");t(e.map((e=>({id:e._id||e.id,name:e.name,email:e.email,phone:e.phone,restricted:e.restricted}))))}catch(DW){console.error("Failed to load students",DW)}})()}),[]);return(0,ht.jsxs)("div",{className:"min-h-screen bg-gray-900 text-white p-6",children:[(0,ht.jsx)("h2",{className:"text-3xl font-bold text-blue-400",children:"\ud83d\udc68\u200d\ud83c\udf93 Student Details"}),(0,ht.jsx)("div",{className:"bg-gray-800 p-6 rounded-lg shadow-lg mt-4",children:(0,ht.jsxs)("table",{className:"w-full border-collapse border border-gray-700",children:[(0,ht.jsx)("thead",{children:(0,ht.jsxs)("tr",{className:"bg-gray-800 text-white",children:[(0,ht.jsx)("th",{className:"p-2 border",children:"ID"}),(0,ht.jsx)("th",{className:"p-2 border",children:"Name"}),(0,ht.jsx)("th",{className:"p-2 border",children:"Email"}),(0,ht.jsx)("th",{className:"p-2 border",children:"Phone"}),(0,ht.jsx)("th",{className:"p-2 border",children:"Actions"})]})}),(0,ht.jsx)("tbody",{children:e.length>0?e.map((n=>(0,ht.jsxs)("tr",{className:"text-center border border-gray-700",children:[(0,ht.jsx)("td",{className:"p-2 border",children:n.id}),(0,ht.jsx)("td",{className:"p-2 border",children:n.name||"N/A"}),(0,ht.jsx)("td",{className:"p-2 border",children:n.email}),(0,ht.jsx)("td",{className:"p-2 border",children:n.phone||"N/A"}),(0,ht.jsxs)("td",{className:"p-2 border flex justify-center gap-2",children:[(0,ht.jsx)("button",{onClick:()=>(async(n,r)=>{const a=e.map((e=>e.id===n?{...e,restricted:!r}:e));t(a);try{await Rr.patch(`http://localhost:5000/api/users/${n}`,{restricted:!r})}catch(s){console.error("Error updating user restriction:",s)}})(n.id,n.restricted),className:`px-3 py-1 rounded-lg text-white ${n.restricted?"bg-green-600 hover:bg-green-700":"bg-yellow-600 hover:bg-yellow-700"} transition`,children:n.restricted?"\u2705 Unrestrict":"\ud83d\udeab Restrict"}),(0,ht.jsx)("button",{onClick:()=>(async n=>{window.confirm("Are you sure you want to delete this student?")&&(await Rr.delete(`http://localhost:5000/api/users/${n}`),t(e.filter((e=>e.id!==n))))})(n.id),className:"bg-red-600 text-white px-4 py-1 rounded-lg hover:bg-red-700 transition",children:"\u274c Delete"})]})]},n.id))):(0,ht.jsx)("tr",{children:(0,ht.jsx)("td",{colSpan:"5",className:"p-4 text-gray-400",children:"No students found."})})})]})})]})},ZB=()=>{const[e,t]=(0,i.useState)({name:"",email:"",username:"",bio:"",profilePic:null}),n=n=>{const{name:r,value:a}=n.target;t({...e,[r]:a})};return(0,ht.jsxs)("div",{className:"max-w-lg mx-auto p-6 bg-white shadow-lg rounded-lg",children:[(0,ht.jsx)("h2",{className:"text-2xl font-bold text-gray-800 mb-6 text-center",children:"Profile Settings"}),(0,ht.jsxs)("div",{className:"mb-6 text-center",children:[(0,ht.jsx)("label",{className:"block font-semibold text-gray-700 mb-2",children:"Profile Picture"}),(0,ht.jsx)("input",{type:"file",accept:"image/*",onChange:n=>{const r=n.target.files[0];t({...e,profilePic:r})},className:"block w-full text-sm text-gray-700 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border file:border-gray-300 file:bg-gray-100 file:text-blue-600 hover:file:bg-gray-200 transition"}),e.profilePic&&(0,ht.jsx)("img",{src:URL.createObjectURL(e.profilePic),alt:"Profile Preview",className:"w-24 h-24 rounded-full mt-3 mx-auto border-2 border-gray-300 object-cover"})]}),(0,ht.jsxs)("form",{onSubmit:t=>{t.preventDefault(),console.log("Updated Profile:",e),alert("Profile updated successfully!")},className:"space-y-4",children:[(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{htmlFor:"name",className:"block font-semibold text-gray-700",children:"Full Name"}),(0,ht.jsx)("input",{type:"text",id:"name",name:"name",value:e.name,onChange:n,className:"w-full border border-gray-300 p-3 rounded-lg focus:ring-2 focus:ring-blue-400 focus:outline-none",placeholder:"Enter your full name"})]}),(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{htmlFor:"email",className:"block font-semibold text-gray-700",children:"Email"}),(0,ht.jsx)("input",{type:"email",id:"email",name:"email",value:e.email,onChange:n,className:"w-full border border-gray-300 p-3 rounded-lg focus:ring-2 focus:ring-blue-400 focus:outline-none",placeholder:"Enter your email"})]}),(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{htmlFor:"username",className:"block font-semibold text-gray-700",children:"Username"}),(0,ht.jsx)("input",{type:"text",id:"username",name:"username",value:e.username,onChange:n,className:"w-full border border-gray-300 p-3 rounded-lg focus:ring-2 focus:ring-blue-400 focus:outline-none",placeholder:"Enter your username"})]}),(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{htmlFor:"bio",className:"block font-semibold text-gray-700",children:"Bio"}),(0,ht.jsx)("textarea",{id:"bio",name:"bio",value:e.bio,onChange:n,className:"w-full border border-gray-300 p-3 rounded-lg h-24 resize-none focus:ring-2 focus:ring-blue-400 focus:outline-none",placeholder:"Tell something about yourself"})]}),(0,ht.jsx)("button",{type:"submit",className:"w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 transition",children:"Update Profile"})]})]})},eW=()=>{const[e,t]=(0,i.useState)(!1),[n,r]=(0,i.useState)(!1),[a,s]=(0,i.useState)([{id:1,device:"Windows PC",location:"New York, USA",lastLogin:"2025-02-01 10:30 AM"},{id:2,device:"Android Phone",location:"Los Angeles, USA",lastLogin:"2025-02-03 8:15 PM"},{id:3,device:"MacBook Pro",location:"London, UK",lastLogin:"2025-02-02 5:00 PM"}]);return(0,ht.jsxs)("div",{className:"p-6 bg-gray-100 min-h-screen",children:[(0,ht.jsx)("h2",{className:"text-2xl font-bold mb-4",children:"Account Management"}),(0,ht.jsxs)("div",{className:"bg-white p-4 rounded-lg shadow-md mb-6",children:[(0,ht.jsx)("h3",{className:"text-lg font-semibold mb-2",children:"Active Login Sessions"}),(0,ht.jsx)("ul",{children:a.length>0?a.map((e=>(0,ht.jsxs)("li",{className:"border-b py-3 flex justify-between items-center",children:[(0,ht.jsxs)("div",{children:[(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Device:"})," ",e.device]}),(0,ht.jsxs)("p",{className:"text-gray-500",children:[(0,ht.jsx)("strong",{children:"Location:"})," ",e.location]}),(0,ht.jsxs)("p",{className:"text-gray-500",children:[(0,ht.jsx)("strong",{children:"Last Login:"})," ",e.lastLogin]})]}),(0,ht.jsx)("button",{onClick:()=>{return t=e.id,s(a.filter((e=>e.id!==t))),void alert("Logged out from the selected device.");var t},className:"bg-red-500 text-white px-3 py-1 rounded-lg hover:bg-red-600 transition",children:"Logout"})]},e.id))):(0,ht.jsx)("p",{className:"text-gray-500",children:"No active sessions."})}),a.length>1&&(0,ht.jsx)("button",{onClick:()=>{s([]),alert("Logged out from all other devices.")},className:"mt-4 w-full bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition",children:"Logout from All Devices"})]}),(0,ht.jsxs)("div",{className:"bg-white p-4 rounded-lg shadow-md",children:[(0,ht.jsx)("h3",{className:"text-lg font-semibold mb-2",children:"Security Settings"}),(0,ht.jsxs)("div",{className:"flex justify-between items-center border-b py-3",children:[(0,ht.jsx)("p",{className:"text-gray-700",children:"Enable 2-Step Verification"}),(0,ht.jsxs)("label",{className:"relative inline-flex items-center cursor-pointer",children:[(0,ht.jsx)("input",{type:"checkbox",className:"sr-only peer",checked:e,onChange:()=>t(!e)}),(0,ht.jsx)("div",{className:"w-11 h-6 bg-gray-300 peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-5 peer-checked:after:border-white after:content-[''] after:absolute after:top-1 after:left-1 after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"})]})]}),(0,ht.jsxs)("div",{className:"flex justify-between items-center border-b py-3",children:[(0,ht.jsx)("p",{className:"text-gray-700",children:"Enable Multi-Step Verification"}),(0,ht.jsxs)("label",{className:"relative inline-flex items-center cursor-pointer",children:[(0,ht.jsx)("input",{type:"checkbox",className:"sr-only peer",checked:n,onChange:()=>r(!n)}),(0,ht.jsx)("div",{className:"w-11 h-6 bg-gray-300 peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-5 peer-checked:after:border-white after:content-[''] after:absolute after:top-1 after:left-1 after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"})]})]})]})]})},tW=()=>{const e=ae(),[t,n]=(0,i.useState)("dashboard"),[r,a]=(0,i.useState)([]);return(0,i.useEffect)((()=>{a([{id:1,name:"John Doe",action:"Joined Study Group",date:"23-Mar-2025"},{id:2,name:"Jane Smith",action:"Posted a Query",date:"22-Mar-2025"}])}),[]),(0,ht.jsxs)("div",{className:"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-700 text-white",children:[(0,ht.jsxs)("div",{className:"bg-gray-900 text-white p-4 flex justify-between items-center shadow-lg",children:[(0,ht.jsx)("h2",{className:"text-2xl font-extrabold text-blue-400",children:"Admin Dashboard"}),(0,ht.jsx)("button",{onClick:()=>e("/login"),className:"bg-red-600 text-white p-2 rounded-lg hover:bg-red-700 transition",children:"\ud83d\udeaa Logout"})]}),(0,ht.jsxs)("div",{className:"flex justify-center gap-4 p-4",children:[(0,ht.jsx)("button",{onClick:()=>n("dashboard"),className:`p-2 rounded-lg ${"dashboard"===t?"bg-blue-500":"bg-gray-700"} text-white hover:bg-blue-600 transition`,children:"\ud83c\udf93 Student Management"}),(0,ht.jsx)("button",{onClick:()=>n("profile"),className:`p-2 rounded-lg ${"profile"===t?"bg-blue-500":"bg-gray-700"} text-white hover:bg-blue-600 transition`,children:"\ud83d\udee0 Profile Settings"}),(0,ht.jsx)("button",{onClick:()=>n("account"),className:`p-2 rounded-lg ${"account"===t?"bg-blue-500":"bg-gray-700"} text-white hover:bg-blue-600 transition`,children:"\u2699 Account Management"})]}),(0,ht.jsxs)("div",{className:"p-6",children:["dashboard"===t&&(0,ht.jsxs)(ht.Fragment,{children:[(0,ht.jsx)("div",{className:"p-6",children:(0,ht.jsx)("button",{onClick:()=>e("/student-details"),className:"bg-blue-500 text-white p-3 w-[200px] rounded-lg shadow-lg hover:bg-blue-600 transition",children:"\ud83d\udc68\u200d\ud83c\udf93 View All Students"})}),(0,ht.jsxs)("div",{className:"bg-gray-800 p-6 rounded-lg shadow-lg mt-6 mx-4",children:[(0,ht.jsx)("h3",{className:"text-xl font-bold mb-4 text-blue-400",children:"\ud83d\udcca Student Activity Logs"}),(0,ht.jsxs)("table",{className:"w-full border-collapse border border-gray-700",children:[(0,ht.jsx)("thead",{children:(0,ht.jsxs)("tr",{className:"bg-gray-900 text-white",children:[(0,ht.jsx)("th",{className:"p-2 border",children:"Student"}),(0,ht.jsx)("th",{className:"p-2 border",children:"Activity"}),(0,ht.jsx)("th",{className:"p-2 border",children:"Date"})]})}),(0,ht.jsx)("tbody",{children:r.length>0?r.map((e=>(0,ht.jsxs)("tr",{className:"text-center border border-gray-700",children:[(0,ht.jsx)("td",{className:"p-2 border",children:e.name}),(0,ht.jsx)("td",{className:"p-2 border",children:e.action}),(0,ht.jsx)("td",{className:"p-2 border",children:e.date})]},e.id))):(0,ht.jsx)("tr",{children:(0,ht.jsx)("td",{colSpan:"3",className:"p-4 text-gray-400",children:"No activities recorded."})})})]})]})]}),"profile"===t&&(0,ht.jsx)(ZB,{}),"account"===t&&(0,ht.jsx)(eW,{})]}),(0,ht.jsxs)("div",{className:"text-center text-gray-400 text-sm mt-6 p-4",children:["\u24b8 ",(new Date).getFullYear()," EduTech Admin Panel"]})]})};!function(e){if(!e||"undefined"==typeof document)return;let t=document.head||document.getElementsByTagName("head")[0],n=document.createElement("style");n.type="text/css",t.firstChild?t.insertBefore(n,t.firstChild):t.appendChild(n),n.styleSheet?n.styleSheet.cssText=e:n.appendChild(document.createTextNode(e))}(':root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n');var nW=e=>"number"==typeof e&&!isNaN(e),rW=e=>"string"==typeof e,aW=e=>"function"==typeof e,sW=e=>(0,i.isValidElement)(e)||rW(e)||aW(e)||nW(e);function iW(e){let{enter:t,exit:n,appendPosition:r=!1,collapse:a=!0,collapseDuration:s=300}=e;return function(e){let{children:o,position:l,preventExitTransition:u,done:c,nodeRef:d,isIn:h,playToast:p}=e,f=r?`${t}--${l}`:t,m=r?`${n}--${l}`:n,g=(0,i.useRef)(0);return(0,i.useLayoutEffect)((()=>{let e=d.current,t=f.split(" "),n=r=>{r.target===d.current&&(p(),e.removeEventListener("animationend",n),e.removeEventListener("animationcancel",n),0===g.current&&"animationcancel"!==r.type&&e.classList.remove(...t))};e.classList.add(...t),e.addEventListener("animationend",n),e.addEventListener("animationcancel",n)}),[]),(0,i.useEffect)((()=>{let e=d.current,t=()=>{e.removeEventListener("animationend",t),a?function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:300,{scrollHeight:r,style:a}=e;requestAnimationFrame((()=>{a.minHeight="initial",a.height=r+"px",a.transition=`all ${n}ms`,requestAnimationFrame((()=>{a.height="0",a.padding="0",a.margin="0",setTimeout(t,n)}))}))}(e,c,s):c()};h||(u?t():(g.current=1,e.className+=` ${m}`,e.addEventListener("animationend",t)))}),[h]),i.createElement(i.Fragment,null,o)}}var oW=1,lW=()=>""+oW++;var uW=new Map,cW=[],dW=new Set,hW=()=>uW.size>0;function pW(e,t){var n;if(t)return!(null==(n=uW.get(t))||!n.isToastActive(e));let r=!1;return uW.forEach((t=>{t.isToastActive(e)&&(r=!0)})),r}function fW(e){if(hW()){if(null==e||(e=>rW(e)||nW(e))(e))uW.forEach((t=>{t.removeToast(e)}));else if(e&&("containerId"in e||"id"in e)){let t=uW.get(e.containerId);t?t.removeToast(e.id):uW.forEach((t=>{t.removeToast(e.id)}))}}else cW=cW.filter((t=>null!=e&&t.options.toastId!==e))}function mW(e,t){sW(e)&&(hW()||cW.push({content:e,options:t}),uW.forEach((n=>{n.buildToast(e,t)})))}function gW(e,t){uW.forEach((n=>{(null==t||null==t||!t.containerId||(null==t?void 0:t.containerId)===n.id)&&n.toggle(e,null==t?void 0:t.id)}))}function bW(e){return e&&(rW(e.toastId)||nW(e.toastId))?e.toastId:lW()}function yW(e,t){return mW(e,t),t.toastId}function xW(e,t){return{...t,type:t&&t.type||e,toastId:bW(t)}}function vW(e){return(t,n)=>yW(t,xW(e,n))}function wW(e,t){return yW(e,xW("default",t))}wW.loading=(e,t)=>yW(e,xW("default",{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...t})),wW.promise=function(e,t,n){let r,{pending:a,error:s,success:i}=t;a&&(r=rW(a)?wW.loading(a,n):wW.loading(a.render,{...n,...a}));let o={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null},l=(e,t,a)=>{if(null==t)return void wW.dismiss(r);let s={type:e,...o,...n,data:a},i=rW(t)?{render:t}:t;return r?wW.update(r,{...s,...i}):wW(i.render,{...s,...i}),a},u=aW(e)?e():e;return u.then((e=>l("success",i,e))).catch((e=>l("error",s,e))),u},wW.success=vW("success"),wW.info=vW("info"),wW.error=vW("error"),wW.warning=vW("warning"),wW.warn=wW.warning,wW.dark=(e,t)=>yW(e,xW("default",{theme:"dark",...t})),wW.dismiss=function(e){fW(e)},wW.clearWaitingQueue=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};uW.forEach((t=>{t.props.limit&&(!e.containerId||t.id===e.containerId)&&t.clearQueue()}))},wW.isActive=pW,wW.update=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=((e,t)=>{let{containerId:n}=t;var r;return null==(r=uW.get(n||1))?void 0:r.toasts.get(e)})(e,t);if(n){let{props:r,content:a}=n,s={delay:100,...r,...t,toastId:t.toastId||e,updateId:lW()};s.toastId!==e&&(s.staleId=e);let i=s.render||a;delete s.render,yW(i,s)}},wW.done=e=>{wW.update(e,{progress:1})},wW.onChange=function(e){return dW.add(e),()=>{dW.delete(e)}},wW.play=e=>gW(!0,e),wW.pause=e=>gW(!1,e);"undefined"!=typeof window?i.useLayoutEffect:i.useEffect;var kW=function(e){return{enter:`Toastify--animate Toastify__${e}-enter`,exit:`Toastify--animate Toastify__${e}-exit`,appendPosition:arguments.length>1&&void 0!==arguments[1]&&arguments[1]}};iW(kW("bounce",!0)),iW(kW("slide",!0)),iW(kW("zoom")),iW(kW("flip"));const SW=()=>{const[e,t]=(0,i.useState)({title:"",description:"",technologies:"",startDate:"",endDate:"",level:"",contactEmail:""}),[n,r]=(0,i.useState)(!1),[a,s]=(0,i.useState)([]),o=(e,t)=>{if(!e||!t)return"";const n=new Date(e),r=new Date(t),a=Math.abs(r-n);return Math.ceil(a/864e5)+" days"},l=n=>{t({...e,[n.target.name]:n.target.value})};return(0,i.useEffect)((()=>{Rr.get("http://localhost:5000/api/projects").then((e=>{let{data:t}=e;return s(t)})).catch((()=>{}))}),[]),(0,ht.jsxs)("div",{className:"min-h-screen bg-gradient-to-br from-blue-50 to-blue-100 flex flex-col items-center p-8",children:[(0,ht.jsxs)("div",{className:"w-full max-w-4xl flex justify-between items-center bg-white p-6 rounded-xl shadow-lg",children:[(0,ht.jsx)("h2",{className:"text-3xl font-bold text-blue-700",children:"\ud83d\ude80 Projects Hub"}),(0,ht.jsx)("button",{onClick:()=>r(!n),className:"px-5 py-3 bg-blue-600 text-white font-semibold rounded-xl shadow-md hover:bg-blue-700 transition",children:n?"Close Form":"\u2795 Post a Project"})]}),(0,ht.jsxs)("div",{className:"w-full max-w-4xl mt-8",children:[(0,ht.jsx)("h3",{className:"text-2xl font-semibold text-blue-700 mb-4",children:"Available Projects"}),(0,ht.jsx)("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-6",children:a.map((e=>(0,ht.jsxs)("div",{className:"bg-white p-6 rounded-xl shadow-lg border-l-4 border-blue-500 transform hover:scale-105 transition",children:[(0,ht.jsx)("h4",{className:"text-xl font-semibold text-gray-800",children:e.title}),(0,ht.jsx)("p",{className:"text-gray-600 mt-2",children:e.description}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Technologies:"})," ",e.technologies]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Level:"})," ",e.level]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Start Date:"})," ",e.startDate]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"End Date:"})," ",e.endDate]}),(0,ht.jsxs)("p",{className:"text-gray-700 font-bold",children:[(0,ht.jsx)("strong",{children:"Duration:"})," ",o(e.startDate,e.endDate)]}),(0,ht.jsx)("button",{onClick:()=>{return t=e._id,void Rr.delete(`http://localhost:5000/api/projects/${t}`).then((()=>{s(a.filter((e=>e._id!==t))),wW.info("Project deleted!",{position:"top-right"})})).catch((()=>wW.error("Failed to delete",{position:"top-right"})));var t},className:"mt-3 px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition",children:"\ud83d\uddd1\ufe0f Delete"})]},e._id)))})]}),n&&(0,ht.jsxs)("form",{onSubmit:n=>{n.preventDefault(),e.title&&e.description&&e.contactEmail&&e.startDate&&e.endDate?Rr.post("http://localhost:5000/api/projects",e).then((e=>{let{data:n}=e;s([n,...a]),wW.success("Project posted successfully! \ud83c\udf89",{position:"top-right"}),t({title:"",description:"",technologies:"",startDate:"",endDate:"",level:"",contactEmail:""}),r(!1),Rr.get("http://localhost:5000/api/projects").then((e=>{let{data:t}=e;return s(t)})).catch((()=>{}))})).catch((()=>wW.error("Failed to post project",{position:"top-right"}))):wW.error("Please fill in all required fields!",{position:"top-right"})},className:"w-full max-w-3xl bg-white p-6 mt-8 rounded-xl shadow-lg transform transition-all animate-fadeIn",children:[(0,ht.jsx)("h3",{className:"text-2xl font-semibold text-blue-700 mb-4",children:"\ud83d\udccc Post a New Project"}),["title","description","technologies","contactEmail"].map(((t,n)=>(0,ht.jsxs)("div",{className:"mb-4",children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold capitalize",children:t}),(0,ht.jsx)("input",{type:"contactEmail"===t?"email":"text",name:t,value:e[t],onChange:l,required:!0,className:"w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 text-gray-700",placeholder:`Enter ${t}...`})]},n))),["startDate","endDate"].map(((t,n)=>(0,ht.jsxs)("div",{className:"mb-4",children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold",children:"startDate"===t?"Start Date":"End Date"}),(0,ht.jsx)("input",{type:"date",name:t,value:e[t],onChange:l,required:!0,className:"w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 text-gray-700"})]},n))),e.startDate&&e.endDate&&(0,ht.jsxs)("p",{className:"text-lg font-bold text-blue-700 mb-4",children:["\u23f3 Total Duration: ",o(e.startDate,e.endDate)]}),(0,ht.jsx)("button",{type:"submit",className:"w-full px-5 py-3 bg-blue-600 text-white font-semibold rounded-xl shadow-md hover:bg-blue-700 transition",children:"\ud83d\ude80 Submit Project"})]})]})},IW=()=>{const e=ae(),[t,n]=(0,i.useState)([{id:1,title:"Math Study Group",description:"Collaborate with peers to solve math problems.",level:"Beginner",contactEmail:"mathgroup@example.com"},{id:2,title:"Science Study Group",description:"Learn and discuss scientific concepts.",level:"Intermediate",contactEmail:"sciencegroup@example.com"}]),[r,a]=(0,i.useState)([{id:1,title:"React App Development",description:"Develop a simple web app using React.",prerequisites:"Basic HTML, CSS, and JavaScript",skills:"React, JavaScript",level:"Beginner",contactEmail:"reactproject@example.com"},{id:2,title:"Data Science Project",description:"Analyze data and build machine learning models.",prerequisites:"Python, Statistics",skills:"Python, Machine Learning",level:"Hard",contactEmail:"datascienceproject@example.com"}]),s=[...t,...r];return(0,ht.jsxs)("div",{className:"min-h-screen bg-gray-100 flex flex-col items-center p-6",children:[(0,ht.jsx)("h2",{className:"text-2xl font-bold text-gray-800 mb-6",children:"Active Collaborations"}),(0,ht.jsxs)("div",{className:"w-full max-w-3xl bg-white p-6 rounded-lg shadow-md",children:[(0,ht.jsx)("h3",{className:"text-xl font-semibold mb-4",children:"Collaboration List"}),(0,ht.jsx)("ul",{children:s.length>0?s.map((e=>(0,ht.jsxs)("li",{className:"border-b py-4",children:[(0,ht.jsx)("h4",{className:"font-semibold",children:e.title}),(0,ht.jsx)("p",{children:e.description}),(0,ht.jsxs)("p",{children:[(0,ht.jsx)("strong",{children:"Level:"})," ",e.level]}),(0,ht.jsxs)("p",{children:[(0,ht.jsx)("strong",{children:"Email:"})," ",e.contactEmail]}),(0,ht.jsx)("button",{onClick:()=>{return s=e.id,n(t.filter((e=>e.id!==s))),void a(r.filter((e=>e.id!==s)));var s},className:"bg-red-600 text-white px-4 py-2 rounded-lg mt-2 hover:bg-red-700",children:"Delete Collaboration"})]},e.id))):(0,ht.jsx)("p",{children:"No active collaborations available at the moment."})})]}),(0,ht.jsx)("button",{onClick:()=>e("/dashboard"),className:"bg-blue-600 text-white px-4 py-2 rounded-lg mt-6 hover:bg-blue-700",children:"Go Back to Dashboard"})]})},NW=()=>{const[e,t]=(0,i.useState)({title:"",description:"",prerequisites:"",skills:"",level:"",duration:"",mode:"",contactEmail:""}),[n,r]=(0,i.useState)(!1),[a,s]=(0,i.useState)([]),o=n=>{t({...e,[n.target.name]:n.target.value})};return(0,i.useEffect)((()=>{Rr.get("http://localhost:5000/api/study-groups").then((e=>{let{data:t}=e;return s(t)})).catch((()=>{}))}),[]),(0,ht.jsxs)("div",{className:"min-h-screen bg-gradient-to-br from-indigo-50 to-indigo-100 flex flex-col items-center p-8",children:[(0,ht.jsxs)("div",{className:"w-full max-w-4xl flex justify-between items-center bg-white p-6 rounded-xl shadow-lg",children:[(0,ht.jsx)("h2",{className:"text-3xl font-bold text-indigo-700",children:"\ud83d\udcda Study Groups"}),(0,ht.jsx)("button",{onClick:()=>r(!n),className:"px-5 py-3 bg-indigo-600 text-white font-semibold rounded-xl shadow-md hover:bg-indigo-700 transition",children:n?"Close Form":"\u2795 Post a Study Group"})]}),(0,ht.jsxs)("div",{className:"w-full max-w-4xl mt-8",children:[(0,ht.jsx)("h3",{className:"text-2xl font-semibold text-indigo-700 mb-4",children:"Available Study Groups"}),(0,ht.jsx)("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-6",children:a.map((e=>(0,ht.jsxs)("div",{className:"bg-white p-6 rounded-xl shadow-lg border-l-4 border-indigo-500 transform hover:scale-105 transition",children:[(0,ht.jsx)("h4",{className:"text-xl font-semibold text-gray-800",children:e.title}),(0,ht.jsx)("p",{className:"text-gray-600 mt-2",children:e.description}),(0,ht.jsxs)("p",{className:"text-gray-700 mt-2",children:[(0,ht.jsx)("strong",{children:"Skills:"})," ",e.skills]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Level:"})," ",e.level]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Duration:"})," ",e.duration]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"Mode:"})," ",e.mode]}),(0,ht.jsx)("button",{onClick:()=>wW.info(`Form sent to ${e.contactEmail}`,{position:"top-right"}),className:"mt-3 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition",children:"\ud83e\udd1d Connect"}),(0,ht.jsx)("button",{onClick:()=>Rr.delete(`http://localhost:5000/api/study-groups/${e._id}`).then((()=>s(a.filter((t=>t._id!==e._id))))),className:"mt-3 ml-2 px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition",children:"\ud83d\uddd1 Delete"})]},e._id)))})]}),n&&(0,ht.jsxs)("form",{onSubmit:n=>{n.preventDefault(),e.title&&e.description&&e.contactEmail?Rr.post("http://localhost:5000/api/study-groups",e).then((e=>{let{data:n}=e;s([n,...a]),wW.success("Study Group posted successfully! \ud83c\udf89",{position:"top-right"}),t({title:"",description:"",prerequisites:"",skills:"",level:"",duration:"",mode:"",contactEmail:""}),r(!1)})).catch((()=>wW.error("Failed to post study group",{position:"top-right"}))):wW.error("Please fill in the required fields!",{position:"top-right"})},className:"w-full max-w-3xl bg-white p-6 mt-8 rounded-xl shadow-lg transform transition-all animate-fadeIn",children:[(0,ht.jsx)("h3",{className:"text-2xl font-semibold text-indigo-700 mb-4",children:"\ud83d\udccc Create a Study Group"}),["title","description","prerequisites","skills","contactEmail"].map(((t,n)=>(0,ht.jsxs)("div",{className:"mb-4",children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold capitalize",children:t}),(0,ht.jsx)("input",{type:"contactEmail"===t?"email":"text",name:t,value:e[t],onChange:o,required:!0,className:"w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 text-gray-700",placeholder:`Enter ${t}...`})]},n))),[{name:"level",options:["Beginner","Moderate","Hard"]},{name:"duration",options:["4 weeks","2 months"]},{name:"mode",options:["Online","Offline"]}].map(((t,n)=>(0,ht.jsxs)("div",{className:"mb-4",children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold capitalize",children:t.name}),(0,ht.jsxs)("select",{name:t.name,value:e[t.name],onChange:o,required:!0,className:"w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 text-gray-700",children:[(0,ht.jsxs)("option",{value:"",children:["Select ",t.name]}),t.options.map(((e,t)=>(0,ht.jsx)("option",{value:e,children:e},t)))]})]},n))),(0,ht.jsx)("button",{type:"submit",className:"w-full px-5 py-3 bg-indigo-600 text-white font-semibold rounded-xl shadow-md hover:bg-indigo-700 transition",children:"\ud83d\ude80 Submit Study Group"})]})]})},CW=()=>{const[e,t]=(0,i.useState)([]),[n,r]=(0,i.useState)(""),[a,s]=(0,i.useState)(null),[o,l]=(0,i.useState)({}),u=(()=>{try{return JSON.parse(localStorage.getItem("currentUser"))}catch(e){return null}})();(0,i.useEffect)((()=>{(async()=>{try{const{data:e}=await Rr.get("http://localhost:5000/api/queries");t(e)}catch(FW){}})()}),[]);const c=async n=>{const r=(o[n]||"").trim();if(r&&null!==u&&void 0!==u&&u.id)try{const{data:a}=await Rr.post(`http://localhost:5000/api/queries/${n}/comments`,{authorId:u.id,content:r});t(e.map((e=>e._id===n?a:e))),l({...o,[n]:""})}catch(a){}};return(0,ht.jsx)("div",{className:"min-h-screen bg-gradient-to-br from-blue-50 to-blue-100 flex justify-center items-center p-6",children:(0,ht.jsxs)("div",{className:"w-full max-w-2xl bg-white shadow-lg rounded-2xl p-6",children:[(0,ht.jsx)("h2",{className:"text-3xl font-extrabold text-blue-700 text-center",children:"Queries Hub"}),(0,ht.jsx)("p",{className:"text-center text-gray-500 mb-6",children:"Submit, edit, and manage your queries."}),(0,ht.jsxs)("form",{onSubmit:async i=>{if(i.preventDefault(),""!==n.trim()&&null!==u&&void 0!==u&&u.id)try{if(a){const{data:r}=await Rr.patch(`http://localhost:5000/api/queries/${a}`,{content:n});t(e.map((e=>e._id===a?r:e))),s(null)}else{const{data:r}=await Rr.post("http://localhost:5000/api/queries",{authorId:u.id,content:n});t([r,...e])}r("")}catch(o){}},className:"flex flex-col items-center space-y-4",children:[(0,ht.jsx)("input",{type:"text",value:n,onChange:e=>r(e.target.value),placeholder:"Write your query...",className:"w-full p-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-700"}),(0,ht.jsx)("button",{type:"submit",className:`w-full px-5 py-3 font-semibold rounded-xl transition shadow-md ${null!==a?"bg-yellow-500 hover:bg-yellow-600":"bg-blue-600 hover:bg-blue-700"} text-white`,children:null!==a?"Update Query":"Post Query"})]}),(0,ht.jsx)("div",{className:"mt-6 space-y-4",children:e.length>0?e.map(((n,a)=>{var i;return(0,ht.jsxs)("div",{className:"p-4 bg-white border-l-4 border-blue-600 shadow-md rounded-lg",children:[(0,ht.jsxs)("div",{className:"flex items-center gap-4",children:[(0,ht.jsx)("div",{className:"w-10 h-10 flex items-center justify-center bg-blue-500 text-white font-bold rounded-full",children:a+1}),(0,ht.jsx)("p",{className:"text-gray-800 flex-1",children:n.content}),(0,ht.jsx)("button",{onClick:()=>(e=>{r(e.content),s(e._id)})(n),className:"px-3 py-1 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 transition",children:"\u270f\ufe0f Edit"}),(0,ht.jsx)("button",{onClick:()=>(async n=>{try{await Rr.delete(`http://localhost:5000/api/queries/${n}`),t(e.filter((e=>e._id!==n)))}catch(r){}})(n._id),className:"px-3 py-1 bg-red-600 text-white rounded-md hover:bg-red-700 transition",children:"\ud83d\uddd1 Delete"})]}),(0,ht.jsxs)("div",{className:"mt-4",children:[(0,ht.jsx)("h3",{className:"text-gray-700 font-semibold",children:"\ud83d\udcac Answers:"}),(0,ht.jsx)("div",{className:"space-y-2",children:(null===(i=n.comments)||void 0===i?void 0:i.length)>0?n.comments.map(((e,t)=>(0,ht.jsx)("p",{className:"text-gray-600 bg-gray-100 p-2 rounded-md",children:e.content},t))):(0,ht.jsx)("p",{className:"text-gray-400 text-sm",children:"No answers yet. Be the first to reply!"})}),(0,ht.jsxs)("div",{className:"mt-2 flex items-center gap-2",children:[(0,ht.jsx)("input",{type:"text",placeholder:"Write an answer...",className:"flex-1 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400",value:o[n._id]||"",onChange:e=>l({...o,[n._id]:e.target.value}),onKeyDown:e=>{"Enter"===e.key&&c(n._id)}}),(0,ht.jsx)("button",{onClick:()=>c(n._id),className:"px-3 py-1 bg-green-600 text-white rounded-md hover:bg-green-700 transition",children:"\u2795 Reply"})]})]})]},a)})):(0,ht.jsx)("p",{className:"text-center text-gray-400 text-lg",children:"No queries posted yet. Start the discussion!"})})]})})},TW=e=>{let{children:t,onClick:n}=e;return(0,ht.jsx)("button",{onClick:n,className:"px-4 py-2 bg-blue-500 text-white rounded",children:t})},EW=e=>{let{name:t,value:n,onChange:r,placeholder:a}=e;return(0,ht.jsx)("input",{name:t,value:n,onChange:r,placeholder:a,className:"p-2 border rounded w-full"})},$W=e=>{const t=new Date(e);return`${String(t.getDate()).padStart(2,"0")}-${String(t.getMonth()+1).padStart(2,"0")}-${t.getFullYear()}`},RW=()=>{const[e,t]=(0,i.useState)(!1),[n,r]=(0,i.useState)([]),[a,s]=(0,i.useState)({title:"",description:"",date:"",time:"",category:"",speakers:"",location:"",audienceLevel:"General",registrationLink:""}),o=e=>{const{name:t,value:n}=e.target;s({...a,[t]:n})};return(0,i.useEffect)((()=>{Rr.get("http://localhost:5000/api/events").then((e=>{let{data:t}=e;return r(t)})).catch((()=>{}))}),[]),(0,ht.jsxs)("div",{className:"min-h-screen bg-gradient-to-br from-indigo-50 to-indigo-100 flex flex-col items-center p-8",children:[(0,ht.jsxs)("div",{className:"w-full max-w-4xl flex justify-between items-center bg-white p-6 rounded-xl shadow-lg",children:[(0,ht.jsx)("h2",{className:"text-3xl font-bold text-indigo-700",children:"\ud83d\udcc5 Events"}),(0,ht.jsx)("button",{onClick:()=>t(!e),className:"px-5 py-3 bg-indigo-600 text-white font-semibold rounded-xl shadow-md hover:bg-indigo-700 transition",children:e?"Close Form":"\u2795 Post an Event"})]}),(0,ht.jsxs)("div",{className:"w-full max-w-4xl mt-8",children:[(0,ht.jsx)("h3",{className:"text-2xl font-semibold text-indigo-700 mb-4",children:"Upcoming Events"}),(0,ht.jsx)("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-6",children:n.map((e=>(0,ht.jsxs)("div",{className:"bg-white p-6 rounded-xl shadow-lg border-l-4 border-indigo-500 transform hover:scale-105 transition",children:[(0,ht.jsx)("h4",{className:"text-xl font-semibold text-gray-800",children:e.title}),(0,ht.jsx)("p",{className:"text-gray-600 mt-2",children:e.description}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"\ud83d\udcc5 Date:"})," ",e.date]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"\u23f0 Time:"})," ",e.time]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"\ud83d\udccc Category:"})," ",e.category||"N/A"]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"\ud83c\udfa4 Speakers:"})," ",e.speakers||"N/A"]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"\ud83d\udccd Location:"})," ",e.location]}),(0,ht.jsxs)("p",{className:"text-gray-700",children:[(0,ht.jsx)("strong",{children:"\ud83c\udfaf Audience Level:"})," ",e.audienceLevel]}),e.registrationLink&&(0,ht.jsx)("p",{className:"text-blue-600 font-semibold",children:(0,ht.jsx)("a",{href:e.registrationLink,target:"_blank",rel:"noopener noreferrer",children:"\ud83d\udd17 Register Here"})}),(0,ht.jsx)("button",{onClick:()=>wW.info("Organizer details sent!",{position:"top-right"}),className:"mt-3 px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition",children:"\ud83e\udd1d Connect with Organizer"}),(0,ht.jsx)("button",{onClick:()=>Rr.delete(`http://localhost:5000/api/events/${e._id}`).then((()=>r(n.filter((t=>t._id!==e._id))))),className:"mt-3 ml-2 px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition",children:"\ud83d\uddd1 Delete"})]},e._id)))})]}),e&&(0,ht.jsxs)("div",{className:"w-full max-w-3xl bg-white p-6 mt-8 rounded-xl shadow-lg animate-fadeIn",children:[(0,ht.jsx)("h3",{className:"text-2xl font-semibold text-indigo-700 mb-4",children:"\ud83d\udccc Post a New Event"}),["title","description","category","speakers","location","registrationLink"].map(((e,t)=>(0,ht.jsxs)("div",{className:"mb-4",children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold capitalize",children:e.replace(/([A-Z])/g," $1")}),(0,ht.jsx)(EW,{name:e,value:a[e],onChange:o,placeholder:`Enter ${e}...`})]},t))),(0,ht.jsxs)("div",{className:"grid grid-cols-2 gap-4 mb-4",children:[(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold",children:"\ud83d\udcc5 Event Date:"}),(0,ht.jsx)(EW,{name:"date",type:"date",value:a.date,onChange:o})]}),(0,ht.jsxs)("div",{children:[(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold",children:"\u23f0 Event Time:"}),(0,ht.jsx)(EW,{name:"time",type:"time",value:a.time,onChange:o})]})]}),(0,ht.jsx)("label",{className:"block text-gray-700 font-semibold",children:"\ud83c\udfaf Audience Level:"}),(0,ht.jsxs)("select",{name:"audienceLevel",value:a.audienceLevel,onChange:o,className:"w-full p-3 border border-gray-300 rounded-lg mb-4",children:[(0,ht.jsx)("option",{value:"General",children:"General"}),(0,ht.jsx)("option",{value:"Beginners",children:"Beginners"}),(0,ht.jsx)("option",{value:"Intermediate",children:"Intermediate"}),(0,ht.jsx)("option",{value:"Advanced",children:"Advanced"})]}),(0,ht.jsx)(TW,{onClick:()=>{a.title&&a.date&&a.time&&a.location?Rr.post("http://localhost:5000/api/events",{...a,date:$W(a.date)}).then((e=>{let{data:a}=e;r([a,...n]),s({title:"",description:"",date:"",time:"",category:"",speakers:"",location:"",audienceLevel:"General",registrationLink:""}),t(!1),wW.success("Event posted successfully! \ud83c\udf89",{position:"top-right"})})).catch((()=>wW.error("Failed to post event",{position:"top-right"}))):wW.error("Please fill in all required fields!",{position:"top-right"})},className:"w-full py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition",children:"\ud83d\ude80 Post Event"})]})]})};const _W=function(){return(0,ht.jsx)(i.Fragment,{children:(0,ht.jsx)(XB,{children:(0,ht.jsx)(nt,{children:(0,ht.jsxs)(we,{children:[(0,ht.jsx)(xe,{path:"/",element:(0,ht.jsx)(pt,{})}),(0,ht.jsx)(xe,{path:"/landing",element:(0,ht.jsx)(pt,{})}),(0,ht.jsx)(xe,{path:"/login",element:(0,ht.jsx)(_r,{})}),(0,ht.jsx)(xe,{path:"/signup",element:(0,ht.jsx)(Ar,{})}),(0,ht.jsx)(xe,{path:"/dashboard",element:(0,ht.jsx)(QB,{})}),(0,ht.jsx)(xe,{path:"/project",element:(0,ht.jsx)(SW,{})}),(0,ht.jsx)(xe,{path:"/collaborations",element:(0,ht.jsx)(IW,{})}),(0,ht.jsx)(xe,{path:"/studygroup",element:(0,ht.jsx)(NW,{})}),(0,ht.jsx)(xe,{path:"/queries-written",element:(0,ht.jsx)(CW,{})}),(0,ht.jsx)(xe,{path:"/profile-settings",element:(0,ht.jsx)(ZB,{})}),(0,ht.jsx)(xe,{path:"/account-management",element:(0,ht.jsx)(eW,{})}),(0,ht.jsx)(xe,{path:"/signout",element:(0,ht.jsx)(pt,{})}),(0,ht.jsx)(xe,{path:"/event",element:(0,ht.jsx)(RW,{})}),(0,ht.jsx)(xe,{path:"/chat",element:(0,ht.jsx)(YB,{})}),(0,ht.jsx)(xe,{path:"/admin-dashboard",element:(0,ht.jsx)(tW,{})}),(0,ht.jsx)(xe,{path:"/student-details",element:(0,ht.jsx)(JB,{})}),(0,ht.jsx)(xe,{path:"*",element:(0,ht.jsx)(pt,{})})]})})})})},AW=e=>{e&&e instanceof Function&&n.e(488).then(n.bind(n,488)).then((t=>{let{getCLS:n,getFID:r,getFCP:a,getLCP:s,getTTFB:i}=t;n(e),r(e),a(e),s(e),i(e)}))};o.createRoot(document.getElementById("root")).render((0,ht.jsx)(i.StrictMode,{children:(0,ht.jsx)(_W,{})})),AW()})()})();
//# sourceMappingURL=main.193d5b99.js.map